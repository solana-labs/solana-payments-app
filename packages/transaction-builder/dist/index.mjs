var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod3) => function __require2() {
  return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
  mod3
));
var __toCommonJS = (mod3) => __copyProps(__defProp({}, "__esModule", { value: true }), mod3);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// ../../node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "../../node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert4(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number3, base, endian) {
        if (BN2.isBN(number3)) {
          return number3;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number3 !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number3 || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN2;
      } else {
        exports2.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer3;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer3 = window.Buffer;
        } else {
          Buffer3 = __require("buffer").Buffer;
        }
      } catch (e) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN2.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN2.prototype._init = function init(number3, base, endian) {
        if (typeof number3 === "number") {
          return this._initNumber(number3, base, endian);
        }
        if (typeof number3 === "object") {
          return this._initArray(number3, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert4(base === (base | 0) && base >= 2 && base <= 36);
        number3 = number3.toString().replace(/\s+/g, "");
        var start = 0;
        if (number3[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number3.length) {
          if (base === 16) {
            this._parseHex(number3, start, endian);
          } else {
            this._parseBase(number3, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN2.prototype._initNumber = function _initNumber(number3, base, endian) {
        if (number3 < 0) {
          this.negative = 1;
          number3 = -number3;
        }
        if (number3 < 67108864) {
          this.words = [number3 & 67108863];
          this.length = 1;
        } else if (number3 < 4503599627370496) {
          this.words = [
            number3 & 67108863,
            number3 / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert4(number3 < 9007199254740992);
          this.words = [
            number3 & 67108863,
            number3 / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN2.prototype._initArray = function _initArray(number3, base, endian) {
        assert4(typeof number3.length === "number");
        if (number3.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number3.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w2;
        var off = 0;
        if (endian === "be") {
          for (i = number3.length - 1, j = 0; i >= 0; i -= 3) {
            w2 = number3[i] | number3[i - 1] << 8 | number3[i - 2] << 16;
            this.words[j] |= w2 << off & 67108863;
            this.words[j + 1] = w2 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number3.length; i += 3) {
            w2 = number3[i] | number3[i + 1] << 8 | number3[i + 2] << 16;
            this.words[j] |= w2 << off & 67108863;
            this.words[j + 1] = w2 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this._strip();
      };
      function parseHex4Bits(string2, index) {
        var c = string2.charCodeAt(index);
        if (c >= 48 && c <= 57) {
          return c - 48;
        } else if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          assert4(false, "Invalid character in " + string2);
        }
      }
      function parseHexByte(string2, lowerBound, index) {
        var r = parseHex4Bits(string2, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string2, index - 1) << 4;
        }
        return r;
      }
      BN2.prototype._parseHex = function _parseHex(number3, start, endian) {
        this.length = Math.ceil((number3.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w2;
        if (endian === "be") {
          for (i = number3.length - 1; i >= start; i -= 2) {
            w2 = parseHexByte(number3, start, i) << off;
            this.words[j] |= w2 & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w2 >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number3.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number3.length; i += 2) {
            w2 = parseHexByte(number3, start, i) << off;
            this.words[j] |= w2 & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w2 >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this._strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var b = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            b = c - 49 + 10;
          } else if (c >= 17) {
            b = c - 17 + 10;
          } else {
            b = c;
          }
          assert4(c >= 0 && b < mul, "Invalid character");
          r += b;
        }
        return r;
      }
      BN2.prototype._parseBase = function _parseBase(number3, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number3.length - start;
        var mod3 = total % limbLen;
        var end = Math.min(total, total - mod3) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number3, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod3 !== 0) {
          var pow = 1;
          word = parseBase(number3, i, number3.length, base);
          for (i = 0; i < mod3; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this._strip();
      };
      BN2.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      function move(dest, src2) {
        dest.words = src2.words;
        dest.length = src2.length;
        dest.negative = src2.negative;
        dest.red = src2.red;
      }
      BN2.prototype._move = function _move(dest) {
        move(dest, this);
      };
      BN2.prototype.clone = function clone3() {
        var r = new BN2(null);
        this.copy(r);
        return r;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
        try {
          BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect2;
        } catch (e) {
          BN2.prototype.inspect = inspect2;
        }
      } else {
        BN2.prototype.inspect = inspect2;
      }
      function inspect2() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w2 = this.words[i];
            var word = ((w2 << off | carry) & 16777215).toString(16);
            carry = w2 >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modrn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert4(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert4(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };
      if (Buffer3) {
        BN2.prototype.toBuffer = function toBuffer2(endian, length) {
          return this.toArrayLike(Buffer3, endian, length);
        };
      }
      BN2.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      var allocate = function allocate2(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert4(byteLength <= reqLength, "byte array longer than desired length");
        assert4(reqLength > 0, "Requested array length <= 0");
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === "le" ? "LE" : "BE";
        this["_toArrayLike" + postfix](res, byteLength);
        return res;
      };
      BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position++] = word & 255;
          if (position < res.length) {
            res[position++] = word >> 8 & 255;
          }
          if (position < res.length) {
            res[position++] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position < res.length) {
          res[position++] = carry;
          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };
      BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position--] = word & 255;
          if (position >= 0) {
            res[position--] = word >> 8 & 255;
          }
          if (position >= 0) {
            res[position--] = word >> 16 & 255;
          }
          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 255;
            }
            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }
        if (position >= 0) {
          res[position--] = carry;
          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w2) {
          return 32 - Math.clz32(w2);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w2) {
          var t = w2;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w2) {
        if (w2 === 0)
          return 26;
        var t = w2;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w2 = this.words[this.length - 1];
        var hi = this._countBits(w2);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w2 = new Array(num.bitLength());
        for (var bit = 0; bit < w2.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w2[bit] = num.words[off] >>> wbit & 1;
        }
        return w2;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN2.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this._strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert4((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this._strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert4((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this._strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert4((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert4(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this._strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert4(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN2.prototype.add = function add2(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this._strip();
      };
      BN2.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out._strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out._strip();
      }
      function jumboMulTo(self2, num, out) {
        return bigMulTo(self2, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y2) {
        this.x = x;
        this.y = y2;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN2.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s2 = 1; s2 < N; s2 <<= 1) {
          var l = s2 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s2; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s2];
              var io = itws[p + j + s2];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s2] = re - ro;
              itws[p + j + s2] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m2) {
        var N = Math.max(m2, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w2 = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w2 & 67108863;
          if (w2 < 67108864) {
            carry = 0;
          } else {
            carry = w2 / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert4(carry === 0);
        assert4((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y2, out) {
        var N = 2 * this.guessLen13b(x.length, y2.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y2.words, y2.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y2.negative;
        out.length = x.length + y2.length;
        return out._strip();
      };
      BN2.prototype.mul = function mul(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert4(typeof num === "number");
        assert4(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w2 = (this.words[i] | 0) * num;
          var lo = (w2 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w2 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return isNegNum ? this.ineg() : this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow(num) {
        var w2 = toBitArray(num);
        if (w2.length === 0)
          return new BN2(1);
        var res = this;
        for (var i = 0; i < w2.length; i++, res = res.sqr()) {
          if (w2[i] !== 0)
            break;
        }
        if (++i < w2.length) {
          for (var q = res.sqr(); i < w2.length; i++, q = q.sqr()) {
            if (w2[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert4(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s2 = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s2 !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s2] = this.words[i];
          }
          for (i = 0; i < s2; i++) {
            this.words[i] = 0;
          }
          this.length += s2;
        }
        return this._strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert4(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert4(typeof bits === "number" && bits >= 0);
        var h2;
        if (hint) {
          h2 = (hint - hint % 26) / 26;
        } else {
          h2 = 0;
        }
        var r = bits % 26;
        var s2 = Math.min((bits - r) / 26, this.length);
        var mask2 = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h2 -= s2;
        h2 = Math.max(0, h2);
        if (maskedWords) {
          for (var i = 0; i < s2; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s2;
        }
        if (s2 === 0) {
        } else if (this.length > s2) {
          this.length -= s2;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s2];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h2); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask2;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this._strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert4(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert4(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s2 = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s2)
          return false;
        var w2 = this.words[s2];
        return !!(w2 & q);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert4(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s2 = (bits - r) / 26;
        assert4(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s2) {
          return this;
        }
        if (r !== 0) {
          s2++;
        }
        this.length = Math.min(s2, this.length);
        if (r !== 0) {
          var mask2 = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask2;
        }
        return this._strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert4(typeof num === "number");
        assert4(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert4(typeof num === "number");
        assert4(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this._strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w2;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w2 = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w2 -= right & 67108863;
          carry = (w2 >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w2 & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w2 = (this.words[i + shift] | 0) + carry;
          carry = w2 >> 26;
          this.words[i + shift] = w2 & 67108863;
        }
        if (carry === 0)
          return this._strip();
        assert4(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w2 = -(this.words[i] | 0) + carry;
          carry = w2 >> 26;
          this.words[i] = w2 & 67108863;
        }
        this.negative = 1;
        return this._strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m2 = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN2(null);
          q.length = m2 + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m2);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m2] = 1;
          }
        }
        for (var j = m2 - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q._strip();
        }
        a._strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN2.prototype.divmod = function divmod(num, mode, positive) {
        assert4(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod3, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod3 = res.mod.neg();
            if (positive && mod3.negative !== 0) {
              mod3.iadd(num);
            }
          }
          return {
            div,
            mod: mod3
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod3 = res.mod.neg();
            if (positive && mod3.negative !== 0) {
              mod3.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod3
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modrn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modrn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN2.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod3(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod3 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod3.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert4(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
      };
      BN2.prototype.modn = function modn(num) {
        return this.modrn(num);
      };
      BN2.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum)
          num = -num;
        assert4(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w2 = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w2 / num | 0;
          carry = w2 % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p) {
        assert4(p.negative === 0);
        assert4(!p.isZero());
        var x = this;
        var y2 = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN2(1);
        var B = new BN2(0);
        var C = new BN2(0);
        var D = new BN2(1);
        var g = 0;
        while (x.isEven() && y2.isEven()) {
          x.iushrn(1);
          y2.iushrn(1);
          ++g;
        }
        var yp = y2.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y2.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y2.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y2) >= 0) {
            x.isub(y2);
            A.isub(C);
            B.isub(D);
          } else {
            y2.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y2.iushln(g)
        };
      };
      BN2.prototype._invmp = function _invmp(p) {
        assert4(p.negative === 0);
        assert4(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN2(1);
        var x2 = new BN2(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd2() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert4(typeof bit === "number");
        var r = bit % 26;
        var s2 = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s2) {
          this._expand(s2 + 1);
          this.words[s2] |= q;
          return this;
        }
        var carry = q;
        for (var i = s2; carry !== 0 && i < this.length; i++) {
          var w2 = this.words[i] | 0;
          w2 += carry;
          carry = w2 >>> 26;
          w2 &= 67108863;
          this.words[i] = w2;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this._strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert4(num <= 67108863, "Number is too big");
          var w2 = this.words[0] | 0;
          res = w2 === num ? 0 : w2 < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert4(!this.red, "Already a number in reduction context");
        assert4(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert4(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert4(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert4(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert4(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert4(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert4(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert4(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert4(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert4(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert4(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert4(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert4(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert4(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert4(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert4(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN2(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split2(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split2(input, output2) {
        var mask2 = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output2.words[i] = input.words[i];
        }
        output2.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output2.words[output2.length++] = prev & mask2;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask2) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w2 = num.words[i] | 0;
          lo += w2 * 977;
          num.words[i] = lo & 67108863;
          lo = w2 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m2) {
        if (typeof m2 === "string") {
          var prime = BN2._prime(m2);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert4(m2.gtn(1), "modulus must be greater than 1");
          this.m = m2;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert4(a.negative === 0, "red works only with positives");
        assert4(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert4((a.negative | b.negative) === 0, "red works only with positives");
        assert4(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add2(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert4(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s2 = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s2++;
          q.iushrn(1);
        }
        assert4(!q.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z2 = this.m.bitLength();
        z2 = new BN2(2 * z2 * z2).toRed(this);
        while (this.pow(z2, lpow).cmp(nOne) !== 0) {
          z2.redIAdd(nOne);
        }
        var c = this.pow(z2, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m2 = s2;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert4(i < m2);
          var b = this.pow(c, new BN2(1).iushln(m2 - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m2 = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m2) {
        Red.call(this, m2);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN2(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// ../../node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "../../node_modules/safe-buffer/index.js"(exports, module) {
    var buffer = __require("buffer");
    var Buffer3 = buffer.Buffer;
    function copyProps(src2, dst) {
      for (var key in src2) {
        dst[key] = src2[key];
      }
    }
    if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer3(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer3.prototype);
    copyProps(Buffer3, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer3(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer3(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer3(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../../node_modules/base-x/src/index.js
var require_src = __commonJS({
  "../../node_modules/base-x/src/index.js"(exports, module) {
    "use strict";
    var _Buffer = require_safe_buffer().Buffer;
    function base(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j = 0; j < BASE_MAP.length; j++) {
        BASE_MAP[j] = 255;
      }
      for (var i = 0; i < ALPHABET.length; i++) {
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
      }
      var BASE2 = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE2) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE2);
      function encode(source) {
        if (Array.isArray(source) || source instanceof Uint8Array) {
          source = _Buffer.from(source);
        }
        if (!_Buffer.isBuffer(source)) {
          throw new TypeError("Expected Buffer");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i2 = 0;
          for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE2 >>> 0;
            carry = carry / BASE2 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          pbegin++;
        }
        var it2 = size - length;
        while (it2 !== size && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return _Buffer.alloc(0);
        }
        var psz = 0;
        var zeroes = 0;
        var length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i2 = 0;
          for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
            carry += BASE2 * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i2;
          psz++;
        }
        var it4 = size - length;
        while (it4 !== size && b256[it4] === 0) {
          it4++;
        }
        var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
        vch.fill(0, 0, zeroes);
        var j2 = zeroes;
        while (it4 !== size) {
          vch[j2++] = b256[it4++];
        }
        return vch;
      }
      function decode(string2) {
        var buffer = decodeUnsafe(string2);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE2 + " character");
      }
      return {
        encode,
        decodeUnsafe,
        decode
      };
    }
    module.exports = base;
  }
});

// ../../node_modules/bs58/index.js
var require_bs58 = __commonJS({
  "../../node_modules/bs58/index.js"(exports, module) {
    var basex = require_src();
    var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module.exports = basex(ALPHABET);
  }
});

// ../../node_modules/text-encoding-utf-8/lib/encoding.lib.js
var require_encoding_lib = __commonJS({
  "../../node_modules/text-encoding-utf-8/lib/encoding.lib.js"(exports) {
    "use strict";
    function inRange(a, min, max) {
      return min <= a && a <= max;
    }
    function ToDictionary(o) {
      if (o === void 0)
        return {};
      if (o === Object(o))
        return o;
      throw TypeError("Could not convert argument to dictionary");
    }
    function stringToCodePoints(string2) {
      var s2 = String(string2);
      var n = s2.length;
      var i = 0;
      var u = [];
      while (i < n) {
        var c = s2.charCodeAt(i);
        if (c < 55296 || c > 57343) {
          u.push(c);
        } else if (56320 <= c && c <= 57343) {
          u.push(65533);
        } else if (55296 <= c && c <= 56319) {
          if (i === n - 1) {
            u.push(65533);
          } else {
            var d2 = string2.charCodeAt(i + 1);
            if (56320 <= d2 && d2 <= 57343) {
              var a = c & 1023;
              var b = d2 & 1023;
              u.push(65536 + (a << 10) + b);
              i += 1;
            } else {
              u.push(65533);
            }
          }
        }
        i += 1;
      }
      return u;
    }
    function codePointsToString(code_points) {
      var s2 = "";
      for (var i = 0; i < code_points.length; ++i) {
        var cp = code_points[i];
        if (cp <= 65535) {
          s2 += String.fromCharCode(cp);
        } else {
          cp -= 65536;
          s2 += String.fromCharCode(
            (cp >> 10) + 55296,
            (cp & 1023) + 56320
          );
        }
      }
      return s2;
    }
    var end_of_stream = -1;
    function Stream2(tokens) {
      this.tokens = [].slice.call(tokens);
    }
    Stream2.prototype = {
      /**
       * @return {boolean} True if end-of-stream has been hit.
       */
      endOfStream: function() {
        return !this.tokens.length;
      },
      /**
       * When a token is read from a stream, the first token in the
       * stream must be returned and subsequently removed, and
       * end-of-stream must be returned otherwise.
       *
       * @return {number} Get the next token from the stream, or
       * end_of_stream.
       */
      read: function() {
        if (!this.tokens.length)
          return end_of_stream;
        return this.tokens.shift();
      },
      /**
       * When one or more tokens are prepended to a stream, those tokens
       * must be inserted, in given order, before the first token in the
       * stream.
       *
       * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.
       */
      prepend: function(token) {
        if (Array.isArray(token)) {
          var tokens = (
            /**@type {!Array.<number>}*/
            token
          );
          while (tokens.length)
            this.tokens.unshift(tokens.pop());
        } else {
          this.tokens.unshift(token);
        }
      },
      /**
       * When one or more tokens are pushed to a stream, those tokens
       * must be inserted, in given order, after the last token in the
       * stream.
       *
       * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.
       */
      push: function(token) {
        if (Array.isArray(token)) {
          var tokens = (
            /**@type {!Array.<number>}*/
            token
          );
          while (tokens.length)
            this.tokens.push(tokens.shift());
        } else {
          this.tokens.push(token);
        }
      }
    };
    var finished = -1;
    function decoderError(fatal, opt_code_point) {
      if (fatal)
        throw TypeError("Decoder error");
      return opt_code_point || 65533;
    }
    var DEFAULT_ENCODING = "utf-8";
    function TextDecoder2(encoding, options) {
      if (!(this instanceof TextDecoder2)) {
        return new TextDecoder2(encoding, options);
      }
      encoding = encoding !== void 0 ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
      if (encoding !== DEFAULT_ENCODING) {
        throw new Error("Encoding not supported. Only utf-8 is supported");
      }
      options = ToDictionary(options);
      this._streaming = false;
      this._BOMseen = false;
      this._decoder = null;
      this._fatal = Boolean(options["fatal"]);
      this._ignoreBOM = Boolean(options["ignoreBOM"]);
      Object.defineProperty(this, "encoding", { value: "utf-8" });
      Object.defineProperty(this, "fatal", { value: this._fatal });
      Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
    }
    TextDecoder2.prototype = {
      /**
       * @param {ArrayBufferView=} input The buffer of bytes to decode.
       * @param {Object=} options
       * @return {string} The decoded string.
       */
      decode: function decode(input, options) {
        var bytes2;
        if (typeof input === "object" && input instanceof ArrayBuffer) {
          bytes2 = new Uint8Array(input);
        } else if (typeof input === "object" && "buffer" in input && input.buffer instanceof ArrayBuffer) {
          bytes2 = new Uint8Array(
            input.buffer,
            input.byteOffset,
            input.byteLength
          );
        } else {
          bytes2 = new Uint8Array(0);
        }
        options = ToDictionary(options);
        if (!this._streaming) {
          this._decoder = new UTF8Decoder({ fatal: this._fatal });
          this._BOMseen = false;
        }
        this._streaming = Boolean(options["stream"]);
        var input_stream = new Stream2(bytes2);
        var code_points = [];
        var result;
        while (!input_stream.endOfStream()) {
          result = this._decoder.handler(input_stream, input_stream.read());
          if (result === finished)
            break;
          if (result === null)
            continue;
          if (Array.isArray(result))
            code_points.push.apply(
              code_points,
              /**@type {!Array.<number>}*/
              result
            );
          else
            code_points.push(result);
        }
        if (!this._streaming) {
          do {
            result = this._decoder.handler(input_stream, input_stream.read());
            if (result === finished)
              break;
            if (result === null)
              continue;
            if (Array.isArray(result))
              code_points.push.apply(
                code_points,
                /**@type {!Array.<number>}*/
                result
              );
            else
              code_points.push(result);
          } while (!input_stream.endOfStream());
          this._decoder = null;
        }
        if (code_points.length) {
          if (["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen) {
            if (code_points[0] === 65279) {
              this._BOMseen = true;
              code_points.shift();
            } else {
              this._BOMseen = true;
            }
          }
        }
        return codePointsToString(code_points);
      }
    };
    function TextEncoder2(encoding, options) {
      if (!(this instanceof TextEncoder2))
        return new TextEncoder2(encoding, options);
      encoding = encoding !== void 0 ? String(encoding).toLowerCase() : DEFAULT_ENCODING;
      if (encoding !== DEFAULT_ENCODING) {
        throw new Error("Encoding not supported. Only utf-8 is supported");
      }
      options = ToDictionary(options);
      this._streaming = false;
      this._encoder = null;
      this._options = { fatal: Boolean(options["fatal"]) };
      Object.defineProperty(this, "encoding", { value: "utf-8" });
    }
    TextEncoder2.prototype = {
      /**
       * @param {string=} opt_string The string to encode.
       * @param {Object=} options
       * @return {Uint8Array} Encoded bytes, as a Uint8Array.
       */
      encode: function encode(opt_string, options) {
        opt_string = opt_string ? String(opt_string) : "";
        options = ToDictionary(options);
        if (!this._streaming)
          this._encoder = new UTF8Encoder(this._options);
        this._streaming = Boolean(options["stream"]);
        var bytes2 = [];
        var input_stream = new Stream2(stringToCodePoints(opt_string));
        var result;
        while (!input_stream.endOfStream()) {
          result = this._encoder.handler(input_stream, input_stream.read());
          if (result === finished)
            break;
          if (Array.isArray(result))
            bytes2.push.apply(
              bytes2,
              /**@type {!Array.<number>}*/
              result
            );
          else
            bytes2.push(result);
        }
        if (!this._streaming) {
          while (true) {
            result = this._encoder.handler(input_stream, input_stream.read());
            if (result === finished)
              break;
            if (Array.isArray(result))
              bytes2.push.apply(
                bytes2,
                /**@type {!Array.<number>}*/
                result
              );
            else
              bytes2.push(result);
          }
          this._encoder = null;
        }
        return new Uint8Array(bytes2);
      }
    };
    function UTF8Decoder(options) {
      var fatal = options.fatal;
      var utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;
      this.handler = function(stream, bite) {
        if (bite === end_of_stream && utf8_bytes_needed !== 0) {
          utf8_bytes_needed = 0;
          return decoderError(fatal);
        }
        if (bite === end_of_stream)
          return finished;
        if (utf8_bytes_needed === 0) {
          if (inRange(bite, 0, 127)) {
            return bite;
          }
          if (inRange(bite, 194, 223)) {
            utf8_bytes_needed = 1;
            utf8_code_point = bite - 192;
          } else if (inRange(bite, 224, 239)) {
            if (bite === 224)
              utf8_lower_boundary = 160;
            if (bite === 237)
              utf8_upper_boundary = 159;
            utf8_bytes_needed = 2;
            utf8_code_point = bite - 224;
          } else if (inRange(bite, 240, 244)) {
            if (bite === 240)
              utf8_lower_boundary = 144;
            if (bite === 244)
              utf8_upper_boundary = 143;
            utf8_bytes_needed = 3;
            utf8_code_point = bite - 240;
          } else {
            return decoderError(fatal);
          }
          utf8_code_point = utf8_code_point << 6 * utf8_bytes_needed;
          return null;
        }
        if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {
          utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
          utf8_lower_boundary = 128;
          utf8_upper_boundary = 191;
          stream.prepend(bite);
          return decoderError(fatal);
        }
        utf8_lower_boundary = 128;
        utf8_upper_boundary = 191;
        utf8_bytes_seen += 1;
        utf8_code_point += bite - 128 << 6 * (utf8_bytes_needed - utf8_bytes_seen);
        if (utf8_bytes_seen !== utf8_bytes_needed)
          return null;
        var code_point = utf8_code_point;
        utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
        return code_point;
      };
    }
    function UTF8Encoder(options) {
      var fatal = options.fatal;
      this.handler = function(stream, code_point) {
        if (code_point === end_of_stream)
          return finished;
        if (inRange(code_point, 0, 127))
          return code_point;
        var count, offset2;
        if (inRange(code_point, 128, 2047)) {
          count = 1;
          offset2 = 192;
        } else if (inRange(code_point, 2048, 65535)) {
          count = 2;
          offset2 = 224;
        } else if (inRange(code_point, 65536, 1114111)) {
          count = 3;
          offset2 = 240;
        }
        var bytes2 = [(code_point >> 6 * count) + offset2];
        while (count > 0) {
          var temp = code_point >> 6 * (count - 1);
          bytes2.push(128 | temp & 63);
          count -= 1;
        }
        return bytes2;
      };
    }
    exports.TextEncoder = TextEncoder2;
    exports.TextDecoder = TextDecoder2;
  }
});

// ../../node_modules/borsh/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/borsh/lib/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m2[k];
      } });
    } : function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m2[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __decorate = exports && exports.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d2 = decorators[i])
            r = (c < 3 ? d2(r) : c > 3 ? d2(target, key, r) : d2(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __importStar = exports && exports.__importStar || function(mod3) {
      if (mod3 && mod3.__esModule)
        return mod3;
      var result = {};
      if (mod3 != null) {
        for (var k in mod3)
          if (k !== "default" && Object.hasOwnProperty.call(mod3, k))
            __createBinding(result, mod3, k);
      }
      __setModuleDefault(result, mod3);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod3) {
      return mod3 && mod3.__esModule ? mod3 : { "default": mod3 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deserializeUnchecked = exports.deserialize = exports.serialize = exports.BinaryReader = exports.BinaryWriter = exports.BorshError = exports.baseDecode = exports.baseEncode = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var bs58_1 = __importDefault(require_bs58());
    var encoding = __importStar(require_encoding_lib());
    var ResolvedTextDecoder = typeof TextDecoder !== "function" ? encoding.TextDecoder : TextDecoder;
    var textDecoder = new ResolvedTextDecoder("utf-8", { fatal: true });
    function baseEncode(value) {
      if (typeof value === "string") {
        value = Buffer.from(value, "utf8");
      }
      return bs58_1.default.encode(Buffer.from(value));
    }
    exports.baseEncode = baseEncode;
    function baseDecode(value) {
      return Buffer.from(bs58_1.default.decode(value));
    }
    exports.baseDecode = baseDecode;
    var INITIAL_LENGTH = 1024;
    var BorshError = class extends Error {
      constructor(message2) {
        super(message2);
        this.fieldPath = [];
        this.originalMessage = message2;
      }
      addToFieldPath(fieldName) {
        this.fieldPath.splice(0, 0, fieldName);
        this.message = this.originalMessage + ": " + this.fieldPath.join(".");
      }
    };
    exports.BorshError = BorshError;
    var BinaryWriter = class {
      constructor() {
        this.buf = Buffer.alloc(INITIAL_LENGTH);
        this.length = 0;
      }
      maybeResize() {
        if (this.buf.length < 16 + this.length) {
          this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);
        }
      }
      writeU8(value) {
        this.maybeResize();
        this.buf.writeUInt8(value, this.length);
        this.length += 1;
      }
      writeU16(value) {
        this.maybeResize();
        this.buf.writeUInt16LE(value, this.length);
        this.length += 2;
      }
      writeU32(value) {
        this.maybeResize();
        this.buf.writeUInt32LE(value, this.length);
        this.length += 4;
      }
      writeU64(value) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 8)));
      }
      writeU128(value) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 16)));
      }
      writeU256(value) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 32)));
      }
      writeU512(value) {
        this.maybeResize();
        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray("le", 64)));
      }
      writeBuffer(buffer) {
        this.buf = Buffer.concat([
          Buffer.from(this.buf.subarray(0, this.length)),
          buffer,
          Buffer.alloc(INITIAL_LENGTH)
        ]);
        this.length += buffer.length;
      }
      writeString(str) {
        this.maybeResize();
        const b = Buffer.from(str, "utf8");
        this.writeU32(b.length);
        this.writeBuffer(b);
      }
      writeFixedArray(array2) {
        this.writeBuffer(Buffer.from(array2));
      }
      writeArray(array2, fn2) {
        this.maybeResize();
        this.writeU32(array2.length);
        for (const elem of array2) {
          this.maybeResize();
          fn2(elem);
        }
      }
      toArray() {
        return this.buf.subarray(0, this.length);
      }
    };
    exports.BinaryWriter = BinaryWriter;
    function handlingRangeError(target, propertyKey, propertyDescriptor) {
      const originalMethod = propertyDescriptor.value;
      propertyDescriptor.value = function(...args2) {
        try {
          return originalMethod.apply(this, args2);
        } catch (e) {
          if (e instanceof RangeError) {
            const code = e.code;
            if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(code) >= 0) {
              throw new BorshError("Reached the end of buffer when deserializing");
            }
          }
          throw e;
        }
      };
    }
    var BinaryReader = class {
      constructor(buf) {
        this.buf = buf;
        this.offset = 0;
      }
      readU8() {
        const value = this.buf.readUInt8(this.offset);
        this.offset += 1;
        return value;
      }
      readU16() {
        const value = this.buf.readUInt16LE(this.offset);
        this.offset += 2;
        return value;
      }
      readU32() {
        const value = this.buf.readUInt32LE(this.offset);
        this.offset += 4;
        return value;
      }
      readU64() {
        const buf = this.readBuffer(8);
        return new bn_js_1.default(buf, "le");
      }
      readU128() {
        const buf = this.readBuffer(16);
        return new bn_js_1.default(buf, "le");
      }
      readU256() {
        const buf = this.readBuffer(32);
        return new bn_js_1.default(buf, "le");
      }
      readU512() {
        const buf = this.readBuffer(64);
        return new bn_js_1.default(buf, "le");
      }
      readBuffer(len) {
        if (this.offset + len > this.buf.length) {
          throw new BorshError(`Expected buffer length ${len} isn't within bounds`);
        }
        const result = this.buf.slice(this.offset, this.offset + len);
        this.offset += len;
        return result;
      }
      readString() {
        const len = this.readU32();
        const buf = this.readBuffer(len);
        try {
          return textDecoder.decode(buf);
        } catch (e) {
          throw new BorshError(`Error decoding UTF-8 string: ${e}`);
        }
      }
      readFixedArray(len) {
        return new Uint8Array(this.readBuffer(len));
      }
      readArray(fn2) {
        const len = this.readU32();
        const result = Array();
        for (let i = 0; i < len; ++i) {
          result.push(fn2());
        }
        return result;
      }
    };
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU8", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU16", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU32", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU64", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU128", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU256", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readU512", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readString", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readFixedArray", null);
    __decorate([
      handlingRangeError
    ], BinaryReader.prototype, "readArray", null);
    exports.BinaryReader = BinaryReader;
    function capitalizeFirstLetter(string2) {
      return string2.charAt(0).toUpperCase() + string2.slice(1);
    }
    function serializeField(schema, fieldName, value, fieldType, writer) {
      try {
        if (typeof fieldType === "string") {
          writer[`write${capitalizeFirstLetter(fieldType)}`](value);
        } else if (fieldType instanceof Array) {
          if (typeof fieldType[0] === "number") {
            if (value.length !== fieldType[0]) {
              throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);
            }
            writer.writeFixedArray(value);
          } else if (fieldType.length === 2 && typeof fieldType[1] === "number") {
            if (value.length !== fieldType[1]) {
              throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);
            }
            for (let i = 0; i < fieldType[1]; i++) {
              serializeField(schema, null, value[i], fieldType[0], writer);
            }
          } else {
            writer.writeArray(value, (item) => {
              serializeField(schema, fieldName, item, fieldType[0], writer);
            });
          }
        } else if (fieldType.kind !== void 0) {
          switch (fieldType.kind) {
            case "option": {
              if (value === null || value === void 0) {
                writer.writeU8(0);
              } else {
                writer.writeU8(1);
                serializeField(schema, fieldName, value, fieldType.type, writer);
              }
              break;
            }
            case "map": {
              writer.writeU32(value.size);
              value.forEach((val, key) => {
                serializeField(schema, fieldName, key, fieldType.key, writer);
                serializeField(schema, fieldName, val, fieldType.value, writer);
              });
              break;
            }
            default:
              throw new BorshError(`FieldType ${fieldType} unrecognized`);
          }
        } else {
          serializeStruct(schema, value, writer);
        }
      } catch (error) {
        if (error instanceof BorshError) {
          error.addToFieldPath(fieldName);
        }
        throw error;
      }
    }
    function serializeStruct(schema, obj, writer) {
      if (typeof obj.borshSerialize === "function") {
        obj.borshSerialize(writer);
        return;
      }
      const structSchema = schema.get(obj.constructor);
      if (!structSchema) {
        throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);
      }
      if (structSchema.kind === "struct") {
        structSchema.fields.map(([fieldName, fieldType]) => {
          serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
        });
      } else if (structSchema.kind === "enum") {
        const name = obj[structSchema.field];
        for (let idx = 0; idx < structSchema.values.length; ++idx) {
          const [fieldName, fieldType] = structSchema.values[idx];
          if (fieldName === name) {
            writer.writeU8(idx);
            serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
            break;
          }
        }
      } else {
        throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);
      }
    }
    function serialize2(schema, obj, Writer = BinaryWriter) {
      const writer = new Writer();
      serializeStruct(schema, obj, writer);
      return writer.toArray();
    }
    exports.serialize = serialize2;
    function deserializeField(schema, fieldName, fieldType, reader) {
      try {
        if (typeof fieldType === "string") {
          return reader[`read${capitalizeFirstLetter(fieldType)}`]();
        }
        if (fieldType instanceof Array) {
          if (typeof fieldType[0] === "number") {
            return reader.readFixedArray(fieldType[0]);
          } else if (typeof fieldType[1] === "number") {
            const arr = [];
            for (let i = 0; i < fieldType[1]; i++) {
              arr.push(deserializeField(schema, null, fieldType[0], reader));
            }
            return arr;
          } else {
            return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));
          }
        }
        if (fieldType.kind === "option") {
          const option = reader.readU8();
          if (option) {
            return deserializeField(schema, fieldName, fieldType.type, reader);
          }
          return void 0;
        }
        if (fieldType.kind === "map") {
          let map = /* @__PURE__ */ new Map();
          const length = reader.readU32();
          for (let i = 0; i < length; i++) {
            const key = deserializeField(schema, fieldName, fieldType.key, reader);
            const val = deserializeField(schema, fieldName, fieldType.value, reader);
            map.set(key, val);
          }
          return map;
        }
        return deserializeStruct(schema, fieldType, reader);
      } catch (error) {
        if (error instanceof BorshError) {
          error.addToFieldPath(fieldName);
        }
        throw error;
      }
    }
    function deserializeStruct(schema, classType, reader) {
      if (typeof classType.borshDeserialize === "function") {
        return classType.borshDeserialize(reader);
      }
      const structSchema = schema.get(classType);
      if (!structSchema) {
        throw new BorshError(`Class ${classType.name} is missing in schema`);
      }
      if (structSchema.kind === "struct") {
        const result = {};
        for (const [fieldName, fieldType] of schema.get(classType).fields) {
          result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);
        }
        return new classType(result);
      }
      if (structSchema.kind === "enum") {
        const idx = reader.readU8();
        if (idx >= structSchema.values.length) {
          throw new BorshError(`Enum index: ${idx} is out of range`);
        }
        const [fieldName, fieldType] = structSchema.values[idx];
        const fieldValue = deserializeField(schema, fieldName, fieldType, reader);
        return new classType({ [fieldName]: fieldValue });
      }
      throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);
    }
    function deserialize2(schema, classType, buffer, Reader = BinaryReader) {
      const reader = new Reader(buffer);
      const result = deserializeStruct(schema, classType, reader);
      if (reader.offset < buffer.length) {
        throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);
      }
      return result;
    }
    exports.deserialize = deserialize2;
    function deserializeUnchecked2(schema, classType, buffer, Reader = BinaryReader) {
      const reader = new Reader(buffer);
      return deserializeStruct(schema, classType, reader);
    }
    exports.deserializeUnchecked = deserializeUnchecked2;
  }
});

// ../../node_modules/@solana/buffer-layout/lib/Layout.js
var require_Layout = __commonJS({
  "../../node_modules/@solana/buffer-layout/lib/Layout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.s16 = exports.s8 = exports.nu64be = exports.u48be = exports.u40be = exports.u32be = exports.u24be = exports.u16be = exports.nu64 = exports.u48 = exports.u40 = exports.u32 = exports.u24 = exports.u16 = exports.u8 = exports.offset = exports.greedy = exports.Constant = exports.UTF8 = exports.CString = exports.Blob = exports.Boolean = exports.BitField = exports.BitStructure = exports.VariantLayout = exports.Union = exports.UnionLayoutDiscriminator = exports.UnionDiscriminator = exports.Structure = exports.Sequence = exports.DoubleBE = exports.Double = exports.FloatBE = exports.Float = exports.NearInt64BE = exports.NearInt64 = exports.NearUInt64BE = exports.NearUInt64 = exports.IntBE = exports.Int = exports.UIntBE = exports.UInt = exports.OffsetLayout = exports.GreedyCount = exports.ExternalLayout = exports.bindConstructorLayout = exports.nameWithProperty = exports.Layout = exports.uint8ArrayToBuffer = exports.checkUint8Array = void 0;
    exports.constant = exports.utf8 = exports.cstr = exports.blob = exports.unionLayoutDiscriminator = exports.union = exports.seq = exports.bits = exports.struct = exports.f64be = exports.f64 = exports.f32be = exports.f32 = exports.ns64be = exports.s48be = exports.s40be = exports.s32be = exports.s24be = exports.s16be = exports.ns64 = exports.s48 = exports.s40 = exports.s32 = exports.s24 = void 0;
    var buffer_1 = __require("buffer");
    function checkUint8Array(b) {
      if (!(b instanceof Uint8Array)) {
        throw new TypeError("b must be a Uint8Array");
      }
    }
    exports.checkUint8Array = checkUint8Array;
    function uint8ArrayToBuffer(b) {
      checkUint8Array(b);
      return buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);
    }
    exports.uint8ArrayToBuffer = uint8ArrayToBuffer;
    var Layout = class {
      constructor(span, property) {
        if (!Number.isInteger(span)) {
          throw new TypeError("span must be an integer");
        }
        this.span = span;
        this.property = property;
      }
      /** Function to create an Object into which decoded properties will
       * be written.
       *
       * Used only for layouts that {@link Layout#decode|decode} to Object
       * instances, which means:
       * * {@link Structure}
       * * {@link Union}
       * * {@link VariantLayout}
       * * {@link BitStructure}
       *
       * If left undefined the JavaScript representation of these layouts
       * will be Object instances.
       *
       * See {@link bindConstructorLayout}.
       */
      makeDestinationObject() {
        return {};
      }
      /**
       * Calculate the span of a specific instance of a layout.
       *
       * @param {Uint8Array} b - the buffer that contains an encoded instance.
       *
       * @param {Number} [offset] - the offset at which the encoded instance
       * starts.  If absent a zero offset is inferred.
       *
       * @return {Number} - the number of bytes covered by the layout
       * instance.  If this method is not overridden in a subclass the
       * definition-time constant {@link Layout#span|span} will be
       * returned.
       *
       * @throws {RangeError} - if the length of the value cannot be
       * determined.
       */
      getSpan(b, offset2) {
        if (0 > this.span) {
          throw new RangeError("indeterminate span");
        }
        return this.span;
      }
      /**
       * Replicate the layout using a new property.
       *
       * This function must be used to get a structurally-equivalent layout
       * with a different name since all {@link Layout} instances are
       * immutable.
       *
       * **NOTE** This is a shallow copy.  All fields except {@link
       * Layout#property|property} are strictly equal to the origin layout.
       *
       * @param {String} property - the value for {@link
       * Layout#property|property} in the replica.
       *
       * @returns {Layout} - the copy with {@link Layout#property|property}
       * set to `property`.
       */
      replicate(property) {
        const rv = Object.create(this.constructor.prototype);
        Object.assign(rv, this);
        rv.property = property;
        return rv;
      }
      /**
       * Create an object from layout properties and an array of values.
       *
       * **NOTE** This function returns `undefined` if invoked on a layout
       * that does not return its value as an Object.  Objects are
       * returned for things that are a {@link Structure}, which includes
       * {@link VariantLayout|variant layouts} if they are structures, and
       * excludes {@link Union}s.  If you want this feature for a union
       * you must use {@link Union.getVariant|getVariant} to select the
       * desired layout.
       *
       * @param {Array} values - an array of values that correspond to the
       * default order for properties.  As with {@link Layout#decode|decode}
       * layout elements that have no property name are skipped when
       * iterating over the array values.  Only the top-level properties are
       * assigned; arguments are not assigned to properties of contained
       * layouts.  Any unused values are ignored.
       *
       * @return {(Object|undefined)}
       */
      fromArray(values) {
        return void 0;
      }
    };
    exports.Layout = Layout;
    function nameWithProperty(name, lo) {
      if (lo.property) {
        return name + "[" + lo.property + "]";
      }
      return name;
    }
    exports.nameWithProperty = nameWithProperty;
    function bindConstructorLayout(Class, layout) {
      if ("function" !== typeof Class) {
        throw new TypeError("Class must be constructor");
      }
      if (Object.prototype.hasOwnProperty.call(Class, "layout_")) {
        throw new Error("Class is already bound to a layout");
      }
      if (!(layout && layout instanceof Layout)) {
        throw new TypeError("layout must be a Layout");
      }
      if (Object.prototype.hasOwnProperty.call(layout, "boundConstructor_")) {
        throw new Error("layout is already bound to a constructor");
      }
      Class.layout_ = layout;
      layout.boundConstructor_ = Class;
      layout.makeDestinationObject = () => new Class();
      Object.defineProperty(Class.prototype, "encode", {
        value(b, offset2) {
          return layout.encode(this, b, offset2);
        },
        writable: true
      });
      Object.defineProperty(Class, "decode", {
        value(b, offset2) {
          return layout.decode(b, offset2);
        },
        writable: true
      });
    }
    exports.bindConstructorLayout = bindConstructorLayout;
    var ExternalLayout = class extends Layout {
      /**
       * Return `true` iff the external layout decodes to an unsigned
       * integer layout.
       *
       * In that case it can be used as the source of {@link
       * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
       * or as {@link UnionLayoutDiscriminator#layout|external union
       * discriminators}.
       *
       * @abstract
       */
      isCount() {
        throw new Error("ExternalLayout is abstract");
      }
    };
    exports.ExternalLayout = ExternalLayout;
    var GreedyCount = class extends ExternalLayout {
      constructor(elementSpan = 1, property) {
        if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
          throw new TypeError("elementSpan must be a (positive) integer");
        }
        super(-1, property);
        this.elementSpan = elementSpan;
      }
      /** @override */
      isCount() {
        return true;
      }
      /** @override */
      decode(b, offset2 = 0) {
        checkUint8Array(b);
        const rem = b.length - offset2;
        return Math.floor(rem / this.elementSpan);
      }
      /** @override */
      encode(src2, b, offset2) {
        return 0;
      }
    };
    exports.GreedyCount = GreedyCount;
    var OffsetLayout = class extends ExternalLayout {
      constructor(layout, offset2 = 0, property) {
        if (!(layout instanceof Layout)) {
          throw new TypeError("layout must be a Layout");
        }
        if (!Number.isInteger(offset2)) {
          throw new TypeError("offset must be integer or undefined");
        }
        super(layout.span, property || layout.property);
        this.layout = layout;
        this.offset = offset2;
      }
      /** @override */
      isCount() {
        return this.layout instanceof UInt || this.layout instanceof UIntBE;
      }
      /** @override */
      decode(b, offset2 = 0) {
        return this.layout.decode(b, offset2 + this.offset);
      }
      /** @override */
      encode(src2, b, offset2 = 0) {
        return this.layout.encode(src2, b, offset2 + this.offset);
      }
    };
    exports.OffsetLayout = OffsetLayout;
    var UInt = class extends Layout {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset2 = 0) {
        return uint8ArrayToBuffer(b).readUIntLE(offset2, this.span);
      }
      /** @override */
      encode(src2, b, offset2 = 0) {
        uint8ArrayToBuffer(b).writeUIntLE(src2, offset2, this.span);
        return this.span;
      }
    };
    exports.UInt = UInt;
    var UIntBE = class extends Layout {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset2 = 0) {
        return uint8ArrayToBuffer(b).readUIntBE(offset2, this.span);
      }
      /** @override */
      encode(src2, b, offset2 = 0) {
        uint8ArrayToBuffer(b).writeUIntBE(src2, offset2, this.span);
        return this.span;
      }
    };
    exports.UIntBE = UIntBE;
    var Int = class extends Layout {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset2 = 0) {
        return uint8ArrayToBuffer(b).readIntLE(offset2, this.span);
      }
      /** @override */
      encode(src2, b, offset2 = 0) {
        uint8ArrayToBuffer(b).writeIntLE(src2, offset2, this.span);
        return this.span;
      }
    };
    exports.Int = Int;
    var IntBE = class extends Layout {
      constructor(span, property) {
        super(span, property);
        if (6 < this.span) {
          throw new RangeError("span must not exceed 6 bytes");
        }
      }
      /** @override */
      decode(b, offset2 = 0) {
        return uint8ArrayToBuffer(b).readIntBE(offset2, this.span);
      }
      /** @override */
      encode(src2, b, offset2 = 0) {
        uint8ArrayToBuffer(b).writeIntBE(src2, offset2, this.span);
        return this.span;
      }
    };
    exports.IntBE = IntBE;
    var V2E32 = Math.pow(2, 32);
    function divmodInt64(src2) {
      const hi32 = Math.floor(src2 / V2E32);
      const lo32 = src2 - hi32 * V2E32;
      return { hi32, lo32 };
    }
    function roundedInt64(hi32, lo32) {
      return hi32 * V2E32 + lo32;
    }
    var NearUInt64 = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset2 = 0) {
        const buffer = uint8ArrayToBuffer(b);
        const lo32 = buffer.readUInt32LE(offset2);
        const hi32 = buffer.readUInt32LE(offset2 + 4);
        return roundedInt64(hi32, lo32);
      }
      /** @override */
      encode(src2, b, offset2 = 0) {
        const split2 = divmodInt64(src2);
        const buffer = uint8ArrayToBuffer(b);
        buffer.writeUInt32LE(split2.lo32, offset2);
        buffer.writeUInt32LE(split2.hi32, offset2 + 4);
        return 8;
      }
    };
    exports.NearUInt64 = NearUInt64;
    var NearUInt64BE = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset2 = 0) {
        const buffer = uint8ArrayToBuffer(b);
        const hi32 = buffer.readUInt32BE(offset2);
        const lo32 = buffer.readUInt32BE(offset2 + 4);
        return roundedInt64(hi32, lo32);
      }
      /** @override */
      encode(src2, b, offset2 = 0) {
        const split2 = divmodInt64(src2);
        const buffer = uint8ArrayToBuffer(b);
        buffer.writeUInt32BE(split2.hi32, offset2);
        buffer.writeUInt32BE(split2.lo32, offset2 + 4);
        return 8;
      }
    };
    exports.NearUInt64BE = NearUInt64BE;
    var NearInt64 = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset2 = 0) {
        const buffer = uint8ArrayToBuffer(b);
        const lo32 = buffer.readUInt32LE(offset2);
        const hi32 = buffer.readInt32LE(offset2 + 4);
        return roundedInt64(hi32, lo32);
      }
      /** @override */
      encode(src2, b, offset2 = 0) {
        const split2 = divmodInt64(src2);
        const buffer = uint8ArrayToBuffer(b);
        buffer.writeUInt32LE(split2.lo32, offset2);
        buffer.writeInt32LE(split2.hi32, offset2 + 4);
        return 8;
      }
    };
    exports.NearInt64 = NearInt64;
    var NearInt64BE = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset2 = 0) {
        const buffer = uint8ArrayToBuffer(b);
        const hi32 = buffer.readInt32BE(offset2);
        const lo32 = buffer.readUInt32BE(offset2 + 4);
        return roundedInt64(hi32, lo32);
      }
      /** @override */
      encode(src2, b, offset2 = 0) {
        const split2 = divmodInt64(src2);
        const buffer = uint8ArrayToBuffer(b);
        buffer.writeInt32BE(split2.hi32, offset2);
        buffer.writeUInt32BE(split2.lo32, offset2 + 4);
        return 8;
      }
    };
    exports.NearInt64BE = NearInt64BE;
    var Float = class extends Layout {
      constructor(property) {
        super(4, property);
      }
      /** @override */
      decode(b, offset2 = 0) {
        return uint8ArrayToBuffer(b).readFloatLE(offset2);
      }
      /** @override */
      encode(src2, b, offset2 = 0) {
        uint8ArrayToBuffer(b).writeFloatLE(src2, offset2);
        return 4;
      }
    };
    exports.Float = Float;
    var FloatBE = class extends Layout {
      constructor(property) {
        super(4, property);
      }
      /** @override */
      decode(b, offset2 = 0) {
        return uint8ArrayToBuffer(b).readFloatBE(offset2);
      }
      /** @override */
      encode(src2, b, offset2 = 0) {
        uint8ArrayToBuffer(b).writeFloatBE(src2, offset2);
        return 4;
      }
    };
    exports.FloatBE = FloatBE;
    var Double = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset2 = 0) {
        return uint8ArrayToBuffer(b).readDoubleLE(offset2);
      }
      /** @override */
      encode(src2, b, offset2 = 0) {
        uint8ArrayToBuffer(b).writeDoubleLE(src2, offset2);
        return 8;
      }
    };
    exports.Double = Double;
    var DoubleBE = class extends Layout {
      constructor(property) {
        super(8, property);
      }
      /** @override */
      decode(b, offset2 = 0) {
        return uint8ArrayToBuffer(b).readDoubleBE(offset2);
      }
      /** @override */
      encode(src2, b, offset2 = 0) {
        uint8ArrayToBuffer(b).writeDoubleBE(src2, offset2);
        return 8;
      }
    };
    exports.DoubleBE = DoubleBE;
    var Sequence = class extends Layout {
      constructor(elementLayout, count, property) {
        if (!(elementLayout instanceof Layout)) {
          throw new TypeError("elementLayout must be a Layout");
        }
        if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {
          throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
        }
        let span = -1;
        if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {
          span = count * elementLayout.span;
        }
        super(span, property);
        this.elementLayout = elementLayout;
        this.count = count;
      }
      /** @override */
      getSpan(b, offset2 = 0) {
        if (0 <= this.span) {
          return this.span;
        }
        let span = 0;
        let count = this.count;
        if (count instanceof ExternalLayout) {
          count = count.decode(b, offset2);
        }
        if (0 < this.elementLayout.span) {
          span = count * this.elementLayout.span;
        } else {
          let idx = 0;
          while (idx < count) {
            span += this.elementLayout.getSpan(b, offset2 + span);
            ++idx;
          }
        }
        return span;
      }
      /** @override */
      decode(b, offset2 = 0) {
        const rv = [];
        let i = 0;
        let count = this.count;
        if (count instanceof ExternalLayout) {
          count = count.decode(b, offset2);
        }
        while (i < count) {
          rv.push(this.elementLayout.decode(b, offset2));
          offset2 += this.elementLayout.getSpan(b, offset2);
          i += 1;
        }
        return rv;
      }
      /** Implement {@link Layout#encode|encode} for {@link Sequence}.
       *
       * **NOTE** If `src` is shorter than {@link Sequence#count|count} then
       * the unused space in the buffer is left unchanged.  If `src` is
       * longer than {@link Sequence#count|count} the unneeded elements are
       * ignored.
       *
       * **NOTE** If {@link Layout#count|count} is an instance of {@link
       * ExternalLayout} then the length of `src` will be encoded as the
       * count after `src` is encoded. */
      encode(src2, b, offset2 = 0) {
        const elo = this.elementLayout;
        const span = src2.reduce((span2, v) => {
          return span2 + elo.encode(v, b, offset2 + span2);
        }, 0);
        if (this.count instanceof ExternalLayout) {
          this.count.encode(src2.length, b, offset2);
        }
        return span;
      }
    };
    exports.Sequence = Sequence;
    var Structure = class extends Layout {
      constructor(fields, property, decodePrefixes) {
        if (!(Array.isArray(fields) && fields.reduce((acc, v) => acc && v instanceof Layout, true))) {
          throw new TypeError("fields must be array of Layout instances");
        }
        if ("boolean" === typeof property && void 0 === decodePrefixes) {
          decodePrefixes = property;
          property = void 0;
        }
        for (const fd of fields) {
          if (0 > fd.span && void 0 === fd.property) {
            throw new Error("fields cannot contain unnamed variable-length layout");
          }
        }
        let span = -1;
        try {
          span = fields.reduce((span2, fd) => span2 + fd.getSpan(), 0);
        } catch (e) {
        }
        super(span, property);
        this.fields = fields;
        this.decodePrefixes = !!decodePrefixes;
      }
      /** @override */
      getSpan(b, offset2 = 0) {
        if (0 <= this.span) {
          return this.span;
        }
        let span = 0;
        try {
          span = this.fields.reduce((span2, fd) => {
            const fsp = fd.getSpan(b, offset2);
            offset2 += fsp;
            return span2 + fsp;
          }, 0);
        } catch (e) {
          throw new RangeError("indeterminate span");
        }
        return span;
      }
      /** @override */
      decode(b, offset2 = 0) {
        checkUint8Array(b);
        const dest = this.makeDestinationObject();
        for (const fd of this.fields) {
          if (void 0 !== fd.property) {
            dest[fd.property] = fd.decode(b, offset2);
          }
          offset2 += fd.getSpan(b, offset2);
          if (this.decodePrefixes && b.length === offset2) {
            break;
          }
        }
        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link Structure}.
       *
       * If `src` is missing a property for a member with a defined {@link
       * Layout#property|property} the corresponding region of the buffer is
       * left unmodified. */
      encode(src2, b, offset2 = 0) {
        const firstOffset = offset2;
        let lastOffset = 0;
        let lastWrote = 0;
        for (const fd of this.fields) {
          let span = fd.span;
          lastWrote = 0 < span ? span : 0;
          if (void 0 !== fd.property) {
            const fv = src2[fd.property];
            if (void 0 !== fv) {
              lastWrote = fd.encode(fv, b, offset2);
              if (0 > span) {
                span = fd.getSpan(b, offset2);
              }
            }
          }
          lastOffset = offset2;
          offset2 += span;
        }
        return lastOffset + lastWrote - firstOffset;
      }
      /** @override */
      fromArray(values) {
        const dest = this.makeDestinationObject();
        for (const fd of this.fields) {
          if (void 0 !== fd.property && 0 < values.length) {
            dest[fd.property] = values.shift();
          }
        }
        return dest;
      }
      /**
       * Get access to the layout of a given property.
       *
       * @param {String} property - the structure member of interest.
       *
       * @return {Layout} - the layout associated with `property`, or
       * undefined if there is no such property.
       */
      layoutFor(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        for (const fd of this.fields) {
          if (fd.property === property) {
            return fd;
          }
        }
        return void 0;
      }
      /**
       * Get the offset of a structure member.
       *
       * @param {String} property - the structure member of interest.
       *
       * @return {Number} - the offset in bytes to the start of `property`
       * within the structure, or undefined if `property` is not a field
       * within the structure.  If the property is a member but follows a
       * variable-length structure member a negative number will be
       * returned.
       */
      offsetOf(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        let offset2 = 0;
        for (const fd of this.fields) {
          if (fd.property === property) {
            return offset2;
          }
          if (0 > fd.span) {
            offset2 = -1;
          } else if (0 <= offset2) {
            offset2 += fd.span;
          }
        }
        return void 0;
      }
    };
    exports.Structure = Structure;
    var UnionDiscriminator = class {
      constructor(property) {
        this.property = property;
      }
      /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
       *
       * The implementation of this method need not reference the buffer if
       * variant information is available through other means. */
      decode(b, offset2) {
        throw new Error("UnionDiscriminator is abstract");
      }
      /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
       *
       * The implementation of this method need not store the value if
       * variant information is maintained through other means. */
      encode(src2, b, offset2) {
        throw new Error("UnionDiscriminator is abstract");
      }
    };
    exports.UnionDiscriminator = UnionDiscriminator;
    var UnionLayoutDiscriminator = class extends UnionDiscriminator {
      constructor(layout, property) {
        if (!(layout instanceof ExternalLayout && layout.isCount())) {
          throw new TypeError("layout must be an unsigned integer ExternalLayout");
        }
        super(property || layout.property || "variant");
        this.layout = layout;
      }
      /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */
      decode(b, offset2) {
        return this.layout.decode(b, offset2);
      }
      /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */
      encode(src2, b, offset2) {
        return this.layout.encode(src2, b, offset2);
      }
    };
    exports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;
    var Union = class extends Layout {
      constructor(discr, defaultLayout, property) {
        let discriminator;
        if (discr instanceof UInt || discr instanceof UIntBE) {
          discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));
        } else if (discr instanceof ExternalLayout && discr.isCount()) {
          discriminator = new UnionLayoutDiscriminator(discr);
        } else if (!(discr instanceof UnionDiscriminator)) {
          throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
        } else {
          discriminator = discr;
        }
        if (void 0 === defaultLayout) {
          defaultLayout = null;
        }
        if (!(null === defaultLayout || defaultLayout instanceof Layout)) {
          throw new TypeError("defaultLayout must be null or a Layout");
        }
        if (null !== defaultLayout) {
          if (0 > defaultLayout.span) {
            throw new Error("defaultLayout must have constant span");
          }
          if (void 0 === defaultLayout.property) {
            defaultLayout = defaultLayout.replicate("content");
          }
        }
        let span = -1;
        if (defaultLayout) {
          span = defaultLayout.span;
          if (0 <= span && (discr instanceof UInt || discr instanceof UIntBE)) {
            span += discriminator.layout.span;
          }
        }
        super(span, property);
        this.discriminator = discriminator;
        this.usesPrefixDiscriminator = discr instanceof UInt || discr instanceof UIntBE;
        this.defaultLayout = defaultLayout;
        this.registry = {};
        let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);
        this.getSourceVariant = function(src2) {
          return boundGetSourceVariant(src2);
        };
        this.configGetSourceVariant = function(gsv) {
          boundGetSourceVariant = gsv.bind(this);
        };
      }
      /** @override */
      getSpan(b, offset2 = 0) {
        if (0 <= this.span) {
          return this.span;
        }
        const vlo = this.getVariant(b, offset2);
        if (!vlo) {
          throw new Error("unable to determine span for unrecognized variant");
        }
        return vlo.getSpan(b, offset2);
      }
      /**
       * Method to infer a registered Union variant compatible with `src`.
       *
       * The first satisfied rule in the following sequence defines the
       * return value:
       * * If `src` has properties matching the Union discriminator and
       *   the default layout, `undefined` is returned regardless of the
       *   value of the discriminator property (this ensures the default
       *   layout will be used);
       * * If `src` has a property matching the Union discriminator, the
       *   value of the discriminator identifies a registered variant, and
       *   either (a) the variant has no layout, or (b) `src` has the
       *   variant's property, then the variant is returned (because the
       *   source satisfies the constraints of the variant it identifies);
       * * If `src` does not have a property matching the Union
       *   discriminator, but does have a property matching a registered
       *   variant, then the variant is returned (because the source
       *   matches a variant without an explicit conflict);
       * * An error is thrown (because we either can't identify a variant,
       *   or we were explicitly told the variant but can't satisfy it).
       *
       * @param {Object} src - an object presumed to be compatible with
       * the content of the Union.
       *
       * @return {(undefined|VariantLayout)} - as described above.
       *
       * @throws {Error} - if `src` cannot be associated with a default or
       * registered variant.
       */
      defaultGetSourceVariant(src2) {
        if (Object.prototype.hasOwnProperty.call(src2, this.discriminator.property)) {
          if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src2, this.defaultLayout.property)) {
            return void 0;
          }
          const vlo = this.registry[src2[this.discriminator.property]];
          if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src2, vlo.property))) {
            return vlo;
          }
        } else {
          for (const tag in this.registry) {
            const vlo = this.registry[tag];
            if (vlo.property && Object.prototype.hasOwnProperty.call(src2, vlo.property)) {
              return vlo;
            }
          }
        }
        throw new Error("unable to infer src variant");
      }
      /** Implement {@link Layout#decode|decode} for {@link Union}.
       *
       * If the variant is {@link Union#addVariant|registered} the return
       * value is an instance of that variant, with no explicit
       * discriminator.  Otherwise the {@link Union#defaultLayout|default
       * layout} is used to decode the content. */
      decode(b, offset2 = 0) {
        let dest;
        const dlo = this.discriminator;
        const discr = dlo.decode(b, offset2);
        const clo = this.registry[discr];
        if (void 0 === clo) {
          const defaultLayout = this.defaultLayout;
          let contentOffset = 0;
          if (this.usesPrefixDiscriminator) {
            contentOffset = dlo.layout.span;
          }
          dest = this.makeDestinationObject();
          dest[dlo.property] = discr;
          dest[defaultLayout.property] = defaultLayout.decode(b, offset2 + contentOffset);
        } else {
          dest = clo.decode(b, offset2);
        }
        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link Union}.
       *
       * This API assumes the `src` object is consistent with the union's
       * {@link Union#defaultLayout|default layout}.  To encode variants
       * use the appropriate variant-specific {@link VariantLayout#encode}
       * method. */
      encode(src2, b, offset2 = 0) {
        const vlo = this.getSourceVariant(src2);
        if (void 0 === vlo) {
          const dlo = this.discriminator;
          const clo = this.defaultLayout;
          let contentOffset = 0;
          if (this.usesPrefixDiscriminator) {
            contentOffset = dlo.layout.span;
          }
          dlo.encode(src2[dlo.property], b, offset2);
          return contentOffset + clo.encode(src2[clo.property], b, offset2 + contentOffset);
        }
        return vlo.encode(src2, b, offset2);
      }
      /** Register a new variant structure within a union.  The newly
       * created variant is returned.
       *
       * @param {Number} variant - initializer for {@link
       * VariantLayout#variant|variant}.
       *
       * @param {Layout} layout - initializer for {@link
       * VariantLayout#layout|layout}.
       *
       * @param {String} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {VariantLayout} */
      addVariant(variant, layout, property) {
        const rv = new VariantLayout(this, variant, layout, property);
        this.registry[variant] = rv;
        return rv;
      }
      /**
       * Get the layout associated with a registered variant.
       *
       * If `vb` does not produce a registered variant the function returns
       * `undefined`.
       *
       * @param {(Number|Uint8Array)} vb - either the variant number, or a
       * buffer from which the discriminator is to be read.
       *
       * @param {Number} offset - offset into `vb` for the start of the
       * union.  Used only when `vb` is an instance of {Uint8Array}.
       *
       * @return {({VariantLayout}|undefined)}
       */
      getVariant(vb, offset2 = 0) {
        let variant;
        if (vb instanceof Uint8Array) {
          variant = this.discriminator.decode(vb, offset2);
        } else {
          variant = vb;
        }
        return this.registry[variant];
      }
    };
    exports.Union = Union;
    var VariantLayout = class extends Layout {
      constructor(union2, variant, layout, property) {
        if (!(union2 instanceof Union)) {
          throw new TypeError("union must be a Union");
        }
        if (!Number.isInteger(variant) || 0 > variant) {
          throw new TypeError("variant must be a (non-negative) integer");
        }
        if ("string" === typeof layout && void 0 === property) {
          property = layout;
          layout = null;
        }
        if (layout) {
          if (!(layout instanceof Layout)) {
            throw new TypeError("layout must be a Layout");
          }
          if (null !== union2.defaultLayout && 0 <= layout.span && layout.span > union2.defaultLayout.span) {
            throw new Error("variant span exceeds span of containing union");
          }
          if ("string" !== typeof property) {
            throw new TypeError("variant must have a String property");
          }
        }
        let span = union2.span;
        if (0 > union2.span) {
          span = layout ? layout.span : 0;
          if (0 <= span && union2.usesPrefixDiscriminator) {
            span += union2.discriminator.layout.span;
          }
        }
        super(span, property);
        this.union = union2;
        this.variant = variant;
        this.layout = layout || null;
      }
      /** @override */
      getSpan(b, offset2 = 0) {
        if (0 <= this.span) {
          return this.span;
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        let span = 0;
        if (this.layout) {
          span = this.layout.getSpan(b, offset2 + contentOffset);
        }
        return contentOffset + span;
      }
      /** @override */
      decode(b, offset2 = 0) {
        const dest = this.makeDestinationObject();
        if (this !== this.union.getVariant(b, offset2)) {
          throw new Error("variant mismatch");
        }
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        if (this.layout) {
          dest[this.property] = this.layout.decode(b, offset2 + contentOffset);
        } else if (this.property) {
          dest[this.property] = true;
        } else if (this.union.usesPrefixDiscriminator) {
          dest[this.union.discriminator.property] = this.variant;
        }
        return dest;
      }
      /** @override */
      encode(src2, b, offset2 = 0) {
        let contentOffset = 0;
        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        if (this.layout && !Object.prototype.hasOwnProperty.call(src2, this.property)) {
          throw new TypeError("variant lacks property " + this.property);
        }
        this.union.discriminator.encode(this.variant, b, offset2);
        let span = contentOffset;
        if (this.layout) {
          this.layout.encode(src2[this.property], b, offset2 + contentOffset);
          span += this.layout.getSpan(b, offset2 + contentOffset);
          if (0 <= this.union.span && span > this.union.span) {
            throw new Error("encoded variant overruns containing union");
          }
        }
        return span;
      }
      /** Delegate {@link Layout#fromArray|fromArray} to {@link
       * VariantLayout#layout|layout}. */
      fromArray(values) {
        if (this.layout) {
          return this.layout.fromArray(values);
        }
        return void 0;
      }
    };
    exports.VariantLayout = VariantLayout;
    function fixBitwiseResult(v) {
      if (0 > v) {
        v += 4294967296;
      }
      return v;
    }
    var BitStructure = class extends Layout {
      constructor(word, msb, property) {
        if (!(word instanceof UInt || word instanceof UIntBE)) {
          throw new TypeError("word must be a UInt or UIntBE layout");
        }
        if ("string" === typeof msb && void 0 === property) {
          property = msb;
          msb = false;
        }
        if (4 < word.span) {
          throw new RangeError("word cannot exceed 32 bits");
        }
        super(word.span, property);
        this.word = word;
        this.msb = !!msb;
        this.fields = [];
        let value = 0;
        this._packedSetValue = function(v) {
          value = fixBitwiseResult(v);
          return this;
        };
        this._packedGetValue = function() {
          return value;
        };
      }
      /** @override */
      decode(b, offset2 = 0) {
        const dest = this.makeDestinationObject();
        const value = this.word.decode(b, offset2);
        this._packedSetValue(value);
        for (const fd of this.fields) {
          if (void 0 !== fd.property) {
            dest[fd.property] = fd.decode(b);
          }
        }
        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link BitStructure}.
       *
       * If `src` is missing a property for a member with a defined {@link
       * Layout#property|property} the corresponding region of the packed
       * value is left unmodified.  Unused bits are also left unmodified. */
      encode(src2, b, offset2 = 0) {
        const value = this.word.decode(b, offset2);
        this._packedSetValue(value);
        for (const fd of this.fields) {
          if (void 0 !== fd.property) {
            const fv = src2[fd.property];
            if (void 0 !== fv) {
              fd.encode(fv);
            }
          }
        }
        return this.word.encode(this._packedGetValue(), b, offset2);
      }
      /** Register a new bitfield with a containing bit structure.  The
       * resulting bitfield is returned.
       *
       * @param {Number} bits - initializer for {@link BitField#bits|bits}.
       *
       * @param {string} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {BitField} */
      addField(bits, property) {
        const bf = new BitField(this, bits, property);
        this.fields.push(bf);
        return bf;
      }
      /** As with {@link BitStructure#addField|addField} for single-bit
       * fields with `boolean` value representation.
       *
       * @param {string} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {Boolean} */
      // `Boolean` conflicts with the native primitive type
      // eslint-disable-next-line @typescript-eslint/ban-types
      addBoolean(property) {
        const bf = new Boolean2(this, property);
        this.fields.push(bf);
        return bf;
      }
      /**
       * Get access to the bit field for a given property.
       *
       * @param {String} property - the bit field of interest.
       *
       * @return {BitField} - the field associated with `property`, or
       * undefined if there is no such property.
       */
      fieldFor(property) {
        if ("string" !== typeof property) {
          throw new TypeError("property must be string");
        }
        for (const fd of this.fields) {
          if (fd.property === property) {
            return fd;
          }
        }
        return void 0;
      }
    };
    exports.BitStructure = BitStructure;
    var BitField = class {
      constructor(container, bits, property) {
        if (!(container instanceof BitStructure)) {
          throw new TypeError("container must be a BitStructure");
        }
        if (!Number.isInteger(bits) || 0 >= bits) {
          throw new TypeError("bits must be positive integer");
        }
        const totalBits = 8 * container.span;
        const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);
        if (bits + usedBits > totalBits) {
          throw new Error("bits too long for span remainder (" + (totalBits - usedBits) + " of " + totalBits + " remain)");
        }
        this.container = container;
        this.bits = bits;
        this.valueMask = (1 << bits) - 1;
        if (32 === bits) {
          this.valueMask = 4294967295;
        }
        this.start = usedBits;
        if (this.container.msb) {
          this.start = totalBits - usedBits - bits;
        }
        this.wordMask = fixBitwiseResult(this.valueMask << this.start);
        this.property = property;
      }
      /** Store a value into the corresponding subsequence of the containing
       * bit field. */
      decode(b, offset2) {
        const word = this.container._packedGetValue();
        const wordValue = fixBitwiseResult(word & this.wordMask);
        const value = wordValue >>> this.start;
        return value;
      }
      /** Store a value into the corresponding subsequence of the containing
       * bit field.
       *
       * **NOTE** This is not a specialization of {@link
       * Layout#encode|Layout.encode} and there is no return value. */
      encode(value) {
        if ("number" !== typeof value || !Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {
          throw new TypeError(nameWithProperty("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
        }
        const word = this.container._packedGetValue();
        const wordValue = fixBitwiseResult(value << this.start);
        this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
      }
    };
    exports.BitField = BitField;
    var Boolean2 = class extends BitField {
      constructor(container, property) {
        super(container, 1, property);
      }
      /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.
       *
       * @returns {boolean} */
      decode(b, offset2) {
        return !!super.decode(b, offset2);
      }
      /** @override */
      encode(value) {
        if ("boolean" === typeof value) {
          value = +value;
        }
        super.encode(value);
      }
    };
    exports.Boolean = Boolean2;
    var Blob2 = class extends Layout {
      constructor(length, property) {
        if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {
          throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
        }
        let span = -1;
        if (!(length instanceof ExternalLayout)) {
          span = length;
        }
        super(span, property);
        this.length = length;
      }
      /** @override */
      getSpan(b, offset2) {
        let span = this.span;
        if (0 > span) {
          span = this.length.decode(b, offset2);
        }
        return span;
      }
      /** @override */
      decode(b, offset2 = 0) {
        let span = this.span;
        if (0 > span) {
          span = this.length.decode(b, offset2);
        }
        return uint8ArrayToBuffer(b).slice(offset2, offset2 + span);
      }
      /** Implement {@link Layout#encode|encode} for {@link Blob}.
       *
       * **NOTE** If {@link Layout#count|count} is an instance of {@link
       * ExternalLayout} then the length of `src` will be encoded as the
       * count after `src` is encoded. */
      encode(src2, b, offset2) {
        let span = this.length;
        if (this.length instanceof ExternalLayout) {
          span = src2.length;
        }
        if (!(src2 instanceof Uint8Array && span === src2.length)) {
          throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + span + ") Uint8Array as src");
        }
        if (offset2 + span > b.length) {
          throw new RangeError("encoding overruns Uint8Array");
        }
        const srcBuffer = uint8ArrayToBuffer(src2);
        uint8ArrayToBuffer(b).write(srcBuffer.toString("hex"), offset2, span, "hex");
        if (this.length instanceof ExternalLayout) {
          this.length.encode(span, b, offset2);
        }
        return span;
      }
    };
    exports.Blob = Blob2;
    var CString = class extends Layout {
      constructor(property) {
        super(-1, property);
      }
      /** @override */
      getSpan(b, offset2 = 0) {
        checkUint8Array(b);
        let idx = offset2;
        while (idx < b.length && 0 !== b[idx]) {
          idx += 1;
        }
        return 1 + idx - offset2;
      }
      /** @override */
      decode(b, offset2 = 0) {
        const span = this.getSpan(b, offset2);
        return uint8ArrayToBuffer(b).slice(offset2, offset2 + span - 1).toString("utf-8");
      }
      /** @override */
      encode(src2, b, offset2 = 0) {
        if ("string" !== typeof src2) {
          src2 = String(src2);
        }
        const srcb = buffer_1.Buffer.from(src2, "utf8");
        const span = srcb.length;
        if (offset2 + span > b.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        const buffer = uint8ArrayToBuffer(b);
        srcb.copy(buffer, offset2);
        buffer[offset2 + span] = 0;
        return span + 1;
      }
    };
    exports.CString = CString;
    var UTF8 = class extends Layout {
      constructor(maxSpan, property) {
        if ("string" === typeof maxSpan && void 0 === property) {
          property = maxSpan;
          maxSpan = void 0;
        }
        if (void 0 === maxSpan) {
          maxSpan = -1;
        } else if (!Number.isInteger(maxSpan)) {
          throw new TypeError("maxSpan must be an integer");
        }
        super(-1, property);
        this.maxSpan = maxSpan;
      }
      /** @override */
      getSpan(b, offset2 = 0) {
        checkUint8Array(b);
        return b.length - offset2;
      }
      /** @override */
      decode(b, offset2 = 0) {
        const span = this.getSpan(b, offset2);
        if (0 <= this.maxSpan && this.maxSpan < span) {
          throw new RangeError("text length exceeds maxSpan");
        }
        return uint8ArrayToBuffer(b).slice(offset2, offset2 + span).toString("utf-8");
      }
      /** @override */
      encode(src2, b, offset2 = 0) {
        if ("string" !== typeof src2) {
          src2 = String(src2);
        }
        const srcb = buffer_1.Buffer.from(src2, "utf8");
        const span = srcb.length;
        if (0 <= this.maxSpan && this.maxSpan < span) {
          throw new RangeError("text length exceeds maxSpan");
        }
        if (offset2 + span > b.length) {
          throw new RangeError("encoding overruns Buffer");
        }
        srcb.copy(uint8ArrayToBuffer(b), offset2);
        return span;
      }
    };
    exports.UTF8 = UTF8;
    var Constant = class extends Layout {
      constructor(value, property) {
        super(0, property);
        this.value = value;
      }
      /** @override */
      decode(b, offset2) {
        return this.value;
      }
      /** @override */
      encode(src2, b, offset2) {
        return 0;
      }
    };
    exports.Constant = Constant;
    exports.greedy = (elementSpan, property) => new GreedyCount(elementSpan, property);
    exports.offset = (layout, offset2, property) => new OffsetLayout(layout, offset2, property);
    exports.u8 = (property) => new UInt(1, property);
    exports.u16 = (property) => new UInt(2, property);
    exports.u24 = (property) => new UInt(3, property);
    exports.u32 = (property) => new UInt(4, property);
    exports.u40 = (property) => new UInt(5, property);
    exports.u48 = (property) => new UInt(6, property);
    exports.nu64 = (property) => new NearUInt64(property);
    exports.u16be = (property) => new UIntBE(2, property);
    exports.u24be = (property) => new UIntBE(3, property);
    exports.u32be = (property) => new UIntBE(4, property);
    exports.u40be = (property) => new UIntBE(5, property);
    exports.u48be = (property) => new UIntBE(6, property);
    exports.nu64be = (property) => new NearUInt64BE(property);
    exports.s8 = (property) => new Int(1, property);
    exports.s16 = (property) => new Int(2, property);
    exports.s24 = (property) => new Int(3, property);
    exports.s32 = (property) => new Int(4, property);
    exports.s40 = (property) => new Int(5, property);
    exports.s48 = (property) => new Int(6, property);
    exports.ns64 = (property) => new NearInt64(property);
    exports.s16be = (property) => new IntBE(2, property);
    exports.s24be = (property) => new IntBE(3, property);
    exports.s32be = (property) => new IntBE(4, property);
    exports.s40be = (property) => new IntBE(5, property);
    exports.s48be = (property) => new IntBE(6, property);
    exports.ns64be = (property) => new NearInt64BE(property);
    exports.f32 = (property) => new Float(property);
    exports.f32be = (property) => new FloatBE(property);
    exports.f64 = (property) => new Double(property);
    exports.f64be = (property) => new DoubleBE(property);
    exports.struct = (fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes);
    exports.bits = (word, msb, property) => new BitStructure(word, msb, property);
    exports.seq = (elementLayout, count, property) => new Sequence(elementLayout, count, property);
    exports.union = (discr, defaultLayout, property) => new Union(discr, defaultLayout, property);
    exports.unionLayoutDiscriminator = (layout, property) => new UnionLayoutDiscriminator(layout, property);
    exports.blob = (length, property) => new Blob2(length, property);
    exports.cstr = (property) => new CString(property);
    exports.utf8 = (maxSpan, property) => new UTF8(maxSpan, property);
    exports.constant = (value, property) => new Constant(value, property);
  }
});

// ../../node_modules/file-uri-to-path/index.js
var require_file_uri_to_path = __commonJS({
  "../../node_modules/file-uri-to-path/index.js"(exports, module) {
    var sep = __require("path").sep || "/";
    module.exports = fileUriToPath;
    function fileUriToPath(uri) {
      if ("string" != typeof uri || uri.length <= 7 || "file://" != uri.substring(0, 7)) {
        throw new TypeError("must pass in a file:// URI to convert to a file path");
      }
      var rest = decodeURI(uri.substring(7));
      var firstSlash = rest.indexOf("/");
      var host = rest.substring(0, firstSlash);
      var path = rest.substring(firstSlash + 1);
      if ("localhost" == host)
        host = "";
      if (host) {
        host = sep + sep + host;
      }
      path = path.replace(/^(.+)\|/, "$1:");
      if (sep == "\\") {
        path = path.replace(/\//g, "\\");
      }
      if (/^.+\:/.test(path)) {
      } else {
        path = sep + path;
      }
      return host + path;
    }
  }
});

// ../../node_modules/bindings/bindings.js
var require_bindings = __commonJS({
  "../../node_modules/bindings/bindings.js"(exports, module) {
    var fs = __require("fs");
    var path = __require("path");
    var fileURLToPath = require_file_uri_to_path();
    var join = path.join;
    var dirname = path.dirname;
    var exists2 = fs.accessSync && function(path2) {
      try {
        fs.accessSync(path2);
      } catch (e) {
        return false;
      }
      return true;
    } || fs.existsSync || path.existsSync;
    var defaults = {
      arrow: process.env.NODE_BINDINGS_ARROW || " \u2192 ",
      compiled: process.env.NODE_BINDINGS_COMPILED_DIR || "compiled",
      platform: process.platform,
      arch: process.arch,
      nodePreGyp: "node-v" + process.versions.modules + "-" + process.platform + "-" + process.arch,
      version: process.versions.node,
      bindings: "bindings.node",
      try: [
        // node-gyp's linked version in the "build" dir
        ["module_root", "build", "bindings"],
        // node-waf and gyp_addon (a.k.a node-gyp)
        ["module_root", "build", "Debug", "bindings"],
        ["module_root", "build", "Release", "bindings"],
        // Debug files, for development (legacy behavior, remove for node v0.9)
        ["module_root", "out", "Debug", "bindings"],
        ["module_root", "Debug", "bindings"],
        // Release files, but manually compiled (legacy behavior, remove for node v0.9)
        ["module_root", "out", "Release", "bindings"],
        ["module_root", "Release", "bindings"],
        // Legacy from node-waf, node <= 0.4.x
        ["module_root", "build", "default", "bindings"],
        // Production "Release" buildtype binary (meh...)
        ["module_root", "compiled", "version", "platform", "arch", "bindings"],
        // node-qbs builds
        ["module_root", "addon-build", "release", "install-root", "bindings"],
        ["module_root", "addon-build", "debug", "install-root", "bindings"],
        ["module_root", "addon-build", "default", "install-root", "bindings"],
        // node-pre-gyp path ./lib/binding/{node_abi}-{platform}-{arch}
        ["module_root", "lib", "binding", "nodePreGyp", "bindings"]
      ]
    };
    function bindings(opts) {
      if (typeof opts == "string") {
        opts = { bindings: opts };
      } else if (!opts) {
        opts = {};
      }
      Object.keys(defaults).map(function(i2) {
        if (!(i2 in opts))
          opts[i2] = defaults[i2];
      });
      if (!opts.module_root) {
        opts.module_root = exports.getRoot(exports.getFileName());
      }
      if (path.extname(opts.bindings) != ".node") {
        opts.bindings += ".node";
      }
      var requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : __require;
      var tries = [], i = 0, l = opts.try.length, n, b, err;
      for (; i < l; i++) {
        n = join.apply(
          null,
          opts.try[i].map(function(p) {
            return opts[p] || p;
          })
        );
        tries.push(n);
        try {
          b = opts.path ? requireFunc.resolve(n) : requireFunc(n);
          if (!opts.path) {
            b.path = n;
          }
          return b;
        } catch (e) {
          if (e.code !== "MODULE_NOT_FOUND" && e.code !== "QUALIFIED_PATH_RESOLUTION_FAILED" && !/not find/i.test(e.message)) {
            throw e;
          }
        }
      }
      err = new Error(
        "Could not locate the bindings file. Tried:\n" + tries.map(function(a) {
          return opts.arrow + a;
        }).join("\n")
      );
      err.tries = tries;
      throw err;
    }
    module.exports = exports = bindings;
    exports.getFileName = function getFileName(calling_file) {
      var origPST = Error.prepareStackTrace, origSTL = Error.stackTraceLimit, dummy = {}, fileName;
      Error.stackTraceLimit = 10;
      Error.prepareStackTrace = function(e, st) {
        for (var i = 0, l = st.length; i < l; i++) {
          fileName = st[i].getFileName();
          if (fileName !== __filename) {
            if (calling_file) {
              if (fileName !== calling_file) {
                return;
              }
            } else {
              return;
            }
          }
        }
      };
      Error.captureStackTrace(dummy);
      dummy.stack;
      Error.prepareStackTrace = origPST;
      Error.stackTraceLimit = origSTL;
      var fileSchema = "file://";
      if (fileName.indexOf(fileSchema) === 0) {
        fileName = fileURLToPath(fileName);
      }
      return fileName;
    };
    exports.getRoot = function getRoot(file) {
      var dir = dirname(file), prev;
      while (true) {
        if (dir === ".") {
          dir = process.cwd();
        }
        if (exists2(join(dir, "package.json")) || exists2(join(dir, "node_modules"))) {
          return dir;
        }
        if (prev === dir) {
          throw new Error(
            'Could not find module root given file: "' + file + '". Do you have a `package.json` file? '
          );
        }
        prev = dir;
        dir = join(dir, "..");
      }
    };
  }
});

// ../../node_modules/bigint-buffer/dist/node.js
var require_node = __commonJS({
  "../../node_modules/bigint-buffer/dist/node.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var converter;
    {
      try {
        converter = require_bindings()("bigint_buffer");
      } catch (e) {
        console.warn("bigint: Failed to load bindings, pure JS will be used (try npm run rebuild?)");
      }
    }
    function toBigIntLE3(buf) {
      if (converter === void 0) {
        const reversed = Buffer.from(buf);
        reversed.reverse();
        const hex = reversed.toString("hex");
        if (hex.length === 0) {
          return BigInt(0);
        }
        return BigInt(`0x${hex}`);
      }
      return converter.toBigInt(buf, false);
    }
    exports.toBigIntLE = toBigIntLE3;
    function toBigIntBE2(buf) {
      if (converter === void 0) {
        const hex = buf.toString("hex");
        if (hex.length === 0) {
          return BigInt(0);
        }
        return BigInt(`0x${hex}`);
      }
      return converter.toBigInt(buf, true);
    }
    exports.toBigIntBE = toBigIntBE2;
    function toBufferLE3(num, width) {
      if (converter === void 0) {
        const hex = num.toString(16);
        const buffer = Buffer.from(hex.padStart(width * 2, "0").slice(0, width * 2), "hex");
        buffer.reverse();
        return buffer;
      }
      return converter.fromBigInt(num, Buffer.allocUnsafe(width), false);
    }
    exports.toBufferLE = toBufferLE3;
    function toBufferBE2(num, width) {
      if (converter === void 0) {
        const hex = num.toString(16);
        return Buffer.from(hex.padStart(width * 2, "0").slice(0, width * 2), "hex");
      }
      return converter.fromBigInt(num, Buffer.allocUnsafe(width), true);
    }
    exports.toBufferBE = toBufferBE2;
  }
});

// ../../node_modules/uuid/dist/esm-node/rng.js
import crypto4 from "crypto";
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    crypto4.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
var rnds8Pool, poolPtr;
var init_rng = __esm({
  "../../node_modules/uuid/dist/esm-node/rng.js"() {
    rnds8Pool = new Uint8Array(256);
    poolPtr = rnds8Pool.length;
  }
});

// ../../node_modules/uuid/dist/esm-node/regex.js
var regex_default;
var init_regex = __esm({
  "../../node_modules/uuid/dist/esm-node/regex.js"() {
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  }
});

// ../../node_modules/uuid/dist/esm-node/validate.js
function validate2(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate = __esm({
  "../../node_modules/uuid/dist/esm-node/validate.js"() {
    init_regex();
    validate_default = validate2;
  }
});

// ../../node_modules/uuid/dist/esm-node/stringify.js
function stringify(arr, offset2 = 0) {
  const uuid = (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex, stringify_default;
var init_stringify = __esm({
  "../../node_modules/uuid/dist/esm-node/stringify.js"() {
    init_validate();
    byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).substr(1));
    }
    stringify_default = stringify;
  }
});

// ../../node_modules/uuid/dist/esm-node/v1.js
function v1(options, buf, offset2) {
  let i = buf && offset2 || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node2 = options.node || _nodeId;
  let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node2 == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || rng)();
    if (node2 == null) {
      node2 = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  const tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (let n = 0; n < 6; ++n) {
    b[i + n] = node2[n];
  }
  return buf || stringify_default(b);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "../../node_modules/uuid/dist/esm-node/v1.js"() {
    init_rng();
    init_stringify();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  }
});

// ../../node_modules/uuid/dist/esm-node/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default;
var init_parse = __esm({
  "../../node_modules/uuid/dist/esm-node/parse.js"() {
    init_validate();
    parse_default = parse;
  }
});

// ../../node_modules/uuid/dist/esm-node/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes2 = [];
  for (let i = 0; i < str.length; ++i) {
    bytes2.push(str.charCodeAt(i));
  }
  return bytes2;
}
function v35_default(name, version2, hashfunc) {
  function generateUUID(value, namespace, buf, offset2) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes2 = new Uint8Array(16 + value.length);
    bytes2.set(namespace);
    bytes2.set(value, namespace.length);
    bytes2 = hashfunc(bytes2);
    bytes2[6] = bytes2[6] & 15 | version2;
    bytes2[8] = bytes2[8] & 63 | 128;
    if (buf) {
      offset2 = offset2 || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset2 + i] = bytes2[i];
      }
      return buf;
    }
    return stringify_default(bytes2);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}
var DNS, URL;
var init_v35 = __esm({
  "../../node_modules/uuid/dist/esm-node/v35.js"() {
    init_stringify();
    init_parse();
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  }
});

// ../../node_modules/uuid/dist/esm-node/md5.js
import crypto5 from "crypto";
function md5(bytes2) {
  if (Array.isArray(bytes2)) {
    bytes2 = Buffer.from(bytes2);
  } else if (typeof bytes2 === "string") {
    bytes2 = Buffer.from(bytes2, "utf8");
  }
  return crypto5.createHash("md5").update(bytes2).digest();
}
var md5_default;
var init_md5 = __esm({
  "../../node_modules/uuid/dist/esm-node/md5.js"() {
    md5_default = md5;
  }
});

// ../../node_modules/uuid/dist/esm-node/v3.js
var v3, v3_default;
var init_v3 = __esm({
  "../../node_modules/uuid/dist/esm-node/v3.js"() {
    init_v35();
    init_md5();
    v3 = v35_default("v3", 48, md5_default);
    v3_default = v3;
  }
});

// ../../node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset2) {
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset2 = offset2 || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset2 + i] = rnds[i];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default;
var init_v4 = __esm({
  "../../node_modules/uuid/dist/esm-node/v4.js"() {
    init_rng();
    init_stringify();
    v4_default = v4;
  }
});

// ../../node_modules/uuid/dist/esm-node/sha1.js
import crypto6 from "crypto";
function sha1(bytes2) {
  if (Array.isArray(bytes2)) {
    bytes2 = Buffer.from(bytes2);
  } else if (typeof bytes2 === "string") {
    bytes2 = Buffer.from(bytes2, "utf8");
  }
  return crypto6.createHash("sha1").update(bytes2).digest();
}
var sha1_default;
var init_sha1 = __esm({
  "../../node_modules/uuid/dist/esm-node/sha1.js"() {
    sha1_default = sha1;
  }
});

// ../../node_modules/uuid/dist/esm-node/v5.js
var v5, v5_default;
var init_v5 = __esm({
  "../../node_modules/uuid/dist/esm-node/v5.js"() {
    init_v35();
    init_sha1();
    v5 = v35_default("v5", 80, sha1_default);
    v5_default = v5;
  }
});

// ../../node_modules/uuid/dist/esm-node/nil.js
var nil_default;
var init_nil = __esm({
  "../../node_modules/uuid/dist/esm-node/nil.js"() {
    nil_default = "00000000-0000-0000-0000-000000000000";
  }
});

// ../../node_modules/uuid/dist/esm-node/version.js
function version(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.substr(14, 1), 16);
}
var version_default;
var init_version = __esm({
  "../../node_modules/uuid/dist/esm-node/version.js"() {
    init_validate();
    version_default = version;
  }
});

// ../../node_modules/uuid/dist/esm-node/index.js
var esm_node_exports = {};
__export(esm_node_exports, {
  NIL: () => nil_default,
  parse: () => parse_default,
  stringify: () => stringify_default,
  v1: () => v1_default,
  v3: () => v3_default,
  v4: () => v4_default,
  v5: () => v5_default,
  validate: () => validate_default,
  version: () => version_default
});
var init_esm_node = __esm({
  "../../node_modules/uuid/dist/esm-node/index.js"() {
    init_v1();
    init_v3();
    init_v4();
    init_v5();
    init_nil();
    init_version();
    init_validate();
    init_stringify();
    init_parse();
  }
});

// ../../node_modules/jayson/lib/generateRequest.js
var require_generateRequest = __commonJS({
  "../../node_modules/jayson/lib/generateRequest.js"(exports, module) {
    "use strict";
    var uuid = (init_esm_node(), __toCommonJS(esm_node_exports)).v4;
    var generateRequest = function(method, params, id, options) {
      if (typeof method !== "string") {
        throw new TypeError(method + " must be a string");
      }
      options = options || {};
      const version2 = typeof options.version === "number" ? options.version : 2;
      if (version2 !== 1 && version2 !== 2) {
        throw new TypeError(version2 + " must be 1 or 2");
      }
      const request = {
        method
      };
      if (version2 === 2) {
        request.jsonrpc = "2.0";
      }
      if (params) {
        if (typeof params !== "object" && !Array.isArray(params)) {
          throw new TypeError(params + " must be an object, array or omitted");
        }
        request.params = params;
      }
      if (typeof id === "undefined") {
        const generator = typeof options.generator === "function" ? options.generator : function() {
          return uuid();
        };
        request.id = generator(request, options);
      } else if (version2 === 2 && id === null) {
        if (options.notificationIdNull) {
          request.id = null;
        }
      } else {
        request.id = id;
      }
      return request;
    };
    module.exports = generateRequest;
  }
});

// ../../node_modules/jayson/lib/client/browser/index.js
var require_browser = __commonJS({
  "../../node_modules/jayson/lib/client/browser/index.js"(exports, module) {
    "use strict";
    var uuid = (init_esm_node(), __toCommonJS(esm_node_exports)).v4;
    var generateRequest = require_generateRequest();
    var ClientBrowser = function(callServer, options) {
      if (!(this instanceof ClientBrowser)) {
        return new ClientBrowser(callServer, options);
      }
      if (!options) {
        options = {};
      }
      this.options = {
        reviver: typeof options.reviver !== "undefined" ? options.reviver : null,
        replacer: typeof options.replacer !== "undefined" ? options.replacer : null,
        generator: typeof options.generator !== "undefined" ? options.generator : function() {
          return uuid();
        },
        version: typeof options.version !== "undefined" ? options.version : 2,
        notificationIdNull: typeof options.notificationIdNull === "boolean" ? options.notificationIdNull : false
      };
      this.callServer = callServer;
    };
    module.exports = ClientBrowser;
    ClientBrowser.prototype.request = function(method, params, id, callback) {
      const self2 = this;
      let request = null;
      const isBatch = Array.isArray(method) && typeof params === "function";
      if (this.options.version === 1 && isBatch) {
        throw new TypeError("JSON-RPC 1.0 does not support batching");
      }
      const isRaw = !isBatch && method && typeof method === "object" && typeof params === "function";
      if (isBatch || isRaw) {
        callback = params;
        request = method;
      } else {
        if (typeof id === "function") {
          callback = id;
          id = void 0;
        }
        const hasCallback = typeof callback === "function";
        try {
          request = generateRequest(method, params, id, {
            generator: this.options.generator,
            version: this.options.version,
            notificationIdNull: this.options.notificationIdNull
          });
        } catch (err) {
          if (hasCallback) {
            return callback(err);
          }
          throw err;
        }
        if (!hasCallback) {
          return request;
        }
      }
      let message2;
      try {
        message2 = JSON.stringify(request, this.options.replacer);
      } catch (err) {
        return callback(err);
      }
      this.callServer(message2, function(err, response) {
        self2._parseResponse(err, response, callback);
      });
      return request;
    };
    ClientBrowser.prototype._parseResponse = function(err, responseText, callback) {
      if (err) {
        callback(err);
        return;
      }
      if (!responseText) {
        return callback();
      }
      let response;
      try {
        response = JSON.parse(responseText, this.options.reviver);
      } catch (err2) {
        return callback(err2);
      }
      if (callback.length === 3) {
        if (Array.isArray(response)) {
          const isError = function(res) {
            return typeof res.error !== "undefined";
          };
          const isNotError = function(res) {
            return !isError(res);
          };
          return callback(null, response.filter(isError), response.filter(isNotError));
        } else {
          return callback(null, response.error, response.result);
        }
      }
      callback(null, response);
    };
  }
});

// node_modules/webidl-conversions/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/webidl-conversions/lib/index.js"(exports) {
    "use strict";
    function _(message2, opts) {
      return `${opts && opts.context ? opts.context : "Value"} ${message2}.`;
    }
    function type2(V) {
      if (V === null) {
        return "Null";
      }
      switch (typeof V) {
        case "undefined":
          return "Undefined";
        case "boolean":
          return "Boolean";
        case "number":
          return "Number";
        case "string":
          return "String";
        case "symbol":
          return "Symbol";
        case "object":
        case "function":
        default:
          return "Object";
      }
    }
    function evenRound(x) {
      if (x > 0 && x % 1 === 0.5 && (x & 1) === 0 || x < 0 && x % 1 === -0.5 && (x & 1) === 1) {
        return censorNegativeZero(Math.floor(x));
      }
      return censorNegativeZero(Math.round(x));
    }
    function integerPart(n) {
      return censorNegativeZero(Math.trunc(n));
    }
    function sign2(x) {
      return x < 0 ? -1 : 1;
    }
    function modulo(x, y2) {
      const signMightNotMatch = x % y2;
      if (sign2(y2) !== sign2(signMightNotMatch)) {
        return signMightNotMatch + y2;
      }
      return signMightNotMatch;
    }
    function censorNegativeZero(x) {
      return x === 0 ? 0 : x;
    }
    function createIntegerConversion(bitLength, typeOpts) {
      const isSigned = !typeOpts.unsigned;
      let lowerBound;
      let upperBound;
      if (bitLength === 64) {
        upperBound = Math.pow(2, 53) - 1;
        lowerBound = !isSigned ? 0 : -Math.pow(2, 53) + 1;
      } else if (!isSigned) {
        lowerBound = 0;
        upperBound = Math.pow(2, bitLength) - 1;
      } else {
        lowerBound = -Math.pow(2, bitLength - 1);
        upperBound = Math.pow(2, bitLength - 1) - 1;
      }
      const twoToTheBitLength = Math.pow(2, bitLength);
      const twoToOneLessThanTheBitLength = Math.pow(2, bitLength - 1);
      return (V, opts) => {
        if (opts === void 0) {
          opts = {};
        }
        let x = +V;
        x = censorNegativeZero(x);
        if (opts.enforceRange) {
          if (!Number.isFinite(x)) {
            throw new TypeError(_("is not a finite number", opts));
          }
          x = integerPart(x);
          if (x < lowerBound || x > upperBound) {
            throw new TypeError(_(
              `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`,
              opts
            ));
          }
          return x;
        }
        if (!Number.isNaN(x) && opts.clamp) {
          x = Math.min(Math.max(x, lowerBound), upperBound);
          x = evenRound(x);
          return x;
        }
        if (!Number.isFinite(x) || x === 0) {
          return 0;
        }
        x = integerPart(x);
        if (x >= lowerBound && x <= upperBound) {
          return x;
        }
        x = modulo(x, twoToTheBitLength);
        if (isSigned && x >= twoToOneLessThanTheBitLength) {
          return x - twoToTheBitLength;
        }
        return x;
      };
    }
    exports.any = (V) => {
      return V;
    };
    exports.void = function() {
      return void 0;
    };
    exports.boolean = function(val) {
      return !!val;
    };
    exports.byte = createIntegerConversion(8, { unsigned: false });
    exports.octet = createIntegerConversion(8, { unsigned: true });
    exports.short = createIntegerConversion(16, { unsigned: false });
    exports["unsigned short"] = createIntegerConversion(16, { unsigned: true });
    exports.long = createIntegerConversion(32, { unsigned: false });
    exports["unsigned long"] = createIntegerConversion(32, { unsigned: true });
    exports["long long"] = createIntegerConversion(64, { unsigned: false });
    exports["unsigned long long"] = createIntegerConversion(64, { unsigned: true });
    exports.double = (V, opts) => {
      const x = +V;
      if (!Number.isFinite(x)) {
        throw new TypeError(_("is not a finite floating-point value", opts));
      }
      return x;
    };
    exports["unrestricted double"] = (V) => {
      const x = +V;
      return x;
    };
    exports.float = (V, opts) => {
      const x = +V;
      if (!Number.isFinite(x)) {
        throw new TypeError(_("is not a finite floating-point value", opts));
      }
      if (Object.is(x, -0)) {
        return x;
      }
      const y2 = Math.fround(x);
      if (!Number.isFinite(y2)) {
        throw new TypeError(_("is outside the range of a single-precision floating-point value", opts));
      }
      return y2;
    };
    exports["unrestricted float"] = (V) => {
      const x = +V;
      if (isNaN(x)) {
        return x;
      }
      if (Object.is(x, -0)) {
        return x;
      }
      return Math.fround(x);
    };
    exports.DOMString = function(V, opts) {
      if (opts === void 0) {
        opts = {};
      }
      if (opts.treatNullAsEmptyString && V === null) {
        return "";
      }
      if (typeof V === "symbol") {
        throw new TypeError(_("is a symbol, which cannot be converted to a string", opts));
      }
      return String(V);
    };
    exports.ByteString = (V, opts) => {
      const x = exports.DOMString(V, opts);
      let c;
      for (let i = 0; (c = x.codePointAt(i)) !== void 0; ++i) {
        if (c > 255) {
          throw new TypeError(_("is not a valid ByteString", opts));
        }
      }
      return x;
    };
    exports.USVString = (V, opts) => {
      const S = exports.DOMString(V, opts);
      const n = S.length;
      const U = [];
      for (let i = 0; i < n; ++i) {
        const c = S.charCodeAt(i);
        if (c < 55296 || c > 57343) {
          U.push(String.fromCodePoint(c));
        } else if (56320 <= c && c <= 57343) {
          U.push(String.fromCodePoint(65533));
        } else if (i === n - 1) {
          U.push(String.fromCodePoint(65533));
        } else {
          const d2 = S.charCodeAt(i + 1);
          if (56320 <= d2 && d2 <= 57343) {
            const a = c & 1023;
            const b = d2 & 1023;
            U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
            ++i;
          } else {
            U.push(String.fromCodePoint(65533));
          }
        }
      }
      return U.join("");
    };
    exports.object = (V, opts) => {
      if (type2(V) !== "Object") {
        throw new TypeError(_("is not an object", opts));
      }
      return V;
    };
    function convertCallbackFunction(V, opts) {
      if (typeof V !== "function") {
        throw new TypeError(_("is not a function", opts));
      }
      return V;
    }
    [
      Error,
      ArrayBuffer,
      // The IsDetachedBuffer abstract operation is not exposed in JS
      DataView,
      Int8Array,
      Int16Array,
      Int32Array,
      Uint8Array,
      Uint16Array,
      Uint32Array,
      Uint8ClampedArray,
      Float32Array,
      Float64Array
    ].forEach((func) => {
      const name = func.name;
      const article = /^[AEIOU]/.test(name) ? "an" : "a";
      exports[name] = (V, opts) => {
        if (!(V instanceof func)) {
          throw new TypeError(_(`is not ${article} ${name} object`, opts));
        }
        return V;
      };
    });
    exports.ArrayBufferView = (V, opts) => {
      if (!ArrayBuffer.isView(V)) {
        throw new TypeError(_("is not a view on an ArrayBuffer object", opts));
      }
      return V;
    };
    exports.BufferSource = (V, opts) => {
      if (!(ArrayBuffer.isView(V) || V instanceof ArrayBuffer)) {
        throw new TypeError(_("is not an ArrayBuffer object or a view on one", opts));
      }
      return V;
    };
    exports.DOMTimeStamp = exports["unsigned long long"];
    exports.Function = convertCallbackFunction;
    exports.VoidFunction = convertCallbackFunction;
  }
});

// node_modules/whatwg-url/lib/utils.js
var require_utils = __commonJS({
  "node_modules/whatwg-url/lib/utils.js"(exports, module) {
    "use strict";
    function isObject2(value) {
      return typeof value === "object" && value !== null || typeof value === "function";
    }
    function hasOwn(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var getOwnPropertyDescriptors = typeof Object.getOwnPropertyDescriptors === "function" ? Object.getOwnPropertyDescriptors : (
      // Polyfill exists until we require Node.js v8.x
      // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
      (obj) => {
        if (obj === void 0 || obj === null) {
          throw new TypeError("Cannot convert undefined or null to object");
        }
        obj = Object(obj);
        const ownKeys = Reflect.ownKeys(obj);
        const descriptors = {};
        for (const key of ownKeys) {
          const descriptor = Reflect.getOwnPropertyDescriptor(obj, key);
          if (descriptor !== void 0) {
            Reflect.defineProperty(descriptors, key, {
              value: descriptor,
              writable: true,
              enumerable: true,
              configurable: true
            });
          }
        }
        return descriptors;
      }
    );
    var wrapperSymbol = Symbol("wrapper");
    var implSymbol = Symbol("impl");
    var sameObjectCaches = Symbol("SameObject caches");
    function getSameObject(wrapper, prop, creator) {
      if (!wrapper[sameObjectCaches]) {
        wrapper[sameObjectCaches] = /* @__PURE__ */ Object.create(null);
      }
      if (prop in wrapper[sameObjectCaches]) {
        return wrapper[sameObjectCaches][prop];
      }
      wrapper[sameObjectCaches][prop] = creator();
      return wrapper[sameObjectCaches][prop];
    }
    function wrapperForImpl(impl) {
      return impl ? impl[wrapperSymbol] : null;
    }
    function implForWrapper(wrapper) {
      return wrapper ? wrapper[implSymbol] : null;
    }
    function tryWrapperForImpl(impl) {
      const wrapper = wrapperForImpl(impl);
      return wrapper ? wrapper : impl;
    }
    function tryImplForWrapper(wrapper) {
      const impl = implForWrapper(wrapper);
      return impl ? impl : wrapper;
    }
    var iterInternalSymbol = Symbol("internal");
    var IteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
    function isArrayIndexPropName(P) {
      if (typeof P !== "string") {
        return false;
      }
      const i = P >>> 0;
      if (i === Math.pow(2, 32) - 1) {
        return false;
      }
      const s2 = `${i}`;
      if (P !== s2) {
        return false;
      }
      return true;
    }
    var supportsPropertyIndex = Symbol("supports property index");
    var supportedPropertyIndices = Symbol("supported property indices");
    var supportsPropertyName = Symbol("supports property name");
    var supportedPropertyNames = Symbol("supported property names");
    var indexedGet = Symbol("indexed property get");
    var indexedSetNew = Symbol("indexed property set new");
    var indexedSetExisting = Symbol("indexed property set existing");
    var namedGet = Symbol("named property get");
    var namedSetNew = Symbol("named property set new");
    var namedSetExisting = Symbol("named property set existing");
    var namedDelete = Symbol("named property delete");
    module.exports = exports = {
      isObject: isObject2,
      hasOwn,
      getOwnPropertyDescriptors,
      wrapperSymbol,
      implSymbol,
      getSameObject,
      wrapperForImpl,
      implForWrapper,
      tryWrapperForImpl,
      tryImplForWrapper,
      iterInternalSymbol,
      IteratorPrototype,
      isArrayIndexPropName,
      supportsPropertyIndex,
      supportedPropertyIndices,
      supportsPropertyName,
      supportedPropertyNames,
      indexedGet,
      indexedSetNew,
      indexedSetExisting,
      namedGet,
      namedSetNew,
      namedSetExisting,
      namedDelete
    };
  }
});

// node_modules/tr46/lib/regexes.js
var require_regexes = __commonJS({
  "node_modules/tr46/lib/regexes.js"(exports, module) {
    "use strict";
    var combiningMarks = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{11000}-\u{11002}\u{11038}-\u{11046}\u{1107F}-\u{11082}\u{110B0}-\u{110BA}\u{11100}-\u{11102}\u{11127}-\u{11134}\u{11173}\u{11180}-\u{11182}\u{111B3}-\u{111C0}\u{111CA}-\u{111CC}\u{1122C}-\u{11237}\u{1123E}\u{112DF}-\u{112EA}\u{11300}-\u{11303}\u{1133C}\u{1133E}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11357}\u{11362}\u{11363}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11435}-\u{11446}\u{114B0}-\u{114C3}\u{115AF}-\u{115B5}\u{115B8}-\u{115C0}\u{115DC}\u{115DD}\u{11630}-\u{11640}\u{116AB}-\u{116B7}\u{1171D}-\u{1172B}\u{11A01}-\u{11A0A}\u{11A33}-\u{11A39}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A5B}\u{11A8A}-\u{11A99}\u{11C2F}-\u{11C36}\u{11C38}-\u{11C3F}\u{11C92}-\u{11CA7}\u{11CA9}-\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F51}-\u{16F7E}\u{16F8F}-\u{16F92}\u{1BC9D}\u{1BC9E}\u{1D165}-\u{1D169}\u{1D16D}-\u{1D172}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]/u;
    var combiningClassVirama = /[\u094D\u09CD\u0A4D\u0ACD\u0B4D\u0BCD\u0C4D\u0CCD\u0D3B\u0D3C\u0D4D\u0DCA\u0E3A\u0F84\u1039\u103A\u1714\u1734\u17D2\u1A60\u1B44\u1BAA\u1BAB\u1BF2\u1BF3\u2D7F\uA806\uA8C4\uA953\uA9C0\uAAF6\uABED\u{10A3F}\u{11046}\u{1107F}\u{110B9}\u{11133}\u{11134}\u{111C0}\u{11235}\u{112EA}\u{1134D}\u{11442}\u{114C2}\u{115BF}\u{1163F}\u{116B6}\u{1172B}\u{11A34}\u{11A47}\u{11A99}\u{11C3F}\u{11D44}\u{11D45}]/u;
    var validZWNJ = /[\u0620\u0626\u0628\u062A-\u062E\u0633-\u063F\u0641-\u0647\u0649\u064A\u066E\u066F\u0678-\u0687\u069A-\u06BF\u06C1\u06C2\u06CC\u06CE\u06D0\u06D1\u06FA-\u06FC\u06FF\u0712-\u0714\u071A-\u071D\u071F-\u0727\u0729\u072B\u072D\u072E\u074E-\u0758\u075C-\u076A\u076D-\u0770\u0772\u0775-\u0777\u077A-\u077F\u07CA-\u07EA\u0841-\u0845\u0848\u084A-\u0853\u0855\u0860\u0862-\u0865\u0868\u08A0-\u08A9\u08AF\u08B0\u08B3\u08B4\u08B6-\u08B8\u08BA-\u08BD\u1807\u1820-\u1877\u1887-\u18A8\u18AA\uA840-\uA872\u{10AC0}-\u{10AC4}\u{10ACD}\u{10AD3}-\u{10ADC}\u{10ADE}-\u{10AE0}\u{10AEB}-\u{10AEE}\u{10B80}\u{10B82}\u{10B86}-\u{10B88}\u{10B8A}\u{10B8B}\u{10B8D}\u{10B90}\u{10BAD}\u{10BAE}\u{1E900}-\u{1E943}][\xAD\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u061C\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u070F\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200B\u200E\u200F\u202A-\u202E\u2060-\u2064\u206A-\u206F\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8C5\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFEFF\uFFF9-\uFFFB\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{11001}\u{11038}-\u{11046}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110BD}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111CA}-\u{111CC}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C3F}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F8F}-\u{16F92}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*\u200C[\xAD\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u061C\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u070F\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC6\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200B\u200E\u200F\u202A-\u202E\u2060-\u2064\u206A-\u206F\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8C5\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFEFF\uFFF9-\uFFFB\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{11001}\u{11038}-\u{11046}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{110BD}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111CA}-\u{111CC}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C3F}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F8F}-\u{16F92}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*[\u0620\u0622-\u063F\u0641-\u064A\u066E\u066F\u0671-\u0673\u0675-\u06D3\u06D5\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u077F\u07CA-\u07EA\u0840-\u0855\u0860\u0862-\u0865\u0867-\u086A\u08A0-\u08AC\u08AE-\u08B4\u08B6-\u08BD\u1807\u1820-\u1877\u1887-\u18A8\u18AA\uA840-\uA871\u{10AC0}-\u{10AC5}\u{10AC7}\u{10AC9}\u{10ACA}\u{10ACE}-\u{10AD6}\u{10AD8}-\u{10AE1}\u{10AE4}\u{10AEB}-\u{10AEF}\u{10B80}-\u{10B91}\u{10BA9}-\u{10BAE}\u{1E900}-\u{1E943}]/u;
    var bidiDomain = /[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05F0-\u05F4\u0600-\u0605\u0608\u060B\u060D\u061B\u061C\u061E-\u064A\u0660-\u0669\u066B-\u066F\u0671-\u06D5\u06DD\u06E5\u06E6\u06EE\u06EF\u06FA-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08E2\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A33}\u{10A40}-\u{10A47}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10CFF}\u{10E60}-\u{10E7E}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}]/u;
    var bidiS1LTR = /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02BB-\u02C1\u02D0\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0482\u048A-\u052F\u0531-\u0556\u0559-\u055F\u0561-\u0587\u0589\u0903-\u0939\u093B\u093D-\u0940\u0949-\u094C\u094E-\u0950\u0958-\u0961\u0964-\u0980\u0982\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C0\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09FA\u09FC\u09FD\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A40\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC0\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0\u0AE1\u0AE6-\u0AF0\u0AF9\u0B02\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0BE6-\u0BF2\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C41-\u0C44\u0C58-\u0C5A\u0C60\u0C61\u0C66-\u0C6F\u0C7F\u0C80\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D4F\u0D54-\u0D61\u0D66-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E4F-\u0E5B\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F17\u0F1A-\u0F34\u0F36\u0F38\u0F3E-\u0F47\u0F49-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE-\u0FDA\u1000-\u102C\u1031\u1038\u103B\u103C\u103F-\u1057\u105A-\u105D\u1061-\u1070\u1075-\u1081\u1083\u1084\u1087-\u108C\u108E-\u109C\u109E-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1360-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u167F\u1681-\u169A\u16A0-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1735\u1736\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17B6\u17BE-\u17C5\u17C7\u17C8\u17D4-\u17DA\u17DC\u17E0-\u17E9\u1810-\u1819\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A19\u1A1A\u1A1E-\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1A80-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1B04-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B4B\u1B50-\u1B6A\u1B74-\u1B7C\u1B82-\u1BA1\u1BA6\u1BA7\u1BAA\u1BAE-\u1BE5\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1BFC-\u1C2B\u1C34\u1C35\u1C3B-\u1C49\u1C4D-\u1C88\u1CC0-\u1CC7\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5-\u1CF7\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200E\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u214F\u2160-\u2188\u2336-\u237A\u2395\u249C-\u24E9\u26AC\u2800-\u28FF\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u302E\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u3190-\u31BA\u31F0-\u321C\u3220-\u324F\u3260-\u327B\u327F-\u32B0\u32C0-\u32CB\u32D0-\u32FE\u3300-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA60C\uA610-\uA62B\uA640-\uA66E\uA680-\uA69D\uA6A0-\uA6EF\uA6F2-\uA6F7\uA722-\uA787\uA789-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA824\uA827\uA830-\uA837\uA840-\uA873\uA880-\uA8C3\uA8CE-\uA8D9\uA8F2-\uA8FD\uA900-\uA925\uA92E-\uA946\uA952\uA953\uA95F-\uA97C\uA983-\uA9B2\uA9B4\uA9B5\uA9BA\uA9BB\uA9BD-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA2F\uAA30\uAA33\uAA34\uAA40-\uAA42\uAA44-\uAA4B\uAA4D\uAA50-\uAA59\uAA5C-\uAA7B\uAA7D-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAAEB\uAAEE-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB65\uAB70-\uABE4\uABE6\uABE7\uABE9-\uABEC\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1013F}\u{1018D}\u{1018E}\u{101D0}-\u{101FC}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{10375}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{11000}\u{11002}-\u{11037}\u{11047}-\u{1104D}\u{11066}-\u{1106F}\u{11082}-\u{110B2}\u{110B7}\u{110B8}\u{110BB}-\u{110C1}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11103}-\u{11126}\u{1112C}\u{11136}-\u{11143}\u{11150}-\u{11172}\u{11174}-\u{11176}\u{11182}-\u{111B5}\u{111BF}-\u{111C9}\u{111CD}\u{111D0}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{1122E}\u{11232}\u{11233}\u{11235}\u{11238}-\u{1123D}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112DE}\u{112E0}-\u{112E2}\u{112F0}-\u{112F9}\u{11302}\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133D}-\u{1133F}\u{11341}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11400}-\u{11437}\u{11440}\u{11441}\u{11445}\u{11447}-\u{11459}\u{1145B}\u{1145D}\u{11480}-\u{114B2}\u{114B9}\u{114BB}-\u{114BE}\u{114C1}\u{114C4}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B1}\u{115B8}-\u{115BB}\u{115BE}\u{115C1}-\u{115DB}\u{11600}-\u{11632}\u{1163B}\u{1163C}\u{1163E}\u{11641}-\u{11644}\u{11650}-\u{11659}\u{11680}-\u{116AA}\u{116AC}\u{116AE}\u{116AF}\u{116B6}\u{116C0}-\u{116C9}\u{11700}-\u{11719}\u{11720}\u{11721}\u{11726}\u{11730}-\u{1173F}\u{118A0}-\u{118F2}\u{118FF}\u{11A00}\u{11A07}\u{11A08}\u{11A0B}-\u{11A32}\u{11A39}\u{11A3A}\u{11A3F}-\u{11A46}\u{11A50}\u{11A57}\u{11A58}\u{11A5C}-\u{11A83}\u{11A86}-\u{11A89}\u{11A97}\u{11A9A}-\u{11A9C}\u{11A9E}-\u{11AA2}\u{11AC0}-\u{11AF8}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C2F}\u{11C3E}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11CA9}\u{11CB1}\u{11CB4}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D30}\u{11D46}\u{11D50}-\u{11D59}\u{12000}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{13000}-\u{1342E}\u{14400}-\u{14646}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}\u{16A6F}\u{16AD0}-\u{16AED}\u{16AF5}\u{16B00}-\u{16B2F}\u{16B37}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16F00}-\u{16F44}\u{16F50}-\u{16F7E}\u{16F93}-\u{16F9F}\u{16FE0}\u{16FE1}\u{17000}-\u{187EC}\u{18800}-\u{18AF2}\u{1B000}-\u{1B11E}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}\u{1BC9F}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D166}\u{1D16A}-\u{1D172}\u{1D183}\u{1D184}\u{1D18C}-\u{1D1A9}\u{1D1AE}-\u{1D1E8}\u{1D360}-\u{1D371}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D6DA}\u{1D6DC}-\u{1D714}\u{1D716}-\u{1D74E}\u{1D750}-\u{1D788}\u{1D78A}-\u{1D7C2}\u{1D7C4}-\u{1D7CB}\u{1D800}-\u{1D9FF}\u{1DA37}-\u{1DA3A}\u{1DA6D}-\u{1DA74}\u{1DA76}-\u{1DA83}\u{1DA85}-\u{1DA8B}\u{1F110}-\u{1F12E}\u{1F130}-\u{1F169}\u{1F170}-\u{1F1AC}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{20000}-\u{2A6D6}\u{2A700}-\u{2B734}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2F800}-\u{2FA1D}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}]/u;
    var bidiS1RTL = /[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05F0-\u05F4\u0608\u060B\u060D\u061B\u061C\u061E-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A33}\u{10A40}-\u{10A47}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10CFF}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}]/u;
    var bidiS2 = /^[\0-\x08\x0E-\x1B!-@\[-`\{-\x84\x86-\xA9\xAB-\xB4\xB6-\xB9\xBB-\xBF\xD7\xF7\u02B9\u02BA\u02C2-\u02CF\u02D2-\u02DF\u02E5-\u02ED\u02EF-\u036F\u0374\u0375\u037E\u0384\u0385\u0387\u03F6\u0483-\u0489\u058A\u058D-\u058F\u0591-\u05C7\u05D0-\u05EA\u05F0-\u05F4\u0600-\u061C\u061E-\u070D\u070F-\u074A\u074D-\u07B1\u07C0-\u07FA\u0800-\u082D\u0830-\u083E\u0840-\u085B\u085E\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u09F2\u09F3\u09FB\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AF1\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0BF3-\u0BFA\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C78-\u0C7E\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E3F\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39-\u0F3D\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1390-\u1399\u1400\u169B\u169C\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DB\u17DD\u17F0-\u17F9\u1800-\u180E\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1940\u1944\u1945\u19DE-\u19FF\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u1FBD\u1FBF-\u1FC1\u1FCD-\u1FCF\u1FDD-\u1FDF\u1FED-\u1FEF\u1FFD\u1FFE\u200B-\u200D\u200F-\u2027\u202F-\u205E\u2060-\u2064\u206A-\u2070\u2074-\u207E\u2080-\u208E\u20A0-\u20BF\u20D0-\u20F0\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211E-\u2123\u2125\u2127\u2129\u212E\u213A\u213B\u2140-\u2144\u214A-\u214D\u2150-\u215F\u2189-\u218B\u2190-\u2335\u237B-\u2394\u2396-\u2426\u2440-\u244A\u2460-\u249B\u24EA-\u26AB\u26AD-\u27FF\u2900-\u2B73\u2B76-\u2B95\u2B98-\u2BB9\u2BBD-\u2BC8\u2BCA-\u2BD2\u2BEC-\u2BEF\u2CE5-\u2CEA\u2CEF-\u2CF1\u2CF9-\u2CFF\u2D7F\u2DE0-\u2E49\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u3004\u3008-\u3020\u302A-\u302D\u3030\u3036\u3037\u303D-\u303F\u3099-\u309C\u30A0\u30FB\u31C0-\u31E3\u321D\u321E\u3250-\u325F\u327C-\u327E\u32B1-\u32BF\u32CC-\u32CF\u3377-\u337A\u33DE\u33DF\u33FF\u4DC0-\u4DFF\uA490-\uA4C6\uA60D-\uA60F\uA66F-\uA67F\uA69E\uA69F\uA6F0\uA6F1\uA700-\uA721\uA788\uA802\uA806\uA80B\uA825\uA826\uA828-\uA82B\uA838\uA839\uA874-\uA877\uA8C4\uA8C5\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1D-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC1\uFBD3-\uFD3F\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFD\uFE00-\uFE19\uFE20-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFE70-\uFE74\uFE76-\uFEFC\uFEFF\uFF01-\uFF20\uFF3B-\uFF40\uFF5B-\uFF65\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD\u{10101}\u{10140}-\u{1018C}\u{10190}-\u{1019B}\u{101A0}\u{101FD}\u{102E0}-\u{102FB}\u{10376}-\u{1037A}\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{1091F}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A33}\u{10A38}-\u{10A3A}\u{10A3F}-\u{10A47}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE6}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B39}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10CFF}\u{10E60}-\u{10E7E}\u{11001}\u{11038}-\u{11046}\u{11052}-\u{11065}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111CA}-\u{111CC}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{11660}-\u{1166C}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F8F}-\u{16F92}\u{1BC9D}\u{1BC9E}\u{1BCA0}-\u{1BCA3}\u{1D167}-\u{1D169}\u{1D173}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D200}-\u{1D245}\u{1D300}-\u{1D356}\u{1D6DB}\u{1D715}\u{1D74F}\u{1D789}\u{1D7C3}\u{1D7CE}-\u{1D7FF}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8D6}\u{1E900}-\u{1E94A}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}\u{1EEF0}\u{1EEF1}\u{1F000}-\u{1F02B}\u{1F030}-\u{1F093}\u{1F0A0}-\u{1F0AE}\u{1F0B1}-\u{1F0BF}\u{1F0C1}-\u{1F0CF}\u{1F0D1}-\u{1F0F5}\u{1F100}-\u{1F10C}\u{1F16A}\u{1F16B}\u{1F260}-\u{1F265}\u{1F300}-\u{1F6D4}\u{1F6E0}-\u{1F6EC}\u{1F6F0}-\u{1F6F8}\u{1F700}-\u{1F773}\u{1F780}-\u{1F7D4}\u{1F800}-\u{1F80B}\u{1F810}-\u{1F847}\u{1F850}-\u{1F859}\u{1F860}-\u{1F887}\u{1F890}-\u{1F8AD}\u{1F900}-\u{1F90B}\u{1F910}-\u{1F93E}\u{1F940}-\u{1F94C}\u{1F950}-\u{1F96B}\u{1F980}-\u{1F997}\u{1F9C0}\u{1F9D0}-\u{1F9E6}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}]*$/u;
    var bidiS3 = /[0-9\xB2\xB3\xB9\u05BE\u05C0\u05C3\u05C6\u05D0-\u05EA\u05F0-\u05F4\u0600-\u0605\u0608\u060B\u060D\u061B\u061C\u061E-\u064A\u0660-\u0669\u066B-\u066F\u0671-\u06D5\u06DD\u06E5\u06E6\u06EE-\u070D\u070F\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0830-\u083E\u0840-\u0858\u085E\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08E2\u200F\u2070\u2074-\u2079\u2080-\u2089\u2488-\u249B\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBC1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFC\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\u{102E1}-\u{102FB}\u{10800}-\u{10805}\u{10808}\u{1080A}-\u{10835}\u{10837}\u{10838}\u{1083C}\u{1083F}-\u{10855}\u{10857}-\u{1089E}\u{108A7}-\u{108AF}\u{108E0}-\u{108F2}\u{108F4}\u{108F5}\u{108FB}-\u{1091B}\u{10920}-\u{10939}\u{1093F}\u{10980}-\u{109B7}\u{109BC}-\u{109CF}\u{109D2}-\u{10A00}\u{10A10}-\u{10A13}\u{10A15}-\u{10A17}\u{10A19}-\u{10A33}\u{10A40}-\u{10A47}\u{10A50}-\u{10A58}\u{10A60}-\u{10A9F}\u{10AC0}-\u{10AE4}\u{10AEB}-\u{10AF6}\u{10B00}-\u{10B35}\u{10B40}-\u{10B55}\u{10B58}-\u{10B72}\u{10B78}-\u{10B91}\u{10B99}-\u{10B9C}\u{10BA9}-\u{10BAF}\u{10C00}-\u{10C48}\u{10C80}-\u{10CB2}\u{10CC0}-\u{10CF2}\u{10CFA}-\u{10CFF}\u{10E60}-\u{10E7E}\u{1D7CE}-\u{1D7FF}\u{1E800}-\u{1E8C4}\u{1E8C7}-\u{1E8CF}\u{1E900}-\u{1E943}\u{1E950}-\u{1E959}\u{1E95E}\u{1E95F}\u{1EE00}-\u{1EE03}\u{1EE05}-\u{1EE1F}\u{1EE21}\u{1EE22}\u{1EE24}\u{1EE27}\u{1EE29}-\u{1EE32}\u{1EE34}-\u{1EE37}\u{1EE39}\u{1EE3B}\u{1EE42}\u{1EE47}\u{1EE49}\u{1EE4B}\u{1EE4D}-\u{1EE4F}\u{1EE51}\u{1EE52}\u{1EE54}\u{1EE57}\u{1EE59}\u{1EE5B}\u{1EE5D}\u{1EE5F}\u{1EE61}\u{1EE62}\u{1EE64}\u{1EE67}-\u{1EE6A}\u{1EE6C}-\u{1EE72}\u{1EE74}-\u{1EE77}\u{1EE79}-\u{1EE7C}\u{1EE7E}\u{1EE80}-\u{1EE89}\u{1EE8B}-\u{1EE9B}\u{1EEA1}-\u{1EEA3}\u{1EEA5}-\u{1EEA9}\u{1EEAB}-\u{1EEBB}\u{1F100}-\u{1F10A}][\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8C5\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{11001}\u{11038}-\u{11046}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111CA}-\u{111CC}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F8F}-\u{16F92}\u{1BC9D}\u{1BC9E}\u{1D167}-\u{1D169}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]*$/u;
    var bidiS4EN = /[0-9\xB2\xB3\xB9\u06F0-\u06F9\u2070\u2074-\u2079\u2080-\u2089\u2488-\u249B\uFF10-\uFF19\u{102E1}-\u{102FB}\u{1D7CE}-\u{1D7FF}\u{1F100}-\u{1F10A}]/u;
    var bidiS4AN = /[\u0600-\u0605\u0660-\u0669\u066B\u066C\u06DD\u08E2\u{10E60}-\u{10E7E}]/u;
    var bidiS5 = /^[\0-\x08\x0E-\x1B!-\x84\x86-\u0377\u037A-\u037F\u0384-\u038A\u038C\u038E-\u03A1\u03A3-\u052F\u0531-\u0556\u0559-\u055F\u0561-\u0587\u0589\u058A\u058D-\u058F\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0606\u0607\u0609\u060A\u060C\u060E-\u061A\u064B-\u065F\u066A\u0670\u06D6-\u06DC\u06DE-\u06E4\u06E7-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07F6-\u07F9\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09FD\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AF1\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B77\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BFA\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C78-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4F\u0D54-\u0D63\u0D66-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E3A\u0E3F-\u0E5B\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F47\u0F49-\u0F6C\u0F71-\u0F97\u0F99-\u0FBC\u0FBE-\u0FCC\u0FCE-\u0FDA\u1000-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u137C\u1380-\u1399\u13A0-\u13F5\u13F8-\u13FD\u1400-\u167F\u1681-\u169C\u16A0-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1736\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17DD\u17E0-\u17E9\u17F0-\u17F9\u1800-\u180E\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1940\u1944-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u19DE-\u1A1B\u1A1E-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1AB0-\u1ABE\u1B00-\u1B4B\u1B50-\u1B7C\u1B80-\u1BF3\u1BFC-\u1C37\u1C3B-\u1C49\u1C4D-\u1C88\u1CC0-\u1CC7\u1CD0-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FC4\u1FC6-\u1FD3\u1FD6-\u1FDB\u1FDD-\u1FEF\u1FF2-\u1FF4\u1FF6-\u1FFE\u200B-\u200E\u2010-\u2027\u202F-\u205E\u2060-\u2064\u206A-\u2071\u2074-\u208E\u2090-\u209C\u20A0-\u20BF\u20D0-\u20F0\u2100-\u218B\u2190-\u2426\u2440-\u244A\u2460-\u2B73\u2B76-\u2B95\u2B98-\u2BB9\u2BBD-\u2BC8\u2BCA-\u2BD2\u2BEC-\u2BEF\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CF3\u2CF9-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2E49\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u303F\u3041-\u3096\u3099-\u30FF\u3105-\u312E\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u32FE\u3300-\u4DB5\u4DC0-\u9FEA\uA000-\uA48C\uA490-\uA4C6\uA4D0-\uA62B\uA640-\uA6F7\uA700-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA82B\uA830-\uA839\uA840-\uA877\uA880-\uA8C5\uA8CE-\uA8D9\uA8E0-\uA8FD\uA900-\uA953\uA95F-\uA97C\uA980-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA5C-\uAAC2\uAADB-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB65\uAB70-\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1E\uFB29\uFD3E\uFD3F\uFDFD\uFE00-\uFE19\uFE20-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFEFF\uFF01-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\uFFE0-\uFFE6\uFFE8-\uFFEE\uFFF9-\uFFFD\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}-\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1018E}\u{10190}-\u{1019B}\u{101A0}\u{101D0}-\u{101FD}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{102E0}-\u{102FB}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{1037A}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{1091F}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{10B39}-\u{10B3F}\u{11000}-\u{1104D}\u{11052}-\u{1106F}\u{1107F}-\u{110C1}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11100}-\u{11134}\u{11136}-\u{11143}\u{11150}-\u{11176}\u{11180}-\u{111CD}\u{111D0}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{1123E}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112EA}\u{112F0}-\u{112F9}\u{11300}-\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133C}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11400}-\u{11459}\u{1145B}\u{1145D}\u{11480}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B5}\u{115B8}-\u{115DD}\u{11600}-\u{11644}\u{11650}-\u{11659}\u{11660}-\u{1166C}\u{11680}-\u{116B7}\u{116C0}-\u{116C9}\u{11700}-\u{11719}\u{1171D}-\u{1172B}\u{11730}-\u{1173F}\u{118A0}-\u{118F2}\u{118FF}\u{11A00}-\u{11A47}\u{11A50}-\u{11A83}\u{11A86}-\u{11A9C}\u{11A9E}-\u{11AA2}\u{11AC0}-\u{11AF8}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C36}\u{11C38}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11C92}-\u{11CA7}\u{11CA9}-\u{11CB6}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D47}\u{11D50}-\u{11D59}\u{12000}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{13000}-\u{1342E}\u{14400}-\u{14646}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}\u{16A6F}\u{16AD0}-\u{16AED}\u{16AF0}-\u{16AF5}\u{16B00}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16F00}-\u{16F44}\u{16F50}-\u{16F7E}\u{16F8F}-\u{16F9F}\u{16FE0}\u{16FE1}\u{17000}-\u{187EC}\u{18800}-\u{18AF2}\u{1B000}-\u{1B11E}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}-\u{1BCA3}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D1E8}\u{1D200}-\u{1D245}\u{1D300}-\u{1D356}\u{1D360}-\u{1D371}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D7CB}\u{1D7CE}-\u{1DA8B}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{1EEF0}\u{1EEF1}\u{1F000}-\u{1F02B}\u{1F030}-\u{1F093}\u{1F0A0}-\u{1F0AE}\u{1F0B1}-\u{1F0BF}\u{1F0C1}-\u{1F0CF}\u{1F0D1}-\u{1F0F5}\u{1F100}-\u{1F10C}\u{1F110}-\u{1F12E}\u{1F130}-\u{1F16B}\u{1F170}-\u{1F1AC}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{1F260}-\u{1F265}\u{1F300}-\u{1F6D4}\u{1F6E0}-\u{1F6EC}\u{1F6F0}-\u{1F6F8}\u{1F700}-\u{1F773}\u{1F780}-\u{1F7D4}\u{1F800}-\u{1F80B}\u{1F810}-\u{1F847}\u{1F850}-\u{1F859}\u{1F860}-\u{1F887}\u{1F890}-\u{1F8AD}\u{1F900}-\u{1F90B}\u{1F910}-\u{1F93E}\u{1F940}-\u{1F94C}\u{1F950}-\u{1F96B}\u{1F980}-\u{1F997}\u{1F9C0}\u{1F9D0}-\u{1F9E6}\u{20000}-\u{2A6D6}\u{2A700}-\u{2B734}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2F800}-\u{2FA1D}\u{E0001}\u{E0020}-\u{E007F}\u{E0100}-\u{E01EF}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}]*$/u;
    var bidiS6 = /[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u02BB-\u02C1\u02D0\u02D1\u02E0-\u02E4\u02EE\u0370-\u0373\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0482\u048A-\u052F\u0531-\u0556\u0559-\u055F\u0561-\u0587\u0589\u06F0-\u06F9\u0903-\u0939\u093B\u093D-\u0940\u0949-\u094C\u094E-\u0950\u0958-\u0961\u0964-\u0980\u0982\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD-\u09C0\u09C7\u09C8\u09CB\u09CC\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09FA\u09FC\u09FD\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3E-\u0A40\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD-\u0AC0\u0AC9\u0ACB\u0ACC\u0AD0\u0AE0\u0AE1\u0AE6-\u0AF0\u0AF9\u0B02\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B3E\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0B57\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0BD0\u0BD7\u0BE6-\u0BF2\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C41-\u0C44\u0C58-\u0C5A\u0C60\u0C61\u0C66-\u0C6F\u0C7F\u0C80\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD-\u0CC4\u0CC6-\u0CC8\u0CCA\u0CCB\u0CD5\u0CD6\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D4E\u0D4F\u0D54-\u0D61\u0D66-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCF-\u0DD1\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2-\u0DF4\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E4F-\u0E5B\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00-\u0F17\u0F1A-\u0F34\u0F36\u0F38\u0F3E-\u0F47\u0F49-\u0F6C\u0F7F\u0F85\u0F88-\u0F8C\u0FBE-\u0FC5\u0FC7-\u0FCC\u0FCE-\u0FDA\u1000-\u102C\u1031\u1038\u103B\u103C\u103F-\u1057\u105A-\u105D\u1061-\u1070\u1075-\u1081\u1083\u1084\u1087-\u108C\u108E-\u109C\u109E-\u10C5\u10C7\u10CD\u10D0-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1360-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u167F\u1681-\u169A\u16A0-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1735\u1736\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17B6\u17BE-\u17C5\u17C7\u17C8\u17D4-\u17DA\u17DC\u17E0-\u17E9\u1810-\u1819\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A19\u1A1A\u1A1E-\u1A55\u1A57\u1A61\u1A63\u1A64\u1A6D-\u1A72\u1A80-\u1A89\u1A90-\u1A99\u1AA0-\u1AAD\u1B04-\u1B33\u1B35\u1B3B\u1B3D-\u1B41\u1B43-\u1B4B\u1B50-\u1B6A\u1B74-\u1B7C\u1B82-\u1BA1\u1BA6\u1BA7\u1BAA\u1BAE-\u1BE5\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1BFC-\u1C2B\u1C34\u1C35\u1C3B-\u1C49\u1C4D-\u1C88\u1CC0-\u1CC7\u1CD3\u1CE1\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5-\u1CF7\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200E\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u214F\u2160-\u2188\u2336-\u237A\u2395\u2488-\u24E9\u26AC\u2800-\u28FF\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D70\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u302E\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u3190-\u31BA\u31F0-\u321C\u3220-\u324F\u3260-\u327B\u327F-\u32B0\u32C0-\u32CB\u32D0-\u32FE\u3300-\u3376\u337B-\u33DD\u33E0-\u33FE\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA60C\uA610-\uA62B\uA640-\uA66E\uA680-\uA69D\uA6A0-\uA6EF\uA6F2-\uA6F7\uA722-\uA787\uA789-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA824\uA827\uA830-\uA837\uA840-\uA873\uA880-\uA8C3\uA8CE-\uA8D9\uA8F2-\uA8FD\uA900-\uA925\uA92E-\uA946\uA952\uA953\uA95F-\uA97C\uA983-\uA9B2\uA9B4\uA9B5\uA9BA\uA9BB\uA9BD-\uA9CD\uA9CF-\uA9D9\uA9DE-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA2F\uAA30\uAA33\uAA34\uAA40-\uAA42\uAA44-\uAA4B\uAA4D\uAA50-\uAA59\uAA5C-\uAA7B\uAA7D-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAAEB\uAAEE-\uAAF5\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB65\uAB70-\uABE4\uABE6\uABE7\uABE9-\uABEC\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uD800-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u{10000}-\u{1000B}\u{1000D}-\u{10026}\u{10028}-\u{1003A}\u{1003C}\u{1003D}\u{1003F}-\u{1004D}\u{10050}-\u{1005D}\u{10080}-\u{100FA}\u{10100}\u{10102}\u{10107}-\u{10133}\u{10137}-\u{1013F}\u{1018D}\u{1018E}\u{101D0}-\u{101FC}\u{10280}-\u{1029C}\u{102A0}-\u{102D0}\u{102E1}-\u{102FB}\u{10300}-\u{10323}\u{1032D}-\u{1034A}\u{10350}-\u{10375}\u{10380}-\u{1039D}\u{1039F}-\u{103C3}\u{103C8}-\u{103D5}\u{10400}-\u{1049D}\u{104A0}-\u{104A9}\u{104B0}-\u{104D3}\u{104D8}-\u{104FB}\u{10500}-\u{10527}\u{10530}-\u{10563}\u{1056F}\u{10600}-\u{10736}\u{10740}-\u{10755}\u{10760}-\u{10767}\u{11000}\u{11002}-\u{11037}\u{11047}-\u{1104D}\u{11066}-\u{1106F}\u{11082}-\u{110B2}\u{110B7}\u{110B8}\u{110BB}-\u{110C1}\u{110D0}-\u{110E8}\u{110F0}-\u{110F9}\u{11103}-\u{11126}\u{1112C}\u{11136}-\u{11143}\u{11150}-\u{11172}\u{11174}-\u{11176}\u{11182}-\u{111B5}\u{111BF}-\u{111C9}\u{111CD}\u{111D0}-\u{111DF}\u{111E1}-\u{111F4}\u{11200}-\u{11211}\u{11213}-\u{1122E}\u{11232}\u{11233}\u{11235}\u{11238}-\u{1123D}\u{11280}-\u{11286}\u{11288}\u{1128A}-\u{1128D}\u{1128F}-\u{1129D}\u{1129F}-\u{112A9}\u{112B0}-\u{112DE}\u{112E0}-\u{112E2}\u{112F0}-\u{112F9}\u{11302}\u{11303}\u{11305}-\u{1130C}\u{1130F}\u{11310}\u{11313}-\u{11328}\u{1132A}-\u{11330}\u{11332}\u{11333}\u{11335}-\u{11339}\u{1133D}-\u{1133F}\u{11341}-\u{11344}\u{11347}\u{11348}\u{1134B}-\u{1134D}\u{11350}\u{11357}\u{1135D}-\u{11363}\u{11400}-\u{11437}\u{11440}\u{11441}\u{11445}\u{11447}-\u{11459}\u{1145B}\u{1145D}\u{11480}-\u{114B2}\u{114B9}\u{114BB}-\u{114BE}\u{114C1}\u{114C4}-\u{114C7}\u{114D0}-\u{114D9}\u{11580}-\u{115B1}\u{115B8}-\u{115BB}\u{115BE}\u{115C1}-\u{115DB}\u{11600}-\u{11632}\u{1163B}\u{1163C}\u{1163E}\u{11641}-\u{11644}\u{11650}-\u{11659}\u{11680}-\u{116AA}\u{116AC}\u{116AE}\u{116AF}\u{116B6}\u{116C0}-\u{116C9}\u{11700}-\u{11719}\u{11720}\u{11721}\u{11726}\u{11730}-\u{1173F}\u{118A0}-\u{118F2}\u{118FF}\u{11A00}\u{11A07}\u{11A08}\u{11A0B}-\u{11A32}\u{11A39}\u{11A3A}\u{11A3F}-\u{11A46}\u{11A50}\u{11A57}\u{11A58}\u{11A5C}-\u{11A83}\u{11A86}-\u{11A89}\u{11A97}\u{11A9A}-\u{11A9C}\u{11A9E}-\u{11AA2}\u{11AC0}-\u{11AF8}\u{11C00}-\u{11C08}\u{11C0A}-\u{11C2F}\u{11C3E}-\u{11C45}\u{11C50}-\u{11C6C}\u{11C70}-\u{11C8F}\u{11CA9}\u{11CB1}\u{11CB4}\u{11D00}-\u{11D06}\u{11D08}\u{11D09}\u{11D0B}-\u{11D30}\u{11D46}\u{11D50}-\u{11D59}\u{12000}-\u{12399}\u{12400}-\u{1246E}\u{12470}-\u{12474}\u{12480}-\u{12543}\u{13000}-\u{1342E}\u{14400}-\u{14646}\u{16800}-\u{16A38}\u{16A40}-\u{16A5E}\u{16A60}-\u{16A69}\u{16A6E}\u{16A6F}\u{16AD0}-\u{16AED}\u{16AF5}\u{16B00}-\u{16B2F}\u{16B37}-\u{16B45}\u{16B50}-\u{16B59}\u{16B5B}-\u{16B61}\u{16B63}-\u{16B77}\u{16B7D}-\u{16B8F}\u{16F00}-\u{16F44}\u{16F50}-\u{16F7E}\u{16F93}-\u{16F9F}\u{16FE0}\u{16FE1}\u{17000}-\u{187EC}\u{18800}-\u{18AF2}\u{1B000}-\u{1B11E}\u{1B170}-\u{1B2FB}\u{1BC00}-\u{1BC6A}\u{1BC70}-\u{1BC7C}\u{1BC80}-\u{1BC88}\u{1BC90}-\u{1BC99}\u{1BC9C}\u{1BC9F}\u{1D000}-\u{1D0F5}\u{1D100}-\u{1D126}\u{1D129}-\u{1D166}\u{1D16A}-\u{1D172}\u{1D183}\u{1D184}\u{1D18C}-\u{1D1A9}\u{1D1AE}-\u{1D1E8}\u{1D360}-\u{1D371}\u{1D400}-\u{1D454}\u{1D456}-\u{1D49C}\u{1D49E}\u{1D49F}\u{1D4A2}\u{1D4A5}\u{1D4A6}\u{1D4A9}-\u{1D4AC}\u{1D4AE}-\u{1D4B9}\u{1D4BB}\u{1D4BD}-\u{1D4C3}\u{1D4C5}-\u{1D505}\u{1D507}-\u{1D50A}\u{1D50D}-\u{1D514}\u{1D516}-\u{1D51C}\u{1D51E}-\u{1D539}\u{1D53B}-\u{1D53E}\u{1D540}-\u{1D544}\u{1D546}\u{1D54A}-\u{1D550}\u{1D552}-\u{1D6A5}\u{1D6A8}-\u{1D6DA}\u{1D6DC}-\u{1D714}\u{1D716}-\u{1D74E}\u{1D750}-\u{1D788}\u{1D78A}-\u{1D7C2}\u{1D7C4}-\u{1D7CB}\u{1D7CE}-\u{1D9FF}\u{1DA37}-\u{1DA3A}\u{1DA6D}-\u{1DA74}\u{1DA76}-\u{1DA83}\u{1DA85}-\u{1DA8B}\u{1F100}-\u{1F10A}\u{1F110}-\u{1F12E}\u{1F130}-\u{1F169}\u{1F170}-\u{1F1AC}\u{1F1E6}-\u{1F202}\u{1F210}-\u{1F23B}\u{1F240}-\u{1F248}\u{1F250}\u{1F251}\u{20000}-\u{2A6D6}\u{2A700}-\u{2B734}\u{2B740}-\u{2B81D}\u{2B820}-\u{2CEA1}\u{2CEB0}-\u{2EBE0}\u{2F800}-\u{2FA1D}\u{F0000}-\u{FFFFD}\u{100000}-\u{10FFFD}][\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09C1-\u09C4\u09CD\u09E2\u09E3\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3F\u0B41-\u0B44\u0B4D\u0B56\u0B62\u0B63\u0B82\u0BC0\u0BCD\u0C00\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CCC\u0CCD\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D41-\u0D44\u0D4D\u0D62\u0D63\u0DCA\u0DD2-\u0DD4\u0DD6\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B03\u1B34\u1B36-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302D\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA8C4\uA8C5\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\u{101FD}\u{102E0}\u{10376}-\u{1037A}\u{10A01}-\u{10A03}\u{10A05}\u{10A06}\u{10A0C}-\u{10A0F}\u{10A38}-\u{10A3A}\u{10A3F}\u{10AE5}\u{10AE6}\u{11001}\u{11038}-\u{11046}\u{1107F}-\u{11081}\u{110B3}-\u{110B6}\u{110B9}\u{110BA}\u{11100}-\u{11102}\u{11127}-\u{1112B}\u{1112D}-\u{11134}\u{11173}\u{11180}\u{11181}\u{111B6}-\u{111BE}\u{111CA}-\u{111CC}\u{1122F}-\u{11231}\u{11234}\u{11236}\u{11237}\u{1123E}\u{112DF}\u{112E3}-\u{112EA}\u{11300}\u{11301}\u{1133C}\u{11340}\u{11366}-\u{1136C}\u{11370}-\u{11374}\u{11438}-\u{1143F}\u{11442}-\u{11444}\u{11446}\u{114B3}-\u{114B8}\u{114BA}\u{114BF}\u{114C0}\u{114C2}\u{114C3}\u{115B2}-\u{115B5}\u{115BC}\u{115BD}\u{115BF}\u{115C0}\u{115DC}\u{115DD}\u{11633}-\u{1163A}\u{1163D}\u{1163F}\u{11640}\u{116AB}\u{116AD}\u{116B0}-\u{116B5}\u{116B7}\u{1171D}-\u{1171F}\u{11722}-\u{11725}\u{11727}-\u{1172B}\u{11A01}-\u{11A06}\u{11A09}\u{11A0A}\u{11A33}-\u{11A38}\u{11A3B}-\u{11A3E}\u{11A47}\u{11A51}-\u{11A56}\u{11A59}-\u{11A5B}\u{11A8A}-\u{11A96}\u{11A98}\u{11A99}\u{11C30}-\u{11C36}\u{11C38}-\u{11C3D}\u{11C92}-\u{11CA7}\u{11CAA}-\u{11CB0}\u{11CB2}\u{11CB3}\u{11CB5}\u{11CB6}\u{11D31}-\u{11D36}\u{11D3A}\u{11D3C}\u{11D3D}\u{11D3F}-\u{11D45}\u{11D47}\u{16AF0}-\u{16AF4}\u{16B30}-\u{16B36}\u{16F8F}-\u{16F92}\u{1BC9D}\u{1BC9E}\u{1D167}-\u{1D169}\u{1D17B}-\u{1D182}\u{1D185}-\u{1D18B}\u{1D1AA}-\u{1D1AD}\u{1D242}-\u{1D244}\u{1DA00}-\u{1DA36}\u{1DA3B}-\u{1DA6C}\u{1DA75}\u{1DA84}\u{1DA9B}-\u{1DA9F}\u{1DAA1}-\u{1DAAF}\u{1E000}-\u{1E006}\u{1E008}-\u{1E018}\u{1E01B}-\u{1E021}\u{1E023}\u{1E024}\u{1E026}-\u{1E02A}\u{1E8D0}-\u{1E8D6}\u{1E944}-\u{1E94A}\u{E0100}-\u{E01EF}]*$/u;
    module.exports = {
      combiningMarks,
      combiningClassVirama,
      validZWNJ,
      bidiDomain,
      bidiS1LTR,
      bidiS1RTL,
      bidiS2,
      bidiS3,
      bidiS4EN,
      bidiS4AN,
      bidiS5,
      bidiS6
    };
  }
});

// node_modules/tr46/lib/mappingTable.json
var require_mappingTable = __commonJS({
  "node_modules/tr46/lib/mappingTable.json"(exports, module) {
    module.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", "a"], [[66, 66], "mapped", "b"], [[67, 67], "mapped", "c"], [[68, 68], "mapped", "d"], [[69, 69], "mapped", "e"], [[70, 70], "mapped", "f"], [[71, 71], "mapped", "g"], [[72, 72], "mapped", "h"], [[73, 73], "mapped", "i"], [[74, 74], "mapped", "j"], [[75, 75], "mapped", "k"], [[76, 76], "mapped", "l"], [[77, 77], "mapped", "m"], [[78, 78], "mapped", "n"], [[79, 79], "mapped", "o"], [[80, 80], "mapped", "p"], [[81, 81], "mapped", "q"], [[82, 82], "mapped", "r"], [[83, 83], "mapped", "s"], [[84, 84], "mapped", "t"], [[85, 85], "mapped", "u"], [[86, 86], "mapped", "v"], [[87, 87], "mapped", "w"], [[88, 88], "mapped", "x"], [[89, 89], "mapped", "y"], [[90, 90], "mapped", "z"], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", " "], [[161, 167], "valid", "", "NV8"], [[168, 168], "disallowed_STD3_mapped", " \u0308"], [[169, 169], "valid", "", "NV8"], [[170, 170], "mapped", "a"], [[171, 172], "valid", "", "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", "", "NV8"], [[175, 175], "disallowed_STD3_mapped", " \u0304"], [[176, 177], "valid", "", "NV8"], [[178, 178], "mapped", "2"], [[179, 179], "mapped", "3"], [[180, 180], "disallowed_STD3_mapped", " \u0301"], [[181, 181], "mapped", "\u03BC"], [[182, 182], "valid", "", "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", " \u0327"], [[185, 185], "mapped", "1"], [[186, 186], "mapped", "o"], [[187, 187], "valid", "", "NV8"], [[188, 188], "mapped", "1\u20444"], [[189, 189], "mapped", "1\u20442"], [[190, 190], "mapped", "3\u20444"], [[191, 191], "valid", "", "NV8"], [[192, 192], "mapped", "\xE0"], [[193, 193], "mapped", "\xE1"], [[194, 194], "mapped", "\xE2"], [[195, 195], "mapped", "\xE3"], [[196, 196], "mapped", "\xE4"], [[197, 197], "mapped", "\xE5"], [[198, 198], "mapped", "\xE6"], [[199, 199], "mapped", "\xE7"], [[200, 200], "mapped", "\xE8"], [[201, 201], "mapped", "\xE9"], [[202, 202], "mapped", "\xEA"], [[203, 203], "mapped", "\xEB"], [[204, 204], "mapped", "\xEC"], [[205, 205], "mapped", "\xED"], [[206, 206], "mapped", "\xEE"], [[207, 207], "mapped", "\xEF"], [[208, 208], "mapped", "\xF0"], [[209, 209], "mapped", "\xF1"], [[210, 210], "mapped", "\xF2"], [[211, 211], "mapped", "\xF3"], [[212, 212], "mapped", "\xF4"], [[213, 213], "mapped", "\xF5"], [[214, 214], "mapped", "\xF6"], [[215, 215], "valid", "", "NV8"], [[216, 216], "mapped", "\xF8"], [[217, 217], "mapped", "\xF9"], [[218, 218], "mapped", "\xFA"], [[219, 219], "mapped", "\xFB"], [[220, 220], "mapped", "\xFC"], [[221, 221], "mapped", "\xFD"], [[222, 222], "mapped", "\xFE"], [[223, 223], "deviation", "ss"], [[224, 246], "valid"], [[247, 247], "valid", "", "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", "\u0101"], [[257, 257], "valid"], [[258, 258], "mapped", "\u0103"], [[259, 259], "valid"], [[260, 260], "mapped", "\u0105"], [[261, 261], "valid"], [[262, 262], "mapped", "\u0107"], [[263, 263], "valid"], [[264, 264], "mapped", "\u0109"], [[265, 265], "valid"], [[266, 266], "mapped", "\u010B"], [[267, 267], "valid"], [[268, 268], "mapped", "\u010D"], [[269, 269], "valid"], [[270, 270], "mapped", "\u010F"], [[271, 271], "valid"], [[272, 272], "mapped", "\u0111"], [[273, 273], "valid"], [[274, 274], "mapped", "\u0113"], [[275, 275], "valid"], [[276, 276], "mapped", "\u0115"], [[277, 277], "valid"], [[278, 278], "mapped", "\u0117"], [[279, 279], "valid"], [[280, 280], "mapped", "\u0119"], [[281, 281], "valid"], [[282, 282], "mapped", "\u011B"], [[283, 283], "valid"], [[284, 284], "mapped", "\u011D"], [[285, 285], "valid"], [[286, 286], "mapped", "\u011F"], [[287, 287], "valid"], [[288, 288], "mapped", "\u0121"], [[289, 289], "valid"], [[290, 290], "mapped", "\u0123"], [[291, 291], "valid"], [[292, 292], "mapped", "\u0125"], [[293, 293], "valid"], [[294, 294], "mapped", "\u0127"], [[295, 295], "valid"], [[296, 296], "mapped", "\u0129"], [[297, 297], "valid"], [[298, 298], "mapped", "\u012B"], [[299, 299], "valid"], [[300, 300], "mapped", "\u012D"], [[301, 301], "valid"], [[302, 302], "mapped", "\u012F"], [[303, 303], "valid"], [[304, 304], "mapped", "i\u0307"], [[305, 305], "valid"], [[306, 307], "mapped", "ij"], [[308, 308], "mapped", "\u0135"], [[309, 309], "valid"], [[310, 310], "mapped", "\u0137"], [[311, 312], "valid"], [[313, 313], "mapped", "\u013A"], [[314, 314], "valid"], [[315, 315], "mapped", "\u013C"], [[316, 316], "valid"], [[317, 317], "mapped", "\u013E"], [[318, 318], "valid"], [[319, 320], "mapped", "l\xB7"], [[321, 321], "mapped", "\u0142"], [[322, 322], "valid"], [[323, 323], "mapped", "\u0144"], [[324, 324], "valid"], [[325, 325], "mapped", "\u0146"], [[326, 326], "valid"], [[327, 327], "mapped", "\u0148"], [[328, 328], "valid"], [[329, 329], "mapped", "\u02BCn"], [[330, 330], "mapped", "\u014B"], [[331, 331], "valid"], [[332, 332], "mapped", "\u014D"], [[333, 333], "valid"], [[334, 334], "mapped", "\u014F"], [[335, 335], "valid"], [[336, 336], "mapped", "\u0151"], [[337, 337], "valid"], [[338, 338], "mapped", "\u0153"], [[339, 339], "valid"], [[340, 340], "mapped", "\u0155"], [[341, 341], "valid"], [[342, 342], "mapped", "\u0157"], [[343, 343], "valid"], [[344, 344], "mapped", "\u0159"], [[345, 345], "valid"], [[346, 346], "mapped", "\u015B"], [[347, 347], "valid"], [[348, 348], "mapped", "\u015D"], [[349, 349], "valid"], [[350, 350], "mapped", "\u015F"], [[351, 351], "valid"], [[352, 352], "mapped", "\u0161"], [[353, 353], "valid"], [[354, 354], "mapped", "\u0163"], [[355, 355], "valid"], [[356, 356], "mapped", "\u0165"], [[357, 357], "valid"], [[358, 358], "mapped", "\u0167"], [[359, 359], "valid"], [[360, 360], "mapped", "\u0169"], [[361, 361], "valid"], [[362, 362], "mapped", "\u016B"], [[363, 363], "valid"], [[364, 364], "mapped", "\u016D"], [[365, 365], "valid"], [[366, 366], "mapped", "\u016F"], [[367, 367], "valid"], [[368, 368], "mapped", "\u0171"], [[369, 369], "valid"], [[370, 370], "mapped", "\u0173"], [[371, 371], "valid"], [[372, 372], "mapped", "\u0175"], [[373, 373], "valid"], [[374, 374], "mapped", "\u0177"], [[375, 375], "valid"], [[376, 376], "mapped", "\xFF"], [[377, 377], "mapped", "\u017A"], [[378, 378], "valid"], [[379, 379], "mapped", "\u017C"], [[380, 380], "valid"], [[381, 381], "mapped", "\u017E"], [[382, 382], "valid"], [[383, 383], "mapped", "s"], [[384, 384], "valid"], [[385, 385], "mapped", "\u0253"], [[386, 386], "mapped", "\u0183"], [[387, 387], "valid"], [[388, 388], "mapped", "\u0185"], [[389, 389], "valid"], [[390, 390], "mapped", "\u0254"], [[391, 391], "mapped", "\u0188"], [[392, 392], "valid"], [[393, 393], "mapped", "\u0256"], [[394, 394], "mapped", "\u0257"], [[395, 395], "mapped", "\u018C"], [[396, 397], "valid"], [[398, 398], "mapped", "\u01DD"], [[399, 399], "mapped", "\u0259"], [[400, 400], "mapped", "\u025B"], [[401, 401], "mapped", "\u0192"], [[402, 402], "valid"], [[403, 403], "mapped", "\u0260"], [[404, 404], "mapped", "\u0263"], [[405, 405], "valid"], [[406, 406], "mapped", "\u0269"], [[407, 407], "mapped", "\u0268"], [[408, 408], "mapped", "\u0199"], [[409, 411], "valid"], [[412, 412], "mapped", "\u026F"], [[413, 413], "mapped", "\u0272"], [[414, 414], "valid"], [[415, 415], "mapped", "\u0275"], [[416, 416], "mapped", "\u01A1"], [[417, 417], "valid"], [[418, 418], "mapped", "\u01A3"], [[419, 419], "valid"], [[420, 420], "mapped", "\u01A5"], [[421, 421], "valid"], [[422, 422], "mapped", "\u0280"], [[423, 423], "mapped", "\u01A8"], [[424, 424], "valid"], [[425, 425], "mapped", "\u0283"], [[426, 427], "valid"], [[428, 428], "mapped", "\u01AD"], [[429, 429], "valid"], [[430, 430], "mapped", "\u0288"], [[431, 431], "mapped", "\u01B0"], [[432, 432], "valid"], [[433, 433], "mapped", "\u028A"], [[434, 434], "mapped", "\u028B"], [[435, 435], "mapped", "\u01B4"], [[436, 436], "valid"], [[437, 437], "mapped", "\u01B6"], [[438, 438], "valid"], [[439, 439], "mapped", "\u0292"], [[440, 440], "mapped", "\u01B9"], [[441, 443], "valid"], [[444, 444], "mapped", "\u01BD"], [[445, 451], "valid"], [[452, 454], "mapped", "d\u017E"], [[455, 457], "mapped", "lj"], [[458, 460], "mapped", "nj"], [[461, 461], "mapped", "\u01CE"], [[462, 462], "valid"], [[463, 463], "mapped", "\u01D0"], [[464, 464], "valid"], [[465, 465], "mapped", "\u01D2"], [[466, 466], "valid"], [[467, 467], "mapped", "\u01D4"], [[468, 468], "valid"], [[469, 469], "mapped", "\u01D6"], [[470, 470], "valid"], [[471, 471], "mapped", "\u01D8"], [[472, 472], "valid"], [[473, 473], "mapped", "\u01DA"], [[474, 474], "valid"], [[475, 475], "mapped", "\u01DC"], [[476, 477], "valid"], [[478, 478], "mapped", "\u01DF"], [[479, 479], "valid"], [[480, 480], "mapped", "\u01E1"], [[481, 481], "valid"], [[482, 482], "mapped", "\u01E3"], [[483, 483], "valid"], [[484, 484], "mapped", "\u01E5"], [[485, 485], "valid"], [[486, 486], "mapped", "\u01E7"], [[487, 487], "valid"], [[488, 488], "mapped", "\u01E9"], [[489, 489], "valid"], [[490, 490], "mapped", "\u01EB"], [[491, 491], "valid"], [[492, 492], "mapped", "\u01ED"], [[493, 493], "valid"], [[494, 494], "mapped", "\u01EF"], [[495, 496], "valid"], [[497, 499], "mapped", "dz"], [[500, 500], "mapped", "\u01F5"], [[501, 501], "valid"], [[502, 502], "mapped", "\u0195"], [[503, 503], "mapped", "\u01BF"], [[504, 504], "mapped", "\u01F9"], [[505, 505], "valid"], [[506, 506], "mapped", "\u01FB"], [[507, 507], "valid"], [[508, 508], "mapped", "\u01FD"], [[509, 509], "valid"], [[510, 510], "mapped", "\u01FF"], [[511, 511], "valid"], [[512, 512], "mapped", "\u0201"], [[513, 513], "valid"], [[514, 514], "mapped", "\u0203"], [[515, 515], "valid"], [[516, 516], "mapped", "\u0205"], [[517, 517], "valid"], [[518, 518], "mapped", "\u0207"], [[519, 519], "valid"], [[520, 520], "mapped", "\u0209"], [[521, 521], "valid"], [[522, 522], "mapped", "\u020B"], [[523, 523], "valid"], [[524, 524], "mapped", "\u020D"], [[525, 525], "valid"], [[526, 526], "mapped", "\u020F"], [[527, 527], "valid"], [[528, 528], "mapped", "\u0211"], [[529, 529], "valid"], [[530, 530], "mapped", "\u0213"], [[531, 531], "valid"], [[532, 532], "mapped", "\u0215"], [[533, 533], "valid"], [[534, 534], "mapped", "\u0217"], [[535, 535], "valid"], [[536, 536], "mapped", "\u0219"], [[537, 537], "valid"], [[538, 538], "mapped", "\u021B"], [[539, 539], "valid"], [[540, 540], "mapped", "\u021D"], [[541, 541], "valid"], [[542, 542], "mapped", "\u021F"], [[543, 543], "valid"], [[544, 544], "mapped", "\u019E"], [[545, 545], "valid"], [[546, 546], "mapped", "\u0223"], [[547, 547], "valid"], [[548, 548], "mapped", "\u0225"], [[549, 549], "valid"], [[550, 550], "mapped", "\u0227"], [[551, 551], "valid"], [[552, 552], "mapped", "\u0229"], [[553, 553], "valid"], [[554, 554], "mapped", "\u022B"], [[555, 555], "valid"], [[556, 556], "mapped", "\u022D"], [[557, 557], "valid"], [[558, 558], "mapped", "\u022F"], [[559, 559], "valid"], [[560, 560], "mapped", "\u0231"], [[561, 561], "valid"], [[562, 562], "mapped", "\u0233"], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", "\u2C65"], [[571, 571], "mapped", "\u023C"], [[572, 572], "valid"], [[573, 573], "mapped", "\u019A"], [[574, 574], "mapped", "\u2C66"], [[575, 576], "valid"], [[577, 577], "mapped", "\u0242"], [[578, 578], "valid"], [[579, 579], "mapped", "\u0180"], [[580, 580], "mapped", "\u0289"], [[581, 581], "mapped", "\u028C"], [[582, 582], "mapped", "\u0247"], [[583, 583], "valid"], [[584, 584], "mapped", "\u0249"], [[585, 585], "valid"], [[586, 586], "mapped", "\u024B"], [[587, 587], "valid"], [[588, 588], "mapped", "\u024D"], [[589, 589], "valid"], [[590, 590], "mapped", "\u024F"], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", "h"], [[689, 689], "mapped", "\u0266"], [[690, 690], "mapped", "j"], [[691, 691], "mapped", "r"], [[692, 692], "mapped", "\u0279"], [[693, 693], "mapped", "\u027B"], [[694, 694], "mapped", "\u0281"], [[695, 695], "mapped", "w"], [[696, 696], "mapped", "y"], [[697, 705], "valid"], [[706, 709], "valid", "", "NV8"], [[710, 721], "valid"], [[722, 727], "valid", "", "NV8"], [[728, 728], "disallowed_STD3_mapped", " \u0306"], [[729, 729], "disallowed_STD3_mapped", " \u0307"], [[730, 730], "disallowed_STD3_mapped", " \u030A"], [[731, 731], "disallowed_STD3_mapped", " \u0328"], [[732, 732], "disallowed_STD3_mapped", " \u0303"], [[733, 733], "disallowed_STD3_mapped", " \u030B"], [[734, 734], "valid", "", "NV8"], [[735, 735], "valid", "", "NV8"], [[736, 736], "mapped", "\u0263"], [[737, 737], "mapped", "l"], [[738, 738], "mapped", "s"], [[739, 739], "mapped", "x"], [[740, 740], "mapped", "\u0295"], [[741, 745], "valid", "", "NV8"], [[746, 747], "valid", "", "NV8"], [[748, 748], "valid"], [[749, 749], "valid", "", "NV8"], [[750, 750], "valid"], [[751, 767], "valid", "", "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", "\u0300"], [[833, 833], "mapped", "\u0301"], [[834, 834], "valid"], [[835, 835], "mapped", "\u0313"], [[836, 836], "mapped", "\u0308\u0301"], [[837, 837], "mapped", "\u03B9"], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", "\u0371"], [[881, 881], "valid"], [[882, 882], "mapped", "\u0373"], [[883, 883], "valid"], [[884, 884], "mapped", "\u02B9"], [[885, 885], "valid"], [[886, 886], "mapped", "\u0377"], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", " \u03B9"], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", ";"], [[895, 895], "mapped", "\u03F3"], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", " \u0301"], [[901, 901], "disallowed_STD3_mapped", " \u0308\u0301"], [[902, 902], "mapped", "\u03AC"], [[903, 903], "mapped", "\xB7"], [[904, 904], "mapped", "\u03AD"], [[905, 905], "mapped", "\u03AE"], [[906, 906], "mapped", "\u03AF"], [[907, 907], "disallowed"], [[908, 908], "mapped", "\u03CC"], [[909, 909], "disallowed"], [[910, 910], "mapped", "\u03CD"], [[911, 911], "mapped", "\u03CE"], [[912, 912], "valid"], [[913, 913], "mapped", "\u03B1"], [[914, 914], "mapped", "\u03B2"], [[915, 915], "mapped", "\u03B3"], [[916, 916], "mapped", "\u03B4"], [[917, 917], "mapped", "\u03B5"], [[918, 918], "mapped", "\u03B6"], [[919, 919], "mapped", "\u03B7"], [[920, 920], "mapped", "\u03B8"], [[921, 921], "mapped", "\u03B9"], [[922, 922], "mapped", "\u03BA"], [[923, 923], "mapped", "\u03BB"], [[924, 924], "mapped", "\u03BC"], [[925, 925], "mapped", "\u03BD"], [[926, 926], "mapped", "\u03BE"], [[927, 927], "mapped", "\u03BF"], [[928, 928], "mapped", "\u03C0"], [[929, 929], "mapped", "\u03C1"], [[930, 930], "disallowed"], [[931, 931], "mapped", "\u03C3"], [[932, 932], "mapped", "\u03C4"], [[933, 933], "mapped", "\u03C5"], [[934, 934], "mapped", "\u03C6"], [[935, 935], "mapped", "\u03C7"], [[936, 936], "mapped", "\u03C8"], [[937, 937], "mapped", "\u03C9"], [[938, 938], "mapped", "\u03CA"], [[939, 939], "mapped", "\u03CB"], [[940, 961], "valid"], [[962, 962], "deviation", "\u03C3"], [[963, 974], "valid"], [[975, 975], "mapped", "\u03D7"], [[976, 976], "mapped", "\u03B2"], [[977, 977], "mapped", "\u03B8"], [[978, 978], "mapped", "\u03C5"], [[979, 979], "mapped", "\u03CD"], [[980, 980], "mapped", "\u03CB"], [[981, 981], "mapped", "\u03C6"], [[982, 982], "mapped", "\u03C0"], [[983, 983], "valid"], [[984, 984], "mapped", "\u03D9"], [[985, 985], "valid"], [[986, 986], "mapped", "\u03DB"], [[987, 987], "valid"], [[988, 988], "mapped", "\u03DD"], [[989, 989], "valid"], [[990, 990], "mapped", "\u03DF"], [[991, 991], "valid"], [[992, 992], "mapped", "\u03E1"], [[993, 993], "valid"], [[994, 994], "mapped", "\u03E3"], [[995, 995], "valid"], [[996, 996], "mapped", "\u03E5"], [[997, 997], "valid"], [[998, 998], "mapped", "\u03E7"], [[999, 999], "valid"], [[1e3, 1e3], "mapped", "\u03E9"], [[1001, 1001], "valid"], [[1002, 1002], "mapped", "\u03EB"], [[1003, 1003], "valid"], [[1004, 1004], "mapped", "\u03ED"], [[1005, 1005], "valid"], [[1006, 1006], "mapped", "\u03EF"], [[1007, 1007], "valid"], [[1008, 1008], "mapped", "\u03BA"], [[1009, 1009], "mapped", "\u03C1"], [[1010, 1010], "mapped", "\u03C3"], [[1011, 1011], "valid"], [[1012, 1012], "mapped", "\u03B8"], [[1013, 1013], "mapped", "\u03B5"], [[1014, 1014], "valid", "", "NV8"], [[1015, 1015], "mapped", "\u03F8"], [[1016, 1016], "valid"], [[1017, 1017], "mapped", "\u03C3"], [[1018, 1018], "mapped", "\u03FB"], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", "\u037B"], [[1022, 1022], "mapped", "\u037C"], [[1023, 1023], "mapped", "\u037D"], [[1024, 1024], "mapped", "\u0450"], [[1025, 1025], "mapped", "\u0451"], [[1026, 1026], "mapped", "\u0452"], [[1027, 1027], "mapped", "\u0453"], [[1028, 1028], "mapped", "\u0454"], [[1029, 1029], "mapped", "\u0455"], [[1030, 1030], "mapped", "\u0456"], [[1031, 1031], "mapped", "\u0457"], [[1032, 1032], "mapped", "\u0458"], [[1033, 1033], "mapped", "\u0459"], [[1034, 1034], "mapped", "\u045A"], [[1035, 1035], "mapped", "\u045B"], [[1036, 1036], "mapped", "\u045C"], [[1037, 1037], "mapped", "\u045D"], [[1038, 1038], "mapped", "\u045E"], [[1039, 1039], "mapped", "\u045F"], [[1040, 1040], "mapped", "\u0430"], [[1041, 1041], "mapped", "\u0431"], [[1042, 1042], "mapped", "\u0432"], [[1043, 1043], "mapped", "\u0433"], [[1044, 1044], "mapped", "\u0434"], [[1045, 1045], "mapped", "\u0435"], [[1046, 1046], "mapped", "\u0436"], [[1047, 1047], "mapped", "\u0437"], [[1048, 1048], "mapped", "\u0438"], [[1049, 1049], "mapped", "\u0439"], [[1050, 1050], "mapped", "\u043A"], [[1051, 1051], "mapped", "\u043B"], [[1052, 1052], "mapped", "\u043C"], [[1053, 1053], "mapped", "\u043D"], [[1054, 1054], "mapped", "\u043E"], [[1055, 1055], "mapped", "\u043F"], [[1056, 1056], "mapped", "\u0440"], [[1057, 1057], "mapped", "\u0441"], [[1058, 1058], "mapped", "\u0442"], [[1059, 1059], "mapped", "\u0443"], [[1060, 1060], "mapped", "\u0444"], [[1061, 1061], "mapped", "\u0445"], [[1062, 1062], "mapped", "\u0446"], [[1063, 1063], "mapped", "\u0447"], [[1064, 1064], "mapped", "\u0448"], [[1065, 1065], "mapped", "\u0449"], [[1066, 1066], "mapped", "\u044A"], [[1067, 1067], "mapped", "\u044B"], [[1068, 1068], "mapped", "\u044C"], [[1069, 1069], "mapped", "\u044D"], [[1070, 1070], "mapped", "\u044E"], [[1071, 1071], "mapped", "\u044F"], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", "\u0461"], [[1121, 1121], "valid"], [[1122, 1122], "mapped", "\u0463"], [[1123, 1123], "valid"], [[1124, 1124], "mapped", "\u0465"], [[1125, 1125], "valid"], [[1126, 1126], "mapped", "\u0467"], [[1127, 1127], "valid"], [[1128, 1128], "mapped", "\u0469"], [[1129, 1129], "valid"], [[1130, 1130], "mapped", "\u046B"], [[1131, 1131], "valid"], [[1132, 1132], "mapped", "\u046D"], [[1133, 1133], "valid"], [[1134, 1134], "mapped", "\u046F"], [[1135, 1135], "valid"], [[1136, 1136], "mapped", "\u0471"], [[1137, 1137], "valid"], [[1138, 1138], "mapped", "\u0473"], [[1139, 1139], "valid"], [[1140, 1140], "mapped", "\u0475"], [[1141, 1141], "valid"], [[1142, 1142], "mapped", "\u0477"], [[1143, 1143], "valid"], [[1144, 1144], "mapped", "\u0479"], [[1145, 1145], "valid"], [[1146, 1146], "mapped", "\u047B"], [[1147, 1147], "valid"], [[1148, 1148], "mapped", "\u047D"], [[1149, 1149], "valid"], [[1150, 1150], "mapped", "\u047F"], [[1151, 1151], "valid"], [[1152, 1152], "mapped", "\u0481"], [[1153, 1153], "valid"], [[1154, 1154], "valid", "", "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", "", "NV8"], [[1162, 1162], "mapped", "\u048B"], [[1163, 1163], "valid"], [[1164, 1164], "mapped", "\u048D"], [[1165, 1165], "valid"], [[1166, 1166], "mapped", "\u048F"], [[1167, 1167], "valid"], [[1168, 1168], "mapped", "\u0491"], [[1169, 1169], "valid"], [[1170, 1170], "mapped", "\u0493"], [[1171, 1171], "valid"], [[1172, 1172], "mapped", "\u0495"], [[1173, 1173], "valid"], [[1174, 1174], "mapped", "\u0497"], [[1175, 1175], "valid"], [[1176, 1176], "mapped", "\u0499"], [[1177, 1177], "valid"], [[1178, 1178], "mapped", "\u049B"], [[1179, 1179], "valid"], [[1180, 1180], "mapped", "\u049D"], [[1181, 1181], "valid"], [[1182, 1182], "mapped", "\u049F"], [[1183, 1183], "valid"], [[1184, 1184], "mapped", "\u04A1"], [[1185, 1185], "valid"], [[1186, 1186], "mapped", "\u04A3"], [[1187, 1187], "valid"], [[1188, 1188], "mapped", "\u04A5"], [[1189, 1189], "valid"], [[1190, 1190], "mapped", "\u04A7"], [[1191, 1191], "valid"], [[1192, 1192], "mapped", "\u04A9"], [[1193, 1193], "valid"], [[1194, 1194], "mapped", "\u04AB"], [[1195, 1195], "valid"], [[1196, 1196], "mapped", "\u04AD"], [[1197, 1197], "valid"], [[1198, 1198], "mapped", "\u04AF"], [[1199, 1199], "valid"], [[1200, 1200], "mapped", "\u04B1"], [[1201, 1201], "valid"], [[1202, 1202], "mapped", "\u04B3"], [[1203, 1203], "valid"], [[1204, 1204], "mapped", "\u04B5"], [[1205, 1205], "valid"], [[1206, 1206], "mapped", "\u04B7"], [[1207, 1207], "valid"], [[1208, 1208], "mapped", "\u04B9"], [[1209, 1209], "valid"], [[1210, 1210], "mapped", "\u04BB"], [[1211, 1211], "valid"], [[1212, 1212], "mapped", "\u04BD"], [[1213, 1213], "valid"], [[1214, 1214], "mapped", "\u04BF"], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", "\u04C2"], [[1218, 1218], "valid"], [[1219, 1219], "mapped", "\u04C4"], [[1220, 1220], "valid"], [[1221, 1221], "mapped", "\u04C6"], [[1222, 1222], "valid"], [[1223, 1223], "mapped", "\u04C8"], [[1224, 1224], "valid"], [[1225, 1225], "mapped", "\u04CA"], [[1226, 1226], "valid"], [[1227, 1227], "mapped", "\u04CC"], [[1228, 1228], "valid"], [[1229, 1229], "mapped", "\u04CE"], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", "\u04D1"], [[1233, 1233], "valid"], [[1234, 1234], "mapped", "\u04D3"], [[1235, 1235], "valid"], [[1236, 1236], "mapped", "\u04D5"], [[1237, 1237], "valid"], [[1238, 1238], "mapped", "\u04D7"], [[1239, 1239], "valid"], [[1240, 1240], "mapped", "\u04D9"], [[1241, 1241], "valid"], [[1242, 1242], "mapped", "\u04DB"], [[1243, 1243], "valid"], [[1244, 1244], "mapped", "\u04DD"], [[1245, 1245], "valid"], [[1246, 1246], "mapped", "\u04DF"], [[1247, 1247], "valid"], [[1248, 1248], "mapped", "\u04E1"], [[1249, 1249], "valid"], [[1250, 1250], "mapped", "\u04E3"], [[1251, 1251], "valid"], [[1252, 1252], "mapped", "\u04E5"], [[1253, 1253], "valid"], [[1254, 1254], "mapped", "\u04E7"], [[1255, 1255], "valid"], [[1256, 1256], "mapped", "\u04E9"], [[1257, 1257], "valid"], [[1258, 1258], "mapped", "\u04EB"], [[1259, 1259], "valid"], [[1260, 1260], "mapped", "\u04ED"], [[1261, 1261], "valid"], [[1262, 1262], "mapped", "\u04EF"], [[1263, 1263], "valid"], [[1264, 1264], "mapped", "\u04F1"], [[1265, 1265], "valid"], [[1266, 1266], "mapped", "\u04F3"], [[1267, 1267], "valid"], [[1268, 1268], "mapped", "\u04F5"], [[1269, 1269], "valid"], [[1270, 1270], "mapped", "\u04F7"], [[1271, 1271], "valid"], [[1272, 1272], "mapped", "\u04F9"], [[1273, 1273], "valid"], [[1274, 1274], "mapped", "\u04FB"], [[1275, 1275], "valid"], [[1276, 1276], "mapped", "\u04FD"], [[1277, 1277], "valid"], [[1278, 1278], "mapped", "\u04FF"], [[1279, 1279], "valid"], [[1280, 1280], "mapped", "\u0501"], [[1281, 1281], "valid"], [[1282, 1282], "mapped", "\u0503"], [[1283, 1283], "valid"], [[1284, 1284], "mapped", "\u0505"], [[1285, 1285], "valid"], [[1286, 1286], "mapped", "\u0507"], [[1287, 1287], "valid"], [[1288, 1288], "mapped", "\u0509"], [[1289, 1289], "valid"], [[1290, 1290], "mapped", "\u050B"], [[1291, 1291], "valid"], [[1292, 1292], "mapped", "\u050D"], [[1293, 1293], "valid"], [[1294, 1294], "mapped", "\u050F"], [[1295, 1295], "valid"], [[1296, 1296], "mapped", "\u0511"], [[1297, 1297], "valid"], [[1298, 1298], "mapped", "\u0513"], [[1299, 1299], "valid"], [[1300, 1300], "mapped", "\u0515"], [[1301, 1301], "valid"], [[1302, 1302], "mapped", "\u0517"], [[1303, 1303], "valid"], [[1304, 1304], "mapped", "\u0519"], [[1305, 1305], "valid"], [[1306, 1306], "mapped", "\u051B"], [[1307, 1307], "valid"], [[1308, 1308], "mapped", "\u051D"], [[1309, 1309], "valid"], [[1310, 1310], "mapped", "\u051F"], [[1311, 1311], "valid"], [[1312, 1312], "mapped", "\u0521"], [[1313, 1313], "valid"], [[1314, 1314], "mapped", "\u0523"], [[1315, 1315], "valid"], [[1316, 1316], "mapped", "\u0525"], [[1317, 1317], "valid"], [[1318, 1318], "mapped", "\u0527"], [[1319, 1319], "valid"], [[1320, 1320], "mapped", "\u0529"], [[1321, 1321], "valid"], [[1322, 1322], "mapped", "\u052B"], [[1323, 1323], "valid"], [[1324, 1324], "mapped", "\u052D"], [[1325, 1325], "valid"], [[1326, 1326], "mapped", "\u052F"], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", "\u0561"], [[1330, 1330], "mapped", "\u0562"], [[1331, 1331], "mapped", "\u0563"], [[1332, 1332], "mapped", "\u0564"], [[1333, 1333], "mapped", "\u0565"], [[1334, 1334], "mapped", "\u0566"], [[1335, 1335], "mapped", "\u0567"], [[1336, 1336], "mapped", "\u0568"], [[1337, 1337], "mapped", "\u0569"], [[1338, 1338], "mapped", "\u056A"], [[1339, 1339], "mapped", "\u056B"], [[1340, 1340], "mapped", "\u056C"], [[1341, 1341], "mapped", "\u056D"], [[1342, 1342], "mapped", "\u056E"], [[1343, 1343], "mapped", "\u056F"], [[1344, 1344], "mapped", "\u0570"], [[1345, 1345], "mapped", "\u0571"], [[1346, 1346], "mapped", "\u0572"], [[1347, 1347], "mapped", "\u0573"], [[1348, 1348], "mapped", "\u0574"], [[1349, 1349], "mapped", "\u0575"], [[1350, 1350], "mapped", "\u0576"], [[1351, 1351], "mapped", "\u0577"], [[1352, 1352], "mapped", "\u0578"], [[1353, 1353], "mapped", "\u0579"], [[1354, 1354], "mapped", "\u057A"], [[1355, 1355], "mapped", "\u057B"], [[1356, 1356], "mapped", "\u057C"], [[1357, 1357], "mapped", "\u057D"], [[1358, 1358], "mapped", "\u057E"], [[1359, 1359], "mapped", "\u057F"], [[1360, 1360], "mapped", "\u0580"], [[1361, 1361], "mapped", "\u0581"], [[1362, 1362], "mapped", "\u0582"], [[1363, 1363], "mapped", "\u0583"], [[1364, 1364], "mapped", "\u0584"], [[1365, 1365], "mapped", "\u0585"], [[1366, 1366], "mapped", "\u0586"], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", "", "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", "\u0565\u0582"], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", "", "NV8"], [[1418, 1418], "valid", "", "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", "", "NV8"], [[1423, 1423], "valid", "", "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", "", "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", "", "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", "", "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", "", "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", "", "NV8"], [[1547, 1547], "valid", "", "NV8"], [[1548, 1548], "valid", "", "NV8"], [[1549, 1551], "valid", "", "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", "", "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", "", "NV8"], [[1567, 1567], "valid", "", "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", "", "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", "", "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", "\u0627\u0674"], [[1654, 1654], "mapped", "\u0648\u0674"], [[1655, 1655], "mapped", "\u06C7\u0674"], [[1656, 1656], "mapped", "\u064A\u0674"], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", "", "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", "", "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", "", "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", "", "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", "", "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", "", "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", "", "NV8"], [[2143, 2143], "disallowed"], [[2144, 2154], "valid"], [[2155, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2229], "disallowed"], [[2230, 2237], "valid"], [[2238, 2259], "disallowed"], [[2260, 2273], "valid"], [[2274, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", "\u0915\u093C"], [[2393, 2393], "mapped", "\u0916\u093C"], [[2394, 2394], "mapped", "\u0917\u093C"], [[2395, 2395], "mapped", "\u091C\u093C"], [[2396, 2396], "mapped", "\u0921\u093C"], [[2397, 2397], "mapped", "\u0922\u093C"], [[2398, 2398], "mapped", "\u092B\u093C"], [[2399, 2399], "mapped", "\u092F\u093C"], [[2400, 2403], "valid"], [[2404, 2405], "valid", "", "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", "", "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", "\u09A1\u09BC"], [[2525, 2525], "mapped", "\u09A2\u09BC"], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", "\u09AF\u09BC"], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", "", "NV8"], [[2555, 2555], "valid", "", "NV8"], [[2556, 2556], "valid"], [[2557, 2557], "valid", "", "NV8"], [[2558, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", "\u0A32\u0A3C"], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", "\u0A38\u0A3C"], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", "\u0A16\u0A3C"], [[2650, 2650], "mapped", "\u0A17\u0A3C"], [[2651, 2651], "mapped", "\u0A1C\u0A3C"], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", "\u0A2B\u0A3C"], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", "", "NV8"], [[2801, 2801], "valid", "", "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2815], "valid"], [[2816, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", "\u0B21\u0B3C"], [[2909, 2909], "mapped", "\u0B22\u0B3C"], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", "", "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", "", "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", "", "NV8"], [[3059, 3066], "valid", "", "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", "", "NV8"], [[3200, 3200], "valid"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3327], "disallowed"], [[3328, 3328], "valid"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "valid"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3407], "valid", "", "NV8"], [[3408, 3411], "disallowed"], [[3412, 3414], "valid"], [[3415, 3415], "valid"], [[3416, 3422], "valid", "", "NV8"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", "", "NV8"], [[3446, 3448], "valid", "", "NV8"], [[3449, 3449], "valid", "", "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", "", "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", "\u0E4D\u0E32"], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", "", "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", "", "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", "", "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", "\u0ECD\u0EB2"], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", "\u0EAB\u0E99"], [[3805, 3805], "mapped", "\u0EAB\u0EA1"], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", "", "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", "\u0F0B"], [[3853, 3863], "valid", "", "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", "", "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", "", "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", "", "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", "", "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", "", "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", "\u0F42\u0FB7"], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", "\u0F4C\u0FB7"], [[3918, 3921], "valid"], [[3922, 3922], "mapped", "\u0F51\u0FB7"], [[3923, 3926], "valid"], [[3927, 3927], "mapped", "\u0F56\u0FB7"], [[3928, 3931], "valid"], [[3932, 3932], "mapped", "\u0F5B\u0FB7"], [[3933, 3944], "valid"], [[3945, 3945], "mapped", "\u0F40\u0FB5"], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", "\u0F71\u0F72"], [[3956, 3956], "valid"], [[3957, 3957], "mapped", "\u0F71\u0F74"], [[3958, 3958], "mapped", "\u0FB2\u0F80"], [[3959, 3959], "mapped", "\u0FB2\u0F71\u0F80"], [[3960, 3960], "mapped", "\u0FB3\u0F80"], [[3961, 3961], "mapped", "\u0FB3\u0F71\u0F80"], [[3962, 3968], "valid"], [[3969, 3969], "mapped", "\u0F71\u0F80"], [[3970, 3972], "valid"], [[3973, 3973], "valid", "", "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", "\u0F92\u0FB7"], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", "\u0F9C\u0FB7"], [[3998, 4001], "valid"], [[4002, 4002], "mapped", "\u0FA1\u0FB7"], [[4003, 4006], "valid"], [[4007, 4007], "mapped", "\u0FA6\u0FB7"], [[4008, 4011], "valid"], [[4012, 4012], "mapped", "\u0FAB\u0FB7"], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", "\u0F90\u0FB5"], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", "", "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", "", "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", "", "NV8"], [[4047, 4047], "valid", "", "NV8"], [[4048, 4049], "valid", "", "NV8"], [[4050, 4052], "valid", "", "NV8"], [[4053, 4056], "valid", "", "NV8"], [[4057, 4058], "valid", "", "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", "", "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", "", "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", "\u2D27"], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", "\u2D2D"], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", "", "NV8"], [[4348, 4348], "mapped", "\u10DC"], [[4349, 4351], "valid"], [[4352, 4441], "valid", "", "NV8"], [[4442, 4446], "valid", "", "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", "", "NV8"], [[4515, 4519], "valid", "", "NV8"], [[4520, 4601], "valid", "", "NV8"], [[4602, 4607], "valid", "", "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", "", "NV8"], [[4961, 4988], "valid", "", "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", "", "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", "\u13F0"], [[5113, 5113], "mapped", "\u13F1"], [[5114, 5114], "mapped", "\u13F2"], [[5115, 5115], "mapped", "\u13F3"], [[5116, 5116], "mapped", "\u13F4"], [[5117, 5117], "mapped", "\u13F5"], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", "", "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", "", "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", "", "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", "", "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", "", "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", "", "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", "", "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", "", "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", "", "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", "", "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", "", "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", "", "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", "", "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", "", "NV8"], [[6624, 6655], "valid", "", "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", "", "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", "", "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", "", "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", "", "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", "", "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", "", "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", "", "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", "", "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", "", "NV8"], [[7296, 7296], "mapped", "\u0432"], [[7297, 7297], "mapped", "\u0434"], [[7298, 7298], "mapped", "\u043E"], [[7299, 7299], "mapped", "\u0441"], [[7300, 7301], "mapped", "\u0442"], [[7302, 7302], "mapped", "\u044A"], [[7303, 7303], "mapped", "\u0463"], [[7304, 7304], "mapped", "\uA64B"], [[7305, 7359], "disallowed"], [[7360, 7367], "valid", "", "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", "", "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "valid"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", "a"], [[7469, 7469], "mapped", "\xE6"], [[7470, 7470], "mapped", "b"], [[7471, 7471], "valid"], [[7472, 7472], "mapped", "d"], [[7473, 7473], "mapped", "e"], [[7474, 7474], "mapped", "\u01DD"], [[7475, 7475], "mapped", "g"], [[7476, 7476], "mapped", "h"], [[7477, 7477], "mapped", "i"], [[7478, 7478], "mapped", "j"], [[7479, 7479], "mapped", "k"], [[7480, 7480], "mapped", "l"], [[7481, 7481], "mapped", "m"], [[7482, 7482], "mapped", "n"], [[7483, 7483], "valid"], [[7484, 7484], "mapped", "o"], [[7485, 7485], "mapped", "\u0223"], [[7486, 7486], "mapped", "p"], [[7487, 7487], "mapped", "r"], [[7488, 7488], "mapped", "t"], [[7489, 7489], "mapped", "u"], [[7490, 7490], "mapped", "w"], [[7491, 7491], "mapped", "a"], [[7492, 7492], "mapped", "\u0250"], [[7493, 7493], "mapped", "\u0251"], [[7494, 7494], "mapped", "\u1D02"], [[7495, 7495], "mapped", "b"], [[7496, 7496], "mapped", "d"], [[7497, 7497], "mapped", "e"], [[7498, 7498], "mapped", "\u0259"], [[7499, 7499], "mapped", "\u025B"], [[7500, 7500], "mapped", "\u025C"], [[7501, 7501], "mapped", "g"], [[7502, 7502], "valid"], [[7503, 7503], "mapped", "k"], [[7504, 7504], "mapped", "m"], [[7505, 7505], "mapped", "\u014B"], [[7506, 7506], "mapped", "o"], [[7507, 7507], "mapped", "\u0254"], [[7508, 7508], "mapped", "\u1D16"], [[7509, 7509], "mapped", "\u1D17"], [[7510, 7510], "mapped", "p"], [[7511, 7511], "mapped", "t"], [[7512, 7512], "mapped", "u"], [[7513, 7513], "mapped", "\u1D1D"], [[7514, 7514], "mapped", "\u026F"], [[7515, 7515], "mapped", "v"], [[7516, 7516], "mapped", "\u1D25"], [[7517, 7517], "mapped", "\u03B2"], [[7518, 7518], "mapped", "\u03B3"], [[7519, 7519], "mapped", "\u03B4"], [[7520, 7520], "mapped", "\u03C6"], [[7521, 7521], "mapped", "\u03C7"], [[7522, 7522], "mapped", "i"], [[7523, 7523], "mapped", "r"], [[7524, 7524], "mapped", "u"], [[7525, 7525], "mapped", "v"], [[7526, 7526], "mapped", "\u03B2"], [[7527, 7527], "mapped", "\u03B3"], [[7528, 7528], "mapped", "\u03C1"], [[7529, 7529], "mapped", "\u03C6"], [[7530, 7530], "mapped", "\u03C7"], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", "\u043D"], [[7545, 7578], "valid"], [[7579, 7579], "mapped", "\u0252"], [[7580, 7580], "mapped", "c"], [[7581, 7581], "mapped", "\u0255"], [[7582, 7582], "mapped", "\xF0"], [[7583, 7583], "mapped", "\u025C"], [[7584, 7584], "mapped", "f"], [[7585, 7585], "mapped", "\u025F"], [[7586, 7586], "mapped", "\u0261"], [[7587, 7587], "mapped", "\u0265"], [[7588, 7588], "mapped", "\u0268"], [[7589, 7589], "mapped", "\u0269"], [[7590, 7590], "mapped", "\u026A"], [[7591, 7591], "mapped", "\u1D7B"], [[7592, 7592], "mapped", "\u029D"], [[7593, 7593], "mapped", "\u026D"], [[7594, 7594], "mapped", "\u1D85"], [[7595, 7595], "mapped", "\u029F"], [[7596, 7596], "mapped", "\u0271"], [[7597, 7597], "mapped", "\u0270"], [[7598, 7598], "mapped", "\u0272"], [[7599, 7599], "mapped", "\u0273"], [[7600, 7600], "mapped", "\u0274"], [[7601, 7601], "mapped", "\u0275"], [[7602, 7602], "mapped", "\u0278"], [[7603, 7603], "mapped", "\u0282"], [[7604, 7604], "mapped", "\u0283"], [[7605, 7605], "mapped", "\u01AB"], [[7606, 7606], "mapped", "\u0289"], [[7607, 7607], "mapped", "\u028A"], [[7608, 7608], "mapped", "\u1D1C"], [[7609, 7609], "mapped", "\u028B"], [[7610, 7610], "mapped", "\u028C"], [[7611, 7611], "mapped", "z"], [[7612, 7612], "mapped", "\u0290"], [[7613, 7613], "mapped", "\u0291"], [[7614, 7614], "mapped", "\u0292"], [[7615, 7615], "mapped", "\u03B8"], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7673], "valid"], [[7674, 7674], "disallowed"], [[7675, 7675], "valid"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", "\u1E01"], [[7681, 7681], "valid"], [[7682, 7682], "mapped", "\u1E03"], [[7683, 7683], "valid"], [[7684, 7684], "mapped", "\u1E05"], [[7685, 7685], "valid"], [[7686, 7686], "mapped", "\u1E07"], [[7687, 7687], "valid"], [[7688, 7688], "mapped", "\u1E09"], [[7689, 7689], "valid"], [[7690, 7690], "mapped", "\u1E0B"], [[7691, 7691], "valid"], [[7692, 7692], "mapped", "\u1E0D"], [[7693, 7693], "valid"], [[7694, 7694], "mapped", "\u1E0F"], [[7695, 7695], "valid"], [[7696, 7696], "mapped", "\u1E11"], [[7697, 7697], "valid"], [[7698, 7698], "mapped", "\u1E13"], [[7699, 7699], "valid"], [[7700, 7700], "mapped", "\u1E15"], [[7701, 7701], "valid"], [[7702, 7702], "mapped", "\u1E17"], [[7703, 7703], "valid"], [[7704, 7704], "mapped", "\u1E19"], [[7705, 7705], "valid"], [[7706, 7706], "mapped", "\u1E1B"], [[7707, 7707], "valid"], [[7708, 7708], "mapped", "\u1E1D"], [[7709, 7709], "valid"], [[7710, 7710], "mapped", "\u1E1F"], [[7711, 7711], "valid"], [[7712, 7712], "mapped", "\u1E21"], [[7713, 7713], "valid"], [[7714, 7714], "mapped", "\u1E23"], [[7715, 7715], "valid"], [[7716, 7716], "mapped", "\u1E25"], [[7717, 7717], "valid"], [[7718, 7718], "mapped", "\u1E27"], [[7719, 7719], "valid"], [[7720, 7720], "mapped", "\u1E29"], [[7721, 7721], "valid"], [[7722, 7722], "mapped", "\u1E2B"], [[7723, 7723], "valid"], [[7724, 7724], "mapped", "\u1E2D"], [[7725, 7725], "valid"], [[7726, 7726], "mapped", "\u1E2F"], [[7727, 7727], "valid"], [[7728, 7728], "mapped", "\u1E31"], [[7729, 7729], "valid"], [[7730, 7730], "mapped", "\u1E33"], [[7731, 7731], "valid"], [[7732, 7732], "mapped", "\u1E35"], [[7733, 7733], "valid"], [[7734, 7734], "mapped", "\u1E37"], [[7735, 7735], "valid"], [[7736, 7736], "mapped", "\u1E39"], [[7737, 7737], "valid"], [[7738, 7738], "mapped", "\u1E3B"], [[7739, 7739], "valid"], [[7740, 7740], "mapped", "\u1E3D"], [[7741, 7741], "valid"], [[7742, 7742], "mapped", "\u1E3F"], [[7743, 7743], "valid"], [[7744, 7744], "mapped", "\u1E41"], [[7745, 7745], "valid"], [[7746, 7746], "mapped", "\u1E43"], [[7747, 7747], "valid"], [[7748, 7748], "mapped", "\u1E45"], [[7749, 7749], "valid"], [[7750, 7750], "mapped", "\u1E47"], [[7751, 7751], "valid"], [[7752, 7752], "mapped", "\u1E49"], [[7753, 7753], "valid"], [[7754, 7754], "mapped", "\u1E4B"], [[7755, 7755], "valid"], [[7756, 7756], "mapped", "\u1E4D"], [[7757, 7757], "valid"], [[7758, 7758], "mapped", "\u1E4F"], [[7759, 7759], "valid"], [[7760, 7760], "mapped", "\u1E51"], [[7761, 7761], "valid"], [[7762, 7762], "mapped", "\u1E53"], [[7763, 7763], "valid"], [[7764, 7764], "mapped", "\u1E55"], [[7765, 7765], "valid"], [[7766, 7766], "mapped", "\u1E57"], [[7767, 7767], "valid"], [[7768, 7768], "mapped", "\u1E59"], [[7769, 7769], "valid"], [[7770, 7770], "mapped", "\u1E5B"], [[7771, 7771], "valid"], [[7772, 7772], "mapped", "\u1E5D"], [[7773, 7773], "valid"], [[7774, 7774], "mapped", "\u1E5F"], [[7775, 7775], "valid"], [[7776, 7776], "mapped", "\u1E61"], [[7777, 7777], "valid"], [[7778, 7778], "mapped", "\u1E63"], [[7779, 7779], "valid"], [[7780, 7780], "mapped", "\u1E65"], [[7781, 7781], "valid"], [[7782, 7782], "mapped", "\u1E67"], [[7783, 7783], "valid"], [[7784, 7784], "mapped", "\u1E69"], [[7785, 7785], "valid"], [[7786, 7786], "mapped", "\u1E6B"], [[7787, 7787], "valid"], [[7788, 7788], "mapped", "\u1E6D"], [[7789, 7789], "valid"], [[7790, 7790], "mapped", "\u1E6F"], [[7791, 7791], "valid"], [[7792, 7792], "mapped", "\u1E71"], [[7793, 7793], "valid"], [[7794, 7794], "mapped", "\u1E73"], [[7795, 7795], "valid"], [[7796, 7796], "mapped", "\u1E75"], [[7797, 7797], "valid"], [[7798, 7798], "mapped", "\u1E77"], [[7799, 7799], "valid"], [[7800, 7800], "mapped", "\u1E79"], [[7801, 7801], "valid"], [[7802, 7802], "mapped", "\u1E7B"], [[7803, 7803], "valid"], [[7804, 7804], "mapped", "\u1E7D"], [[7805, 7805], "valid"], [[7806, 7806], "mapped", "\u1E7F"], [[7807, 7807], "valid"], [[7808, 7808], "mapped", "\u1E81"], [[7809, 7809], "valid"], [[7810, 7810], "mapped", "\u1E83"], [[7811, 7811], "valid"], [[7812, 7812], "mapped", "\u1E85"], [[7813, 7813], "valid"], [[7814, 7814], "mapped", "\u1E87"], [[7815, 7815], "valid"], [[7816, 7816], "mapped", "\u1E89"], [[7817, 7817], "valid"], [[7818, 7818], "mapped", "\u1E8B"], [[7819, 7819], "valid"], [[7820, 7820], "mapped", "\u1E8D"], [[7821, 7821], "valid"], [[7822, 7822], "mapped", "\u1E8F"], [[7823, 7823], "valid"], [[7824, 7824], "mapped", "\u1E91"], [[7825, 7825], "valid"], [[7826, 7826], "mapped", "\u1E93"], [[7827, 7827], "valid"], [[7828, 7828], "mapped", "\u1E95"], [[7829, 7833], "valid"], [[7834, 7834], "mapped", "a\u02BE"], [[7835, 7835], "mapped", "\u1E61"], [[7836, 7837], "valid"], [[7838, 7838], "mapped", "ss"], [[7839, 7839], "valid"], [[7840, 7840], "mapped", "\u1EA1"], [[7841, 7841], "valid"], [[7842, 7842], "mapped", "\u1EA3"], [[7843, 7843], "valid"], [[7844, 7844], "mapped", "\u1EA5"], [[7845, 7845], "valid"], [[7846, 7846], "mapped", "\u1EA7"], [[7847, 7847], "valid"], [[7848, 7848], "mapped", "\u1EA9"], [[7849, 7849], "valid"], [[7850, 7850], "mapped", "\u1EAB"], [[7851, 7851], "valid"], [[7852, 7852], "mapped", "\u1EAD"], [[7853, 7853], "valid"], [[7854, 7854], "mapped", "\u1EAF"], [[7855, 7855], "valid"], [[7856, 7856], "mapped", "\u1EB1"], [[7857, 7857], "valid"], [[7858, 7858], "mapped", "\u1EB3"], [[7859, 7859], "valid"], [[7860, 7860], "mapped", "\u1EB5"], [[7861, 7861], "valid"], [[7862, 7862], "mapped", "\u1EB7"], [[7863, 7863], "valid"], [[7864, 7864], "mapped", "\u1EB9"], [[7865, 7865], "valid"], [[7866, 7866], "mapped", "\u1EBB"], [[7867, 7867], "valid"], [[7868, 7868], "mapped", "\u1EBD"], [[7869, 7869], "valid"], [[7870, 7870], "mapped", "\u1EBF"], [[7871, 7871], "valid"], [[7872, 7872], "mapped", "\u1EC1"], [[7873, 7873], "valid"], [[7874, 7874], "mapped", "\u1EC3"], [[7875, 7875], "valid"], [[7876, 7876], "mapped", "\u1EC5"], [[7877, 7877], "valid"], [[7878, 7878], "mapped", "\u1EC7"], [[7879, 7879], "valid"], [[7880, 7880], "mapped", "\u1EC9"], [[7881, 7881], "valid"], [[7882, 7882], "mapped", "\u1ECB"], [[7883, 7883], "valid"], [[7884, 7884], "mapped", "\u1ECD"], [[7885, 7885], "valid"], [[7886, 7886], "mapped", "\u1ECF"], [[7887, 7887], "valid"], [[7888, 7888], "mapped", "\u1ED1"], [[7889, 7889], "valid"], [[7890, 7890], "mapped", "\u1ED3"], [[7891, 7891], "valid"], [[7892, 7892], "mapped", "\u1ED5"], [[7893, 7893], "valid"], [[7894, 7894], "mapped", "\u1ED7"], [[7895, 7895], "valid"], [[7896, 7896], "mapped", "\u1ED9"], [[7897, 7897], "valid"], [[7898, 7898], "mapped", "\u1EDB"], [[7899, 7899], "valid"], [[7900, 7900], "mapped", "\u1EDD"], [[7901, 7901], "valid"], [[7902, 7902], "mapped", "\u1EDF"], [[7903, 7903], "valid"], [[7904, 7904], "mapped", "\u1EE1"], [[7905, 7905], "valid"], [[7906, 7906], "mapped", "\u1EE3"], [[7907, 7907], "valid"], [[7908, 7908], "mapped", "\u1EE5"], [[7909, 7909], "valid"], [[7910, 7910], "mapped", "\u1EE7"], [[7911, 7911], "valid"], [[7912, 7912], "mapped", "\u1EE9"], [[7913, 7913], "valid"], [[7914, 7914], "mapped", "\u1EEB"], [[7915, 7915], "valid"], [[7916, 7916], "mapped", "\u1EED"], [[7917, 7917], "valid"], [[7918, 7918], "mapped", "\u1EEF"], [[7919, 7919], "valid"], [[7920, 7920], "mapped", "\u1EF1"], [[7921, 7921], "valid"], [[7922, 7922], "mapped", "\u1EF3"], [[7923, 7923], "valid"], [[7924, 7924], "mapped", "\u1EF5"], [[7925, 7925], "valid"], [[7926, 7926], "mapped", "\u1EF7"], [[7927, 7927], "valid"], [[7928, 7928], "mapped", "\u1EF9"], [[7929, 7929], "valid"], [[7930, 7930], "mapped", "\u1EFB"], [[7931, 7931], "valid"], [[7932, 7932], "mapped", "\u1EFD"], [[7933, 7933], "valid"], [[7934, 7934], "mapped", "\u1EFF"], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", "\u1F00"], [[7945, 7945], "mapped", "\u1F01"], [[7946, 7946], "mapped", "\u1F02"], [[7947, 7947], "mapped", "\u1F03"], [[7948, 7948], "mapped", "\u1F04"], [[7949, 7949], "mapped", "\u1F05"], [[7950, 7950], "mapped", "\u1F06"], [[7951, 7951], "mapped", "\u1F07"], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", "\u1F10"], [[7961, 7961], "mapped", "\u1F11"], [[7962, 7962], "mapped", "\u1F12"], [[7963, 7963], "mapped", "\u1F13"], [[7964, 7964], "mapped", "\u1F14"], [[7965, 7965], "mapped", "\u1F15"], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", "\u1F20"], [[7977, 7977], "mapped", "\u1F21"], [[7978, 7978], "mapped", "\u1F22"], [[7979, 7979], "mapped", "\u1F23"], [[7980, 7980], "mapped", "\u1F24"], [[7981, 7981], "mapped", "\u1F25"], [[7982, 7982], "mapped", "\u1F26"], [[7983, 7983], "mapped", "\u1F27"], [[7984, 7991], "valid"], [[7992, 7992], "mapped", "\u1F30"], [[7993, 7993], "mapped", "\u1F31"], [[7994, 7994], "mapped", "\u1F32"], [[7995, 7995], "mapped", "\u1F33"], [[7996, 7996], "mapped", "\u1F34"], [[7997, 7997], "mapped", "\u1F35"], [[7998, 7998], "mapped", "\u1F36"], [[7999, 7999], "mapped", "\u1F37"], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", "\u1F40"], [[8009, 8009], "mapped", "\u1F41"], [[8010, 8010], "mapped", "\u1F42"], [[8011, 8011], "mapped", "\u1F43"], [[8012, 8012], "mapped", "\u1F44"], [[8013, 8013], "mapped", "\u1F45"], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", "\u1F51"], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", "\u1F53"], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", "\u1F55"], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", "\u1F57"], [[8032, 8039], "valid"], [[8040, 8040], "mapped", "\u1F60"], [[8041, 8041], "mapped", "\u1F61"], [[8042, 8042], "mapped", "\u1F62"], [[8043, 8043], "mapped", "\u1F63"], [[8044, 8044], "mapped", "\u1F64"], [[8045, 8045], "mapped", "\u1F65"], [[8046, 8046], "mapped", "\u1F66"], [[8047, 8047], "mapped", "\u1F67"], [[8048, 8048], "valid"], [[8049, 8049], "mapped", "\u03AC"], [[8050, 8050], "valid"], [[8051, 8051], "mapped", "\u03AD"], [[8052, 8052], "valid"], [[8053, 8053], "mapped", "\u03AE"], [[8054, 8054], "valid"], [[8055, 8055], "mapped", "\u03AF"], [[8056, 8056], "valid"], [[8057, 8057], "mapped", "\u03CC"], [[8058, 8058], "valid"], [[8059, 8059], "mapped", "\u03CD"], [[8060, 8060], "valid"], [[8061, 8061], "mapped", "\u03CE"], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", "\u1F00\u03B9"], [[8065, 8065], "mapped", "\u1F01\u03B9"], [[8066, 8066], "mapped", "\u1F02\u03B9"], [[8067, 8067], "mapped", "\u1F03\u03B9"], [[8068, 8068], "mapped", "\u1F04\u03B9"], [[8069, 8069], "mapped", "\u1F05\u03B9"], [[8070, 8070], "mapped", "\u1F06\u03B9"], [[8071, 8071], "mapped", "\u1F07\u03B9"], [[8072, 8072], "mapped", "\u1F00\u03B9"], [[8073, 8073], "mapped", "\u1F01\u03B9"], [[8074, 8074], "mapped", "\u1F02\u03B9"], [[8075, 8075], "mapped", "\u1F03\u03B9"], [[8076, 8076], "mapped", "\u1F04\u03B9"], [[8077, 8077], "mapped", "\u1F05\u03B9"], [[8078, 8078], "mapped", "\u1F06\u03B9"], [[8079, 8079], "mapped", "\u1F07\u03B9"], [[8080, 8080], "mapped", "\u1F20\u03B9"], [[8081, 8081], "mapped", "\u1F21\u03B9"], [[8082, 8082], "mapped", "\u1F22\u03B9"], [[8083, 8083], "mapped", "\u1F23\u03B9"], [[8084, 8084], "mapped", "\u1F24\u03B9"], [[8085, 8085], "mapped", "\u1F25\u03B9"], [[8086, 8086], "mapped", "\u1F26\u03B9"], [[8087, 8087], "mapped", "\u1F27\u03B9"], [[8088, 8088], "mapped", "\u1F20\u03B9"], [[8089, 8089], "mapped", "\u1F21\u03B9"], [[8090, 8090], "mapped", "\u1F22\u03B9"], [[8091, 8091], "mapped", "\u1F23\u03B9"], [[8092, 8092], "mapped", "\u1F24\u03B9"], [[8093, 8093], "mapped", "\u1F25\u03B9"], [[8094, 8094], "mapped", "\u1F26\u03B9"], [[8095, 8095], "mapped", "\u1F27\u03B9"], [[8096, 8096], "mapped", "\u1F60\u03B9"], [[8097, 8097], "mapped", "\u1F61\u03B9"], [[8098, 8098], "mapped", "\u1F62\u03B9"], [[8099, 8099], "mapped", "\u1F63\u03B9"], [[8100, 8100], "mapped", "\u1F64\u03B9"], [[8101, 8101], "mapped", "\u1F65\u03B9"], [[8102, 8102], "mapped", "\u1F66\u03B9"], [[8103, 8103], "mapped", "\u1F67\u03B9"], [[8104, 8104], "mapped", "\u1F60\u03B9"], [[8105, 8105], "mapped", "\u1F61\u03B9"], [[8106, 8106], "mapped", "\u1F62\u03B9"], [[8107, 8107], "mapped", "\u1F63\u03B9"], [[8108, 8108], "mapped", "\u1F64\u03B9"], [[8109, 8109], "mapped", "\u1F65\u03B9"], [[8110, 8110], "mapped", "\u1F66\u03B9"], [[8111, 8111], "mapped", "\u1F67\u03B9"], [[8112, 8113], "valid"], [[8114, 8114], "mapped", "\u1F70\u03B9"], [[8115, 8115], "mapped", "\u03B1\u03B9"], [[8116, 8116], "mapped", "\u03AC\u03B9"], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", "\u1FB6\u03B9"], [[8120, 8120], "mapped", "\u1FB0"], [[8121, 8121], "mapped", "\u1FB1"], [[8122, 8122], "mapped", "\u1F70"], [[8123, 8123], "mapped", "\u03AC"], [[8124, 8124], "mapped", "\u03B1\u03B9"], [[8125, 8125], "disallowed_STD3_mapped", " \u0313"], [[8126, 8126], "mapped", "\u03B9"], [[8127, 8127], "disallowed_STD3_mapped", " \u0313"], [[8128, 8128], "disallowed_STD3_mapped", " \u0342"], [[8129, 8129], "disallowed_STD3_mapped", " \u0308\u0342"], [[8130, 8130], "mapped", "\u1F74\u03B9"], [[8131, 8131], "mapped", "\u03B7\u03B9"], [[8132, 8132], "mapped", "\u03AE\u03B9"], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", "\u1FC6\u03B9"], [[8136, 8136], "mapped", "\u1F72"], [[8137, 8137], "mapped", "\u03AD"], [[8138, 8138], "mapped", "\u1F74"], [[8139, 8139], "mapped", "\u03AE"], [[8140, 8140], "mapped", "\u03B7\u03B9"], [[8141, 8141], "disallowed_STD3_mapped", " \u0313\u0300"], [[8142, 8142], "disallowed_STD3_mapped", " \u0313\u0301"], [[8143, 8143], "disallowed_STD3_mapped", " \u0313\u0342"], [[8144, 8146], "valid"], [[8147, 8147], "mapped", "\u0390"], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", "\u1FD0"], [[8153, 8153], "mapped", "\u1FD1"], [[8154, 8154], "mapped", "\u1F76"], [[8155, 8155], "mapped", "\u03AF"], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", " \u0314\u0300"], [[8158, 8158], "disallowed_STD3_mapped", " \u0314\u0301"], [[8159, 8159], "disallowed_STD3_mapped", " \u0314\u0342"], [[8160, 8162], "valid"], [[8163, 8163], "mapped", "\u03B0"], [[8164, 8167], "valid"], [[8168, 8168], "mapped", "\u1FE0"], [[8169, 8169], "mapped", "\u1FE1"], [[8170, 8170], "mapped", "\u1F7A"], [[8171, 8171], "mapped", "\u03CD"], [[8172, 8172], "mapped", "\u1FE5"], [[8173, 8173], "disallowed_STD3_mapped", " \u0308\u0300"], [[8174, 8174], "disallowed_STD3_mapped", " \u0308\u0301"], [[8175, 8175], "disallowed_STD3_mapped", "`"], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", "\u1F7C\u03B9"], [[8179, 8179], "mapped", "\u03C9\u03B9"], [[8180, 8180], "mapped", "\u03CE\u03B9"], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", "\u1FF6\u03B9"], [[8184, 8184], "mapped", "\u1F78"], [[8185, 8185], "mapped", "\u03CC"], [[8186, 8186], "mapped", "\u1F7C"], [[8187, 8187], "mapped", "\u03CE"], [[8188, 8188], "mapped", "\u03C9\u03B9"], [[8189, 8189], "disallowed_STD3_mapped", " \u0301"], [[8190, 8190], "disallowed_STD3_mapped", " \u0314"], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", " "], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", ""], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", "", "NV8"], [[8209, 8209], "mapped", "\u2010"], [[8210, 8214], "valid", "", "NV8"], [[8215, 8215], "disallowed_STD3_mapped", " \u0333"], [[8216, 8227], "valid", "", "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", "", "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", " "], [[8240, 8242], "valid", "", "NV8"], [[8243, 8243], "mapped", "\u2032\u2032"], [[8244, 8244], "mapped", "\u2032\u2032\u2032"], [[8245, 8245], "valid", "", "NV8"], [[8246, 8246], "mapped", "\u2035\u2035"], [[8247, 8247], "mapped", "\u2035\u2035\u2035"], [[8248, 8251], "valid", "", "NV8"], [[8252, 8252], "disallowed_STD3_mapped", "!!"], [[8253, 8253], "valid", "", "NV8"], [[8254, 8254], "disallowed_STD3_mapped", " \u0305"], [[8255, 8262], "valid", "", "NV8"], [[8263, 8263], "disallowed_STD3_mapped", "??"], [[8264, 8264], "disallowed_STD3_mapped", "?!"], [[8265, 8265], "disallowed_STD3_mapped", "!?"], [[8266, 8269], "valid", "", "NV8"], [[8270, 8274], "valid", "", "NV8"], [[8275, 8276], "valid", "", "NV8"], [[8277, 8278], "valid", "", "NV8"], [[8279, 8279], "mapped", "\u2032\u2032\u2032\u2032"], [[8280, 8286], "valid", "", "NV8"], [[8287, 8287], "disallowed_STD3_mapped", " "], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", "0"], [[8305, 8305], "mapped", "i"], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", "4"], [[8309, 8309], "mapped", "5"], [[8310, 8310], "mapped", "6"], [[8311, 8311], "mapped", "7"], [[8312, 8312], "mapped", "8"], [[8313, 8313], "mapped", "9"], [[8314, 8314], "disallowed_STD3_mapped", "+"], [[8315, 8315], "mapped", "\u2212"], [[8316, 8316], "disallowed_STD3_mapped", "="], [[8317, 8317], "disallowed_STD3_mapped", "("], [[8318, 8318], "disallowed_STD3_mapped", ")"], [[8319, 8319], "mapped", "n"], [[8320, 8320], "mapped", "0"], [[8321, 8321], "mapped", "1"], [[8322, 8322], "mapped", "2"], [[8323, 8323], "mapped", "3"], [[8324, 8324], "mapped", "4"], [[8325, 8325], "mapped", "5"], [[8326, 8326], "mapped", "6"], [[8327, 8327], "mapped", "7"], [[8328, 8328], "mapped", "8"], [[8329, 8329], "mapped", "9"], [[8330, 8330], "disallowed_STD3_mapped", "+"], [[8331, 8331], "mapped", "\u2212"], [[8332, 8332], "disallowed_STD3_mapped", "="], [[8333, 8333], "disallowed_STD3_mapped", "("], [[8334, 8334], "disallowed_STD3_mapped", ")"], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", "a"], [[8337, 8337], "mapped", "e"], [[8338, 8338], "mapped", "o"], [[8339, 8339], "mapped", "x"], [[8340, 8340], "mapped", "\u0259"], [[8341, 8341], "mapped", "h"], [[8342, 8342], "mapped", "k"], [[8343, 8343], "mapped", "l"], [[8344, 8344], "mapped", "m"], [[8345, 8345], "mapped", "n"], [[8346, 8346], "mapped", "p"], [[8347, 8347], "mapped", "s"], [[8348, 8348], "mapped", "t"], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", "", "NV8"], [[8360, 8360], "mapped", "rs"], [[8361, 8362], "valid", "", "NV8"], [[8363, 8363], "valid", "", "NV8"], [[8364, 8364], "valid", "", "NV8"], [[8365, 8367], "valid", "", "NV8"], [[8368, 8369], "valid", "", "NV8"], [[8370, 8373], "valid", "", "NV8"], [[8374, 8376], "valid", "", "NV8"], [[8377, 8377], "valid", "", "NV8"], [[8378, 8378], "valid", "", "NV8"], [[8379, 8381], "valid", "", "NV8"], [[8382, 8382], "valid", "", "NV8"], [[8383, 8383], "valid", "", "NV8"], [[8384, 8399], "disallowed"], [[8400, 8417], "valid", "", "NV8"], [[8418, 8419], "valid", "", "NV8"], [[8420, 8426], "valid", "", "NV8"], [[8427, 8427], "valid", "", "NV8"], [[8428, 8431], "valid", "", "NV8"], [[8432, 8432], "valid", "", "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", "a/c"], [[8449, 8449], "disallowed_STD3_mapped", "a/s"], [[8450, 8450], "mapped", "c"], [[8451, 8451], "mapped", "\xB0c"], [[8452, 8452], "valid", "", "NV8"], [[8453, 8453], "disallowed_STD3_mapped", "c/o"], [[8454, 8454], "disallowed_STD3_mapped", "c/u"], [[8455, 8455], "mapped", "\u025B"], [[8456, 8456], "valid", "", "NV8"], [[8457, 8457], "mapped", "\xB0f"], [[8458, 8458], "mapped", "g"], [[8459, 8462], "mapped", "h"], [[8463, 8463], "mapped", "\u0127"], [[8464, 8465], "mapped", "i"], [[8466, 8467], "mapped", "l"], [[8468, 8468], "valid", "", "NV8"], [[8469, 8469], "mapped", "n"], [[8470, 8470], "mapped", "no"], [[8471, 8472], "valid", "", "NV8"], [[8473, 8473], "mapped", "p"], [[8474, 8474], "mapped", "q"], [[8475, 8477], "mapped", "r"], [[8478, 8479], "valid", "", "NV8"], [[8480, 8480], "mapped", "sm"], [[8481, 8481], "mapped", "tel"], [[8482, 8482], "mapped", "tm"], [[8483, 8483], "valid", "", "NV8"], [[8484, 8484], "mapped", "z"], [[8485, 8485], "valid", "", "NV8"], [[8486, 8486], "mapped", "\u03C9"], [[8487, 8487], "valid", "", "NV8"], [[8488, 8488], "mapped", "z"], [[8489, 8489], "valid", "", "NV8"], [[8490, 8490], "mapped", "k"], [[8491, 8491], "mapped", "\xE5"], [[8492, 8492], "mapped", "b"], [[8493, 8493], "mapped", "c"], [[8494, 8494], "valid", "", "NV8"], [[8495, 8496], "mapped", "e"], [[8497, 8497], "mapped", "f"], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", "m"], [[8500, 8500], "mapped", "o"], [[8501, 8501], "mapped", "\u05D0"], [[8502, 8502], "mapped", "\u05D1"], [[8503, 8503], "mapped", "\u05D2"], [[8504, 8504], "mapped", "\u05D3"], [[8505, 8505], "mapped", "i"], [[8506, 8506], "valid", "", "NV8"], [[8507, 8507], "mapped", "fax"], [[8508, 8508], "mapped", "\u03C0"], [[8509, 8510], "mapped", "\u03B3"], [[8511, 8511], "mapped", "\u03C0"], [[8512, 8512], "mapped", "\u2211"], [[8513, 8516], "valid", "", "NV8"], [[8517, 8518], "mapped", "d"], [[8519, 8519], "mapped", "e"], [[8520, 8520], "mapped", "i"], [[8521, 8521], "mapped", "j"], [[8522, 8523], "valid", "", "NV8"], [[8524, 8524], "valid", "", "NV8"], [[8525, 8525], "valid", "", "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", "", "NV8"], [[8528, 8528], "mapped", "1\u20447"], [[8529, 8529], "mapped", "1\u20449"], [[8530, 8530], "mapped", "1\u204410"], [[8531, 8531], "mapped", "1\u20443"], [[8532, 8532], "mapped", "2\u20443"], [[8533, 8533], "mapped", "1\u20445"], [[8534, 8534], "mapped", "2\u20445"], [[8535, 8535], "mapped", "3\u20445"], [[8536, 8536], "mapped", "4\u20445"], [[8537, 8537], "mapped", "1\u20446"], [[8538, 8538], "mapped", "5\u20446"], [[8539, 8539], "mapped", "1\u20448"], [[8540, 8540], "mapped", "3\u20448"], [[8541, 8541], "mapped", "5\u20448"], [[8542, 8542], "mapped", "7\u20448"], [[8543, 8543], "mapped", "1\u2044"], [[8544, 8544], "mapped", "i"], [[8545, 8545], "mapped", "ii"], [[8546, 8546], "mapped", "iii"], [[8547, 8547], "mapped", "iv"], [[8548, 8548], "mapped", "v"], [[8549, 8549], "mapped", "vi"], [[8550, 8550], "mapped", "vii"], [[8551, 8551], "mapped", "viii"], [[8552, 8552], "mapped", "ix"], [[8553, 8553], "mapped", "x"], [[8554, 8554], "mapped", "xi"], [[8555, 8555], "mapped", "xii"], [[8556, 8556], "mapped", "l"], [[8557, 8557], "mapped", "c"], [[8558, 8558], "mapped", "d"], [[8559, 8559], "mapped", "m"], [[8560, 8560], "mapped", "i"], [[8561, 8561], "mapped", "ii"], [[8562, 8562], "mapped", "iii"], [[8563, 8563], "mapped", "iv"], [[8564, 8564], "mapped", "v"], [[8565, 8565], "mapped", "vi"], [[8566, 8566], "mapped", "vii"], [[8567, 8567], "mapped", "viii"], [[8568, 8568], "mapped", "ix"], [[8569, 8569], "mapped", "x"], [[8570, 8570], "mapped", "xi"], [[8571, 8571], "mapped", "xii"], [[8572, 8572], "mapped", "l"], [[8573, 8573], "mapped", "c"], [[8574, 8574], "mapped", "d"], [[8575, 8575], "mapped", "m"], [[8576, 8578], "valid", "", "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", "", "NV8"], [[8585, 8585], "mapped", "0\u20443"], [[8586, 8587], "valid", "", "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", "", "NV8"], [[8683, 8691], "valid", "", "NV8"], [[8692, 8703], "valid", "", "NV8"], [[8704, 8747], "valid", "", "NV8"], [[8748, 8748], "mapped", "\u222B\u222B"], [[8749, 8749], "mapped", "\u222B\u222B\u222B"], [[8750, 8750], "valid", "", "NV8"], [[8751, 8751], "mapped", "\u222E\u222E"], [[8752, 8752], "mapped", "\u222E\u222E\u222E"], [[8753, 8799], "valid", "", "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", "", "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", "", "NV8"], [[8946, 8959], "valid", "", "NV8"], [[8960, 8960], "valid", "", "NV8"], [[8961, 8961], "valid", "", "NV8"], [[8962, 9e3], "valid", "", "NV8"], [[9001, 9001], "mapped", "\u3008"], [[9002, 9002], "mapped", "\u3009"], [[9003, 9082], "valid", "", "NV8"], [[9083, 9083], "valid", "", "NV8"], [[9084, 9084], "valid", "", "NV8"], [[9085, 9114], "valid", "", "NV8"], [[9115, 9166], "valid", "", "NV8"], [[9167, 9168], "valid", "", "NV8"], [[9169, 9179], "valid", "", "NV8"], [[9180, 9191], "valid", "", "NV8"], [[9192, 9192], "valid", "", "NV8"], [[9193, 9203], "valid", "", "NV8"], [[9204, 9210], "valid", "", "NV8"], [[9211, 9214], "valid", "", "NV8"], [[9215, 9215], "valid", "", "NV8"], [[9216, 9252], "valid", "", "NV8"], [[9253, 9254], "valid", "", "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", "", "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", "1"], [[9313, 9313], "mapped", "2"], [[9314, 9314], "mapped", "3"], [[9315, 9315], "mapped", "4"], [[9316, 9316], "mapped", "5"], [[9317, 9317], "mapped", "6"], [[9318, 9318], "mapped", "7"], [[9319, 9319], "mapped", "8"], [[9320, 9320], "mapped", "9"], [[9321, 9321], "mapped", "10"], [[9322, 9322], "mapped", "11"], [[9323, 9323], "mapped", "12"], [[9324, 9324], "mapped", "13"], [[9325, 9325], "mapped", "14"], [[9326, 9326], "mapped", "15"], [[9327, 9327], "mapped", "16"], [[9328, 9328], "mapped", "17"], [[9329, 9329], "mapped", "18"], [[9330, 9330], "mapped", "19"], [[9331, 9331], "mapped", "20"], [[9332, 9332], "disallowed_STD3_mapped", "(1)"], [[9333, 9333], "disallowed_STD3_mapped", "(2)"], [[9334, 9334], "disallowed_STD3_mapped", "(3)"], [[9335, 9335], "disallowed_STD3_mapped", "(4)"], [[9336, 9336], "disallowed_STD3_mapped", "(5)"], [[9337, 9337], "disallowed_STD3_mapped", "(6)"], [[9338, 9338], "disallowed_STD3_mapped", "(7)"], [[9339, 9339], "disallowed_STD3_mapped", "(8)"], [[9340, 9340], "disallowed_STD3_mapped", "(9)"], [[9341, 9341], "disallowed_STD3_mapped", "(10)"], [[9342, 9342], "disallowed_STD3_mapped", "(11)"], [[9343, 9343], "disallowed_STD3_mapped", "(12)"], [[9344, 9344], "disallowed_STD3_mapped", "(13)"], [[9345, 9345], "disallowed_STD3_mapped", "(14)"], [[9346, 9346], "disallowed_STD3_mapped", "(15)"], [[9347, 9347], "disallowed_STD3_mapped", "(16)"], [[9348, 9348], "disallowed_STD3_mapped", "(17)"], [[9349, 9349], "disallowed_STD3_mapped", "(18)"], [[9350, 9350], "disallowed_STD3_mapped", "(19)"], [[9351, 9351], "disallowed_STD3_mapped", "(20)"], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", "(a)"], [[9373, 9373], "disallowed_STD3_mapped", "(b)"], [[9374, 9374], "disallowed_STD3_mapped", "(c)"], [[9375, 9375], "disallowed_STD3_mapped", "(d)"], [[9376, 9376], "disallowed_STD3_mapped", "(e)"], [[9377, 9377], "disallowed_STD3_mapped", "(f)"], [[9378, 9378], "disallowed_STD3_mapped", "(g)"], [[9379, 9379], "disallowed_STD3_mapped", "(h)"], [[9380, 9380], "disallowed_STD3_mapped", "(i)"], [[9381, 9381], "disallowed_STD3_mapped", "(j)"], [[9382, 9382], "disallowed_STD3_mapped", "(k)"], [[9383, 9383], "disallowed_STD3_mapped", "(l)"], [[9384, 9384], "disallowed_STD3_mapped", "(m)"], [[9385, 9385], "disallowed_STD3_mapped", "(n)"], [[9386, 9386], "disallowed_STD3_mapped", "(o)"], [[9387, 9387], "disallowed_STD3_mapped", "(p)"], [[9388, 9388], "disallowed_STD3_mapped", "(q)"], [[9389, 9389], "disallowed_STD3_mapped", "(r)"], [[9390, 9390], "disallowed_STD3_mapped", "(s)"], [[9391, 9391], "disallowed_STD3_mapped", "(t)"], [[9392, 9392], "disallowed_STD3_mapped", "(u)"], [[9393, 9393], "disallowed_STD3_mapped", "(v)"], [[9394, 9394], "disallowed_STD3_mapped", "(w)"], [[9395, 9395], "disallowed_STD3_mapped", "(x)"], [[9396, 9396], "disallowed_STD3_mapped", "(y)"], [[9397, 9397], "disallowed_STD3_mapped", "(z)"], [[9398, 9398], "mapped", "a"], [[9399, 9399], "mapped", "b"], [[9400, 9400], "mapped", "c"], [[9401, 9401], "mapped", "d"], [[9402, 9402], "mapped", "e"], [[9403, 9403], "mapped", "f"], [[9404, 9404], "mapped", "g"], [[9405, 9405], "mapped", "h"], [[9406, 9406], "mapped", "i"], [[9407, 9407], "mapped", "j"], [[9408, 9408], "mapped", "k"], [[9409, 9409], "mapped", "l"], [[9410, 9410], "mapped", "m"], [[9411, 9411], "mapped", "n"], [[9412, 9412], "mapped", "o"], [[9413, 9413], "mapped", "p"], [[9414, 9414], "mapped", "q"], [[9415, 9415], "mapped", "r"], [[9416, 9416], "mapped", "s"], [[9417, 9417], "mapped", "t"], [[9418, 9418], "mapped", "u"], [[9419, 9419], "mapped", "v"], [[9420, 9420], "mapped", "w"], [[9421, 9421], "mapped", "x"], [[9422, 9422], "mapped", "y"], [[9423, 9423], "mapped", "z"], [[9424, 9424], "mapped", "a"], [[9425, 9425], "mapped", "b"], [[9426, 9426], "mapped", "c"], [[9427, 9427], "mapped", "d"], [[9428, 9428], "mapped", "e"], [[9429, 9429], "mapped", "f"], [[9430, 9430], "mapped", "g"], [[9431, 9431], "mapped", "h"], [[9432, 9432], "mapped", "i"], [[9433, 9433], "mapped", "j"], [[9434, 9434], "mapped", "k"], [[9435, 9435], "mapped", "l"], [[9436, 9436], "mapped", "m"], [[9437, 9437], "mapped", "n"], [[9438, 9438], "mapped", "o"], [[9439, 9439], "mapped", "p"], [[9440, 9440], "mapped", "q"], [[9441, 9441], "mapped", "r"], [[9442, 9442], "mapped", "s"], [[9443, 9443], "mapped", "t"], [[9444, 9444], "mapped", "u"], [[9445, 9445], "mapped", "v"], [[9446, 9446], "mapped", "w"], [[9447, 9447], "mapped", "x"], [[9448, 9448], "mapped", "y"], [[9449, 9449], "mapped", "z"], [[9450, 9450], "mapped", "0"], [[9451, 9470], "valid", "", "NV8"], [[9471, 9471], "valid", "", "NV8"], [[9472, 9621], "valid", "", "NV8"], [[9622, 9631], "valid", "", "NV8"], [[9632, 9711], "valid", "", "NV8"], [[9712, 9719], "valid", "", "NV8"], [[9720, 9727], "valid", "", "NV8"], [[9728, 9747], "valid", "", "NV8"], [[9748, 9749], "valid", "", "NV8"], [[9750, 9751], "valid", "", "NV8"], [[9752, 9752], "valid", "", "NV8"], [[9753, 9753], "valid", "", "NV8"], [[9754, 9839], "valid", "", "NV8"], [[9840, 9841], "valid", "", "NV8"], [[9842, 9853], "valid", "", "NV8"], [[9854, 9855], "valid", "", "NV8"], [[9856, 9865], "valid", "", "NV8"], [[9866, 9873], "valid", "", "NV8"], [[9874, 9884], "valid", "", "NV8"], [[9885, 9885], "valid", "", "NV8"], [[9886, 9887], "valid", "", "NV8"], [[9888, 9889], "valid", "", "NV8"], [[9890, 9905], "valid", "", "NV8"], [[9906, 9906], "valid", "", "NV8"], [[9907, 9916], "valid", "", "NV8"], [[9917, 9919], "valid", "", "NV8"], [[9920, 9923], "valid", "", "NV8"], [[9924, 9933], "valid", "", "NV8"], [[9934, 9934], "valid", "", "NV8"], [[9935, 9953], "valid", "", "NV8"], [[9954, 9954], "valid", "", "NV8"], [[9955, 9955], "valid", "", "NV8"], [[9956, 9959], "valid", "", "NV8"], [[9960, 9983], "valid", "", "NV8"], [[9984, 9984], "valid", "", "NV8"], [[9985, 9988], "valid", "", "NV8"], [[9989, 9989], "valid", "", "NV8"], [[9990, 9993], "valid", "", "NV8"], [[9994, 9995], "valid", "", "NV8"], [[9996, 10023], "valid", "", "NV8"], [[10024, 10024], "valid", "", "NV8"], [[10025, 10059], "valid", "", "NV8"], [[10060, 10060], "valid", "", "NV8"], [[10061, 10061], "valid", "", "NV8"], [[10062, 10062], "valid", "", "NV8"], [[10063, 10066], "valid", "", "NV8"], [[10067, 10069], "valid", "", "NV8"], [[10070, 10070], "valid", "", "NV8"], [[10071, 10071], "valid", "", "NV8"], [[10072, 10078], "valid", "", "NV8"], [[10079, 10080], "valid", "", "NV8"], [[10081, 10087], "valid", "", "NV8"], [[10088, 10101], "valid", "", "NV8"], [[10102, 10132], "valid", "", "NV8"], [[10133, 10135], "valid", "", "NV8"], [[10136, 10159], "valid", "", "NV8"], [[10160, 10160], "valid", "", "NV8"], [[10161, 10174], "valid", "", "NV8"], [[10175, 10175], "valid", "", "NV8"], [[10176, 10182], "valid", "", "NV8"], [[10183, 10186], "valid", "", "NV8"], [[10187, 10187], "valid", "", "NV8"], [[10188, 10188], "valid", "", "NV8"], [[10189, 10189], "valid", "", "NV8"], [[10190, 10191], "valid", "", "NV8"], [[10192, 10219], "valid", "", "NV8"], [[10220, 10223], "valid", "", "NV8"], [[10224, 10239], "valid", "", "NV8"], [[10240, 10495], "valid", "", "NV8"], [[10496, 10763], "valid", "", "NV8"], [[10764, 10764], "mapped", "\u222B\u222B\u222B\u222B"], [[10765, 10867], "valid", "", "NV8"], [[10868, 10868], "disallowed_STD3_mapped", "::="], [[10869, 10869], "disallowed_STD3_mapped", "=="], [[10870, 10870], "disallowed_STD3_mapped", "==="], [[10871, 10971], "valid", "", "NV8"], [[10972, 10972], "mapped", "\u2ADD\u0338"], [[10973, 11007], "valid", "", "NV8"], [[11008, 11021], "valid", "", "NV8"], [[11022, 11027], "valid", "", "NV8"], [[11028, 11034], "valid", "", "NV8"], [[11035, 11039], "valid", "", "NV8"], [[11040, 11043], "valid", "", "NV8"], [[11044, 11084], "valid", "", "NV8"], [[11085, 11087], "valid", "", "NV8"], [[11088, 11092], "valid", "", "NV8"], [[11093, 11097], "valid", "", "NV8"], [[11098, 11123], "valid", "", "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", "", "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", "", "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", "", "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", "", "NV8"], [[11218, 11218], "valid", "", "NV8"], [[11219, 11243], "disallowed"], [[11244, 11247], "valid", "", "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", "\u2C30"], [[11265, 11265], "mapped", "\u2C31"], [[11266, 11266], "mapped", "\u2C32"], [[11267, 11267], "mapped", "\u2C33"], [[11268, 11268], "mapped", "\u2C34"], [[11269, 11269], "mapped", "\u2C35"], [[11270, 11270], "mapped", "\u2C36"], [[11271, 11271], "mapped", "\u2C37"], [[11272, 11272], "mapped", "\u2C38"], [[11273, 11273], "mapped", "\u2C39"], [[11274, 11274], "mapped", "\u2C3A"], [[11275, 11275], "mapped", "\u2C3B"], [[11276, 11276], "mapped", "\u2C3C"], [[11277, 11277], "mapped", "\u2C3D"], [[11278, 11278], "mapped", "\u2C3E"], [[11279, 11279], "mapped", "\u2C3F"], [[11280, 11280], "mapped", "\u2C40"], [[11281, 11281], "mapped", "\u2C41"], [[11282, 11282], "mapped", "\u2C42"], [[11283, 11283], "mapped", "\u2C43"], [[11284, 11284], "mapped", "\u2C44"], [[11285, 11285], "mapped", "\u2C45"], [[11286, 11286], "mapped", "\u2C46"], [[11287, 11287], "mapped", "\u2C47"], [[11288, 11288], "mapped", "\u2C48"], [[11289, 11289], "mapped", "\u2C49"], [[11290, 11290], "mapped", "\u2C4A"], [[11291, 11291], "mapped", "\u2C4B"], [[11292, 11292], "mapped", "\u2C4C"], [[11293, 11293], "mapped", "\u2C4D"], [[11294, 11294], "mapped", "\u2C4E"], [[11295, 11295], "mapped", "\u2C4F"], [[11296, 11296], "mapped", "\u2C50"], [[11297, 11297], "mapped", "\u2C51"], [[11298, 11298], "mapped", "\u2C52"], [[11299, 11299], "mapped", "\u2C53"], [[11300, 11300], "mapped", "\u2C54"], [[11301, 11301], "mapped", "\u2C55"], [[11302, 11302], "mapped", "\u2C56"], [[11303, 11303], "mapped", "\u2C57"], [[11304, 11304], "mapped", "\u2C58"], [[11305, 11305], "mapped", "\u2C59"], [[11306, 11306], "mapped", "\u2C5A"], [[11307, 11307], "mapped", "\u2C5B"], [[11308, 11308], "mapped", "\u2C5C"], [[11309, 11309], "mapped", "\u2C5D"], [[11310, 11310], "mapped", "\u2C5E"], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", "\u2C61"], [[11361, 11361], "valid"], [[11362, 11362], "mapped", "\u026B"], [[11363, 11363], "mapped", "\u1D7D"], [[11364, 11364], "mapped", "\u027D"], [[11365, 11366], "valid"], [[11367, 11367], "mapped", "\u2C68"], [[11368, 11368], "valid"], [[11369, 11369], "mapped", "\u2C6A"], [[11370, 11370], "valid"], [[11371, 11371], "mapped", "\u2C6C"], [[11372, 11372], "valid"], [[11373, 11373], "mapped", "\u0251"], [[11374, 11374], "mapped", "\u0271"], [[11375, 11375], "mapped", "\u0250"], [[11376, 11376], "mapped", "\u0252"], [[11377, 11377], "valid"], [[11378, 11378], "mapped", "\u2C73"], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", "\u2C76"], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", "j"], [[11389, 11389], "mapped", "v"], [[11390, 11390], "mapped", "\u023F"], [[11391, 11391], "mapped", "\u0240"], [[11392, 11392], "mapped", "\u2C81"], [[11393, 11393], "valid"], [[11394, 11394], "mapped", "\u2C83"], [[11395, 11395], "valid"], [[11396, 11396], "mapped", "\u2C85"], [[11397, 11397], "valid"], [[11398, 11398], "mapped", "\u2C87"], [[11399, 11399], "valid"], [[11400, 11400], "mapped", "\u2C89"], [[11401, 11401], "valid"], [[11402, 11402], "mapped", "\u2C8B"], [[11403, 11403], "valid"], [[11404, 11404], "mapped", "\u2C8D"], [[11405, 11405], "valid"], [[11406, 11406], "mapped", "\u2C8F"], [[11407, 11407], "valid"], [[11408, 11408], "mapped", "\u2C91"], [[11409, 11409], "valid"], [[11410, 11410], "mapped", "\u2C93"], [[11411, 11411], "valid"], [[11412, 11412], "mapped", "\u2C95"], [[11413, 11413], "valid"], [[11414, 11414], "mapped", "\u2C97"], [[11415, 11415], "valid"], [[11416, 11416], "mapped", "\u2C99"], [[11417, 11417], "valid"], [[11418, 11418], "mapped", "\u2C9B"], [[11419, 11419], "valid"], [[11420, 11420], "mapped", "\u2C9D"], [[11421, 11421], "valid"], [[11422, 11422], "mapped", "\u2C9F"], [[11423, 11423], "valid"], [[11424, 11424], "mapped", "\u2CA1"], [[11425, 11425], "valid"], [[11426, 11426], "mapped", "\u2CA3"], [[11427, 11427], "valid"], [[11428, 11428], "mapped", "\u2CA5"], [[11429, 11429], "valid"], [[11430, 11430], "mapped", "\u2CA7"], [[11431, 11431], "valid"], [[11432, 11432], "mapped", "\u2CA9"], [[11433, 11433], "valid"], [[11434, 11434], "mapped", "\u2CAB"], [[11435, 11435], "valid"], [[11436, 11436], "mapped", "\u2CAD"], [[11437, 11437], "valid"], [[11438, 11438], "mapped", "\u2CAF"], [[11439, 11439], "valid"], [[11440, 11440], "mapped", "\u2CB1"], [[11441, 11441], "valid"], [[11442, 11442], "mapped", "\u2CB3"], [[11443, 11443], "valid"], [[11444, 11444], "mapped", "\u2CB5"], [[11445, 11445], "valid"], [[11446, 11446], "mapped", "\u2CB7"], [[11447, 11447], "valid"], [[11448, 11448], "mapped", "\u2CB9"], [[11449, 11449], "valid"], [[11450, 11450], "mapped", "\u2CBB"], [[11451, 11451], "valid"], [[11452, 11452], "mapped", "\u2CBD"], [[11453, 11453], "valid"], [[11454, 11454], "mapped", "\u2CBF"], [[11455, 11455], "valid"], [[11456, 11456], "mapped", "\u2CC1"], [[11457, 11457], "valid"], [[11458, 11458], "mapped", "\u2CC3"], [[11459, 11459], "valid"], [[11460, 11460], "mapped", "\u2CC5"], [[11461, 11461], "valid"], [[11462, 11462], "mapped", "\u2CC7"], [[11463, 11463], "valid"], [[11464, 11464], "mapped", "\u2CC9"], [[11465, 11465], "valid"], [[11466, 11466], "mapped", "\u2CCB"], [[11467, 11467], "valid"], [[11468, 11468], "mapped", "\u2CCD"], [[11469, 11469], "valid"], [[11470, 11470], "mapped", "\u2CCF"], [[11471, 11471], "valid"], [[11472, 11472], "mapped", "\u2CD1"], [[11473, 11473], "valid"], [[11474, 11474], "mapped", "\u2CD3"], [[11475, 11475], "valid"], [[11476, 11476], "mapped", "\u2CD5"], [[11477, 11477], "valid"], [[11478, 11478], "mapped", "\u2CD7"], [[11479, 11479], "valid"], [[11480, 11480], "mapped", "\u2CD9"], [[11481, 11481], "valid"], [[11482, 11482], "mapped", "\u2CDB"], [[11483, 11483], "valid"], [[11484, 11484], "mapped", "\u2CDD"], [[11485, 11485], "valid"], [[11486, 11486], "mapped", "\u2CDF"], [[11487, 11487], "valid"], [[11488, 11488], "mapped", "\u2CE1"], [[11489, 11489], "valid"], [[11490, 11490], "mapped", "\u2CE3"], [[11491, 11492], "valid"], [[11493, 11498], "valid", "", "NV8"], [[11499, 11499], "mapped", "\u2CEC"], [[11500, 11500], "valid"], [[11501, 11501], "mapped", "\u2CEE"], [[11502, 11505], "valid"], [[11506, 11506], "mapped", "\u2CF3"], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", "", "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", "\u2D61"], [[11632, 11632], "valid", "", "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", "", "NV8"], [[11800, 11803], "valid", "", "NV8"], [[11804, 11805], "valid", "", "NV8"], [[11806, 11822], "valid", "", "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", "", "NV8"], [[11825, 11825], "valid", "", "NV8"], [[11826, 11835], "valid", "", "NV8"], [[11836, 11842], "valid", "", "NV8"], [[11843, 11844], "valid", "", "NV8"], [[11845, 11849], "valid", "", "NV8"], [[11850, 11903], "disallowed"], [[11904, 11929], "valid", "", "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", "", "NV8"], [[11935, 11935], "mapped", "\u6BCD"], [[11936, 12018], "valid", "", "NV8"], [[12019, 12019], "mapped", "\u9F9F"], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", "\u4E00"], [[12033, 12033], "mapped", "\u4E28"], [[12034, 12034], "mapped", "\u4E36"], [[12035, 12035], "mapped", "\u4E3F"], [[12036, 12036], "mapped", "\u4E59"], [[12037, 12037], "mapped", "\u4E85"], [[12038, 12038], "mapped", "\u4E8C"], [[12039, 12039], "mapped", "\u4EA0"], [[12040, 12040], "mapped", "\u4EBA"], [[12041, 12041], "mapped", "\u513F"], [[12042, 12042], "mapped", "\u5165"], [[12043, 12043], "mapped", "\u516B"], [[12044, 12044], "mapped", "\u5182"], [[12045, 12045], "mapped", "\u5196"], [[12046, 12046], "mapped", "\u51AB"], [[12047, 12047], "mapped", "\u51E0"], [[12048, 12048], "mapped", "\u51F5"], [[12049, 12049], "mapped", "\u5200"], [[12050, 12050], "mapped", "\u529B"], [[12051, 12051], "mapped", "\u52F9"], [[12052, 12052], "mapped", "\u5315"], [[12053, 12053], "mapped", "\u531A"], [[12054, 12054], "mapped", "\u5338"], [[12055, 12055], "mapped", "\u5341"], [[12056, 12056], "mapped", "\u535C"], [[12057, 12057], "mapped", "\u5369"], [[12058, 12058], "mapped", "\u5382"], [[12059, 12059], "mapped", "\u53B6"], [[12060, 12060], "mapped", "\u53C8"], [[12061, 12061], "mapped", "\u53E3"], [[12062, 12062], "mapped", "\u56D7"], [[12063, 12063], "mapped", "\u571F"], [[12064, 12064], "mapped", "\u58EB"], [[12065, 12065], "mapped", "\u5902"], [[12066, 12066], "mapped", "\u590A"], [[12067, 12067], "mapped", "\u5915"], [[12068, 12068], "mapped", "\u5927"], [[12069, 12069], "mapped", "\u5973"], [[12070, 12070], "mapped", "\u5B50"], [[12071, 12071], "mapped", "\u5B80"], [[12072, 12072], "mapped", "\u5BF8"], [[12073, 12073], "mapped", "\u5C0F"], [[12074, 12074], "mapped", "\u5C22"], [[12075, 12075], "mapped", "\u5C38"], [[12076, 12076], "mapped", "\u5C6E"], [[12077, 12077], "mapped", "\u5C71"], [[12078, 12078], "mapped", "\u5DDB"], [[12079, 12079], "mapped", "\u5DE5"], [[12080, 12080], "mapped", "\u5DF1"], [[12081, 12081], "mapped", "\u5DFE"], [[12082, 12082], "mapped", "\u5E72"], [[12083, 12083], "mapped", "\u5E7A"], [[12084, 12084], "mapped", "\u5E7F"], [[12085, 12085], "mapped", "\u5EF4"], [[12086, 12086], "mapped", "\u5EFE"], [[12087, 12087], "mapped", "\u5F0B"], [[12088, 12088], "mapped", "\u5F13"], [[12089, 12089], "mapped", "\u5F50"], [[12090, 12090], "mapped", "\u5F61"], [[12091, 12091], "mapped", "\u5F73"], [[12092, 12092], "mapped", "\u5FC3"], [[12093, 12093], "mapped", "\u6208"], [[12094, 12094], "mapped", "\u6236"], [[12095, 12095], "mapped", "\u624B"], [[12096, 12096], "mapped", "\u652F"], [[12097, 12097], "mapped", "\u6534"], [[12098, 12098], "mapped", "\u6587"], [[12099, 12099], "mapped", "\u6597"], [[12100, 12100], "mapped", "\u65A4"], [[12101, 12101], "mapped", "\u65B9"], [[12102, 12102], "mapped", "\u65E0"], [[12103, 12103], "mapped", "\u65E5"], [[12104, 12104], "mapped", "\u66F0"], [[12105, 12105], "mapped", "\u6708"], [[12106, 12106], "mapped", "\u6728"], [[12107, 12107], "mapped", "\u6B20"], [[12108, 12108], "mapped", "\u6B62"], [[12109, 12109], "mapped", "\u6B79"], [[12110, 12110], "mapped", "\u6BB3"], [[12111, 12111], "mapped", "\u6BCB"], [[12112, 12112], "mapped", "\u6BD4"], [[12113, 12113], "mapped", "\u6BDB"], [[12114, 12114], "mapped", "\u6C0F"], [[12115, 12115], "mapped", "\u6C14"], [[12116, 12116], "mapped", "\u6C34"], [[12117, 12117], "mapped", "\u706B"], [[12118, 12118], "mapped", "\u722A"], [[12119, 12119], "mapped", "\u7236"], [[12120, 12120], "mapped", "\u723B"], [[12121, 12121], "mapped", "\u723F"], [[12122, 12122], "mapped", "\u7247"], [[12123, 12123], "mapped", "\u7259"], [[12124, 12124], "mapped", "\u725B"], [[12125, 12125], "mapped", "\u72AC"], [[12126, 12126], "mapped", "\u7384"], [[12127, 12127], "mapped", "\u7389"], [[12128, 12128], "mapped", "\u74DC"], [[12129, 12129], "mapped", "\u74E6"], [[12130, 12130], "mapped", "\u7518"], [[12131, 12131], "mapped", "\u751F"], [[12132, 12132], "mapped", "\u7528"], [[12133, 12133], "mapped", "\u7530"], [[12134, 12134], "mapped", "\u758B"], [[12135, 12135], "mapped", "\u7592"], [[12136, 12136], "mapped", "\u7676"], [[12137, 12137], "mapped", "\u767D"], [[12138, 12138], "mapped", "\u76AE"], [[12139, 12139], "mapped", "\u76BF"], [[12140, 12140], "mapped", "\u76EE"], [[12141, 12141], "mapped", "\u77DB"], [[12142, 12142], "mapped", "\u77E2"], [[12143, 12143], "mapped", "\u77F3"], [[12144, 12144], "mapped", "\u793A"], [[12145, 12145], "mapped", "\u79B8"], [[12146, 12146], "mapped", "\u79BE"], [[12147, 12147], "mapped", "\u7A74"], [[12148, 12148], "mapped", "\u7ACB"], [[12149, 12149], "mapped", "\u7AF9"], [[12150, 12150], "mapped", "\u7C73"], [[12151, 12151], "mapped", "\u7CF8"], [[12152, 12152], "mapped", "\u7F36"], [[12153, 12153], "mapped", "\u7F51"], [[12154, 12154], "mapped", "\u7F8A"], [[12155, 12155], "mapped", "\u7FBD"], [[12156, 12156], "mapped", "\u8001"], [[12157, 12157], "mapped", "\u800C"], [[12158, 12158], "mapped", "\u8012"], [[12159, 12159], "mapped", "\u8033"], [[12160, 12160], "mapped", "\u807F"], [[12161, 12161], "mapped", "\u8089"], [[12162, 12162], "mapped", "\u81E3"], [[12163, 12163], "mapped", "\u81EA"], [[12164, 12164], "mapped", "\u81F3"], [[12165, 12165], "mapped", "\u81FC"], [[12166, 12166], "mapped", "\u820C"], [[12167, 12167], "mapped", "\u821B"], [[12168, 12168], "mapped", "\u821F"], [[12169, 12169], "mapped", "\u826E"], [[12170, 12170], "mapped", "\u8272"], [[12171, 12171], "mapped", "\u8278"], [[12172, 12172], "mapped", "\u864D"], [[12173, 12173], "mapped", "\u866B"], [[12174, 12174], "mapped", "\u8840"], [[12175, 12175], "mapped", "\u884C"], [[12176, 12176], "mapped", "\u8863"], [[12177, 12177], "mapped", "\u897E"], [[12178, 12178], "mapped", "\u898B"], [[12179, 12179], "mapped", "\u89D2"], [[12180, 12180], "mapped", "\u8A00"], [[12181, 12181], "mapped", "\u8C37"], [[12182, 12182], "mapped", "\u8C46"], [[12183, 12183], "mapped", "\u8C55"], [[12184, 12184], "mapped", "\u8C78"], [[12185, 12185], "mapped", "\u8C9D"], [[12186, 12186], "mapped", "\u8D64"], [[12187, 12187], "mapped", "\u8D70"], [[12188, 12188], "mapped", "\u8DB3"], [[12189, 12189], "mapped", "\u8EAB"], [[12190, 12190], "mapped", "\u8ECA"], [[12191, 12191], "mapped", "\u8F9B"], [[12192, 12192], "mapped", "\u8FB0"], [[12193, 12193], "mapped", "\u8FB5"], [[12194, 12194], "mapped", "\u9091"], [[12195, 12195], "mapped", "\u9149"], [[12196, 12196], "mapped", "\u91C6"], [[12197, 12197], "mapped", "\u91CC"], [[12198, 12198], "mapped", "\u91D1"], [[12199, 12199], "mapped", "\u9577"], [[12200, 12200], "mapped", "\u9580"], [[12201, 12201], "mapped", "\u961C"], [[12202, 12202], "mapped", "\u96B6"], [[12203, 12203], "mapped", "\u96B9"], [[12204, 12204], "mapped", "\u96E8"], [[12205, 12205], "mapped", "\u9751"], [[12206, 12206], "mapped", "\u975E"], [[12207, 12207], "mapped", "\u9762"], [[12208, 12208], "mapped", "\u9769"], [[12209, 12209], "mapped", "\u97CB"], [[12210, 12210], "mapped", "\u97ED"], [[12211, 12211], "mapped", "\u97F3"], [[12212, 12212], "mapped", "\u9801"], [[12213, 12213], "mapped", "\u98A8"], [[12214, 12214], "mapped", "\u98DB"], [[12215, 12215], "mapped", "\u98DF"], [[12216, 12216], "mapped", "\u9996"], [[12217, 12217], "mapped", "\u9999"], [[12218, 12218], "mapped", "\u99AC"], [[12219, 12219], "mapped", "\u9AA8"], [[12220, 12220], "mapped", "\u9AD8"], [[12221, 12221], "mapped", "\u9ADF"], [[12222, 12222], "mapped", "\u9B25"], [[12223, 12223], "mapped", "\u9B2F"], [[12224, 12224], "mapped", "\u9B32"], [[12225, 12225], "mapped", "\u9B3C"], [[12226, 12226], "mapped", "\u9B5A"], [[12227, 12227], "mapped", "\u9CE5"], [[12228, 12228], "mapped", "\u9E75"], [[12229, 12229], "mapped", "\u9E7F"], [[12230, 12230], "mapped", "\u9EA5"], [[12231, 12231], "mapped", "\u9EBB"], [[12232, 12232], "mapped", "\u9EC3"], [[12233, 12233], "mapped", "\u9ECD"], [[12234, 12234], "mapped", "\u9ED1"], [[12235, 12235], "mapped", "\u9EF9"], [[12236, 12236], "mapped", "\u9EFD"], [[12237, 12237], "mapped", "\u9F0E"], [[12238, 12238], "mapped", "\u9F13"], [[12239, 12239], "mapped", "\u9F20"], [[12240, 12240], "mapped", "\u9F3B"], [[12241, 12241], "mapped", "\u9F4A"], [[12242, 12242], "mapped", "\u9F52"], [[12243, 12243], "mapped", "\u9F8D"], [[12244, 12244], "mapped", "\u9F9C"], [[12245, 12245], "mapped", "\u9FA0"], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", " "], [[12289, 12289], "valid", "", "NV8"], [[12290, 12290], "mapped", "."], [[12291, 12292], "valid", "", "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", "", "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", "", "NV8"], [[12342, 12342], "mapped", "\u3012"], [[12343, 12343], "valid", "", "NV8"], [[12344, 12344], "mapped", "\u5341"], [[12345, 12345], "mapped", "\u5344"], [[12346, 12346], "mapped", "\u5345"], [[12347, 12347], "valid", "", "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", "", "NV8"], [[12350, 12350], "valid", "", "NV8"], [[12351, 12351], "valid", "", "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", " \u3099"], [[12444, 12444], "disallowed_STD3_mapped", " \u309A"], [[12445, 12446], "valid"], [[12447, 12447], "mapped", "\u3088\u308A"], [[12448, 12448], "valid", "", "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", "\u30B3\u30C8"], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12590], "valid"], [[12591, 12592], "disallowed"], [[12593, 12593], "mapped", "\u1100"], [[12594, 12594], "mapped", "\u1101"], [[12595, 12595], "mapped", "\u11AA"], [[12596, 12596], "mapped", "\u1102"], [[12597, 12597], "mapped", "\u11AC"], [[12598, 12598], "mapped", "\u11AD"], [[12599, 12599], "mapped", "\u1103"], [[12600, 12600], "mapped", "\u1104"], [[12601, 12601], "mapped", "\u1105"], [[12602, 12602], "mapped", "\u11B0"], [[12603, 12603], "mapped", "\u11B1"], [[12604, 12604], "mapped", "\u11B2"], [[12605, 12605], "mapped", "\u11B3"], [[12606, 12606], "mapped", "\u11B4"], [[12607, 12607], "mapped", "\u11B5"], [[12608, 12608], "mapped", "\u111A"], [[12609, 12609], "mapped", "\u1106"], [[12610, 12610], "mapped", "\u1107"], [[12611, 12611], "mapped", "\u1108"], [[12612, 12612], "mapped", "\u1121"], [[12613, 12613], "mapped", "\u1109"], [[12614, 12614], "mapped", "\u110A"], [[12615, 12615], "mapped", "\u110B"], [[12616, 12616], "mapped", "\u110C"], [[12617, 12617], "mapped", "\u110D"], [[12618, 12618], "mapped", "\u110E"], [[12619, 12619], "mapped", "\u110F"], [[12620, 12620], "mapped", "\u1110"], [[12621, 12621], "mapped", "\u1111"], [[12622, 12622], "mapped", "\u1112"], [[12623, 12623], "mapped", "\u1161"], [[12624, 12624], "mapped", "\u1162"], [[12625, 12625], "mapped", "\u1163"], [[12626, 12626], "mapped", "\u1164"], [[12627, 12627], "mapped", "\u1165"], [[12628, 12628], "mapped", "\u1166"], [[12629, 12629], "mapped", "\u1167"], [[12630, 12630], "mapped", "\u1168"], [[12631, 12631], "mapped", "\u1169"], [[12632, 12632], "mapped", "\u116A"], [[12633, 12633], "mapped", "\u116B"], [[12634, 12634], "mapped", "\u116C"], [[12635, 12635], "mapped", "\u116D"], [[12636, 12636], "mapped", "\u116E"], [[12637, 12637], "mapped", "\u116F"], [[12638, 12638], "mapped", "\u1170"], [[12639, 12639], "mapped", "\u1171"], [[12640, 12640], "mapped", "\u1172"], [[12641, 12641], "mapped", "\u1173"], [[12642, 12642], "mapped", "\u1174"], [[12643, 12643], "mapped", "\u1175"], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", "\u1114"], [[12646, 12646], "mapped", "\u1115"], [[12647, 12647], "mapped", "\u11C7"], [[12648, 12648], "mapped", "\u11C8"], [[12649, 12649], "mapped", "\u11CC"], [[12650, 12650], "mapped", "\u11CE"], [[12651, 12651], "mapped", "\u11D3"], [[12652, 12652], "mapped", "\u11D7"], [[12653, 12653], "mapped", "\u11D9"], [[12654, 12654], "mapped", "\u111C"], [[12655, 12655], "mapped", "\u11DD"], [[12656, 12656], "mapped", "\u11DF"], [[12657, 12657], "mapped", "\u111D"], [[12658, 12658], "mapped", "\u111E"], [[12659, 12659], "mapped", "\u1120"], [[12660, 12660], "mapped", "\u1122"], [[12661, 12661], "mapped", "\u1123"], [[12662, 12662], "mapped", "\u1127"], [[12663, 12663], "mapped", "\u1129"], [[12664, 12664], "mapped", "\u112B"], [[12665, 12665], "mapped", "\u112C"], [[12666, 12666], "mapped", "\u112D"], [[12667, 12667], "mapped", "\u112E"], [[12668, 12668], "mapped", "\u112F"], [[12669, 12669], "mapped", "\u1132"], [[12670, 12670], "mapped", "\u1136"], [[12671, 12671], "mapped", "\u1140"], [[12672, 12672], "mapped", "\u1147"], [[12673, 12673], "mapped", "\u114C"], [[12674, 12674], "mapped", "\u11F1"], [[12675, 12675], "mapped", "\u11F2"], [[12676, 12676], "mapped", "\u1157"], [[12677, 12677], "mapped", "\u1158"], [[12678, 12678], "mapped", "\u1159"], [[12679, 12679], "mapped", "\u1184"], [[12680, 12680], "mapped", "\u1185"], [[12681, 12681], "mapped", "\u1188"], [[12682, 12682], "mapped", "\u1191"], [[12683, 12683], "mapped", "\u1192"], [[12684, 12684], "mapped", "\u1194"], [[12685, 12685], "mapped", "\u119E"], [[12686, 12686], "mapped", "\u11A1"], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", "", "NV8"], [[12690, 12690], "mapped", "\u4E00"], [[12691, 12691], "mapped", "\u4E8C"], [[12692, 12692], "mapped", "\u4E09"], [[12693, 12693], "mapped", "\u56DB"], [[12694, 12694], "mapped", "\u4E0A"], [[12695, 12695], "mapped", "\u4E2D"], [[12696, 12696], "mapped", "\u4E0B"], [[12697, 12697], "mapped", "\u7532"], [[12698, 12698], "mapped", "\u4E59"], [[12699, 12699], "mapped", "\u4E19"], [[12700, 12700], "mapped", "\u4E01"], [[12701, 12701], "mapped", "\u5929"], [[12702, 12702], "mapped", "\u5730"], [[12703, 12703], "mapped", "\u4EBA"], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", "", "NV8"], [[12752, 12771], "valid", "", "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", "(\u1100)"], [[12801, 12801], "disallowed_STD3_mapped", "(\u1102)"], [[12802, 12802], "disallowed_STD3_mapped", "(\u1103)"], [[12803, 12803], "disallowed_STD3_mapped", "(\u1105)"], [[12804, 12804], "disallowed_STD3_mapped", "(\u1106)"], [[12805, 12805], "disallowed_STD3_mapped", "(\u1107)"], [[12806, 12806], "disallowed_STD3_mapped", "(\u1109)"], [[12807, 12807], "disallowed_STD3_mapped", "(\u110B)"], [[12808, 12808], "disallowed_STD3_mapped", "(\u110C)"], [[12809, 12809], "disallowed_STD3_mapped", "(\u110E)"], [[12810, 12810], "disallowed_STD3_mapped", "(\u110F)"], [[12811, 12811], "disallowed_STD3_mapped", "(\u1110)"], [[12812, 12812], "disallowed_STD3_mapped", "(\u1111)"], [[12813, 12813], "disallowed_STD3_mapped", "(\u1112)"], [[12814, 12814], "disallowed_STD3_mapped", "(\uAC00)"], [[12815, 12815], "disallowed_STD3_mapped", "(\uB098)"], [[12816, 12816], "disallowed_STD3_mapped", "(\uB2E4)"], [[12817, 12817], "disallowed_STD3_mapped", "(\uB77C)"], [[12818, 12818], "disallowed_STD3_mapped", "(\uB9C8)"], [[12819, 12819], "disallowed_STD3_mapped", "(\uBC14)"], [[12820, 12820], "disallowed_STD3_mapped", "(\uC0AC)"], [[12821, 12821], "disallowed_STD3_mapped", "(\uC544)"], [[12822, 12822], "disallowed_STD3_mapped", "(\uC790)"], [[12823, 12823], "disallowed_STD3_mapped", "(\uCC28)"], [[12824, 12824], "disallowed_STD3_mapped", "(\uCE74)"], [[12825, 12825], "disallowed_STD3_mapped", "(\uD0C0)"], [[12826, 12826], "disallowed_STD3_mapped", "(\uD30C)"], [[12827, 12827], "disallowed_STD3_mapped", "(\uD558)"], [[12828, 12828], "disallowed_STD3_mapped", "(\uC8FC)"], [[12829, 12829], "disallowed_STD3_mapped", "(\uC624\uC804)"], [[12830, 12830], "disallowed_STD3_mapped", "(\uC624\uD6C4)"], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", "(\u4E00)"], [[12833, 12833], "disallowed_STD3_mapped", "(\u4E8C)"], [[12834, 12834], "disallowed_STD3_mapped", "(\u4E09)"], [[12835, 12835], "disallowed_STD3_mapped", "(\u56DB)"], [[12836, 12836], "disallowed_STD3_mapped", "(\u4E94)"], [[12837, 12837], "disallowed_STD3_mapped", "(\u516D)"], [[12838, 12838], "disallowed_STD3_mapped", "(\u4E03)"], [[12839, 12839], "disallowed_STD3_mapped", "(\u516B)"], [[12840, 12840], "disallowed_STD3_mapped", "(\u4E5D)"], [[12841, 12841], "disallowed_STD3_mapped", "(\u5341)"], [[12842, 12842], "disallowed_STD3_mapped", "(\u6708)"], [[12843, 12843], "disallowed_STD3_mapped", "(\u706B)"], [[12844, 12844], "disallowed_STD3_mapped", "(\u6C34)"], [[12845, 12845], "disallowed_STD3_mapped", "(\u6728)"], [[12846, 12846], "disallowed_STD3_mapped", "(\u91D1)"], [[12847, 12847], "disallowed_STD3_mapped", "(\u571F)"], [[12848, 12848], "disallowed_STD3_mapped", "(\u65E5)"], [[12849, 12849], "disallowed_STD3_mapped", "(\u682A)"], [[12850, 12850], "disallowed_STD3_mapped", "(\u6709)"], [[12851, 12851], "disallowed_STD3_mapped", "(\u793E)"], [[12852, 12852], "disallowed_STD3_mapped", "(\u540D)"], [[12853, 12853], "disallowed_STD3_mapped", "(\u7279)"], [[12854, 12854], "disallowed_STD3_mapped", "(\u8CA1)"], [[12855, 12855], "disallowed_STD3_mapped", "(\u795D)"], [[12856, 12856], "disallowed_STD3_mapped", "(\u52B4)"], [[12857, 12857], "disallowed_STD3_mapped", "(\u4EE3)"], [[12858, 12858], "disallowed_STD3_mapped", "(\u547C)"], [[12859, 12859], "disallowed_STD3_mapped", "(\u5B66)"], [[12860, 12860], "disallowed_STD3_mapped", "(\u76E3)"], [[12861, 12861], "disallowed_STD3_mapped", "(\u4F01)"], [[12862, 12862], "disallowed_STD3_mapped", "(\u8CC7)"], [[12863, 12863], "disallowed_STD3_mapped", "(\u5354)"], [[12864, 12864], "disallowed_STD3_mapped", "(\u796D)"], [[12865, 12865], "disallowed_STD3_mapped", "(\u4F11)"], [[12866, 12866], "disallowed_STD3_mapped", "(\u81EA)"], [[12867, 12867], "disallowed_STD3_mapped", "(\u81F3)"], [[12868, 12868], "mapped", "\u554F"], [[12869, 12869], "mapped", "\u5E7C"], [[12870, 12870], "mapped", "\u6587"], [[12871, 12871], "mapped", "\u7B8F"], [[12872, 12879], "valid", "", "NV8"], [[12880, 12880], "mapped", "pte"], [[12881, 12881], "mapped", "21"], [[12882, 12882], "mapped", "22"], [[12883, 12883], "mapped", "23"], [[12884, 12884], "mapped", "24"], [[12885, 12885], "mapped", "25"], [[12886, 12886], "mapped", "26"], [[12887, 12887], "mapped", "27"], [[12888, 12888], "mapped", "28"], [[12889, 12889], "mapped", "29"], [[12890, 12890], "mapped", "30"], [[12891, 12891], "mapped", "31"], [[12892, 12892], "mapped", "32"], [[12893, 12893], "mapped", "33"], [[12894, 12894], "mapped", "34"], [[12895, 12895], "mapped", "35"], [[12896, 12896], "mapped", "\u1100"], [[12897, 12897], "mapped", "\u1102"], [[12898, 12898], "mapped", "\u1103"], [[12899, 12899], "mapped", "\u1105"], [[12900, 12900], "mapped", "\u1106"], [[12901, 12901], "mapped", "\u1107"], [[12902, 12902], "mapped", "\u1109"], [[12903, 12903], "mapped", "\u110B"], [[12904, 12904], "mapped", "\u110C"], [[12905, 12905], "mapped", "\u110E"], [[12906, 12906], "mapped", "\u110F"], [[12907, 12907], "mapped", "\u1110"], [[12908, 12908], "mapped", "\u1111"], [[12909, 12909], "mapped", "\u1112"], [[12910, 12910], "mapped", "\uAC00"], [[12911, 12911], "mapped", "\uB098"], [[12912, 12912], "mapped", "\uB2E4"], [[12913, 12913], "mapped", "\uB77C"], [[12914, 12914], "mapped", "\uB9C8"], [[12915, 12915], "mapped", "\uBC14"], [[12916, 12916], "mapped", "\uC0AC"], [[12917, 12917], "mapped", "\uC544"], [[12918, 12918], "mapped", "\uC790"], [[12919, 12919], "mapped", "\uCC28"], [[12920, 12920], "mapped", "\uCE74"], [[12921, 12921], "mapped", "\uD0C0"], [[12922, 12922], "mapped", "\uD30C"], [[12923, 12923], "mapped", "\uD558"], [[12924, 12924], "mapped", "\uCC38\uACE0"], [[12925, 12925], "mapped", "\uC8FC\uC758"], [[12926, 12926], "mapped", "\uC6B0"], [[12927, 12927], "valid", "", "NV8"], [[12928, 12928], "mapped", "\u4E00"], [[12929, 12929], "mapped", "\u4E8C"], [[12930, 12930], "mapped", "\u4E09"], [[12931, 12931], "mapped", "\u56DB"], [[12932, 12932], "mapped", "\u4E94"], [[12933, 12933], "mapped", "\u516D"], [[12934, 12934], "mapped", "\u4E03"], [[12935, 12935], "mapped", "\u516B"], [[12936, 12936], "mapped", "\u4E5D"], [[12937, 12937], "mapped", "\u5341"], [[12938, 12938], "mapped", "\u6708"], [[12939, 12939], "mapped", "\u706B"], [[12940, 12940], "mapped", "\u6C34"], [[12941, 12941], "mapped", "\u6728"], [[12942, 12942], "mapped", "\u91D1"], [[12943, 12943], "mapped", "\u571F"], [[12944, 12944], "mapped", "\u65E5"], [[12945, 12945], "mapped", "\u682A"], [[12946, 12946], "mapped", "\u6709"], [[12947, 12947], "mapped", "\u793E"], [[12948, 12948], "mapped", "\u540D"], [[12949, 12949], "mapped", "\u7279"], [[12950, 12950], "mapped", "\u8CA1"], [[12951, 12951], "mapped", "\u795D"], [[12952, 12952], "mapped", "\u52B4"], [[12953, 12953], "mapped", "\u79D8"], [[12954, 12954], "mapped", "\u7537"], [[12955, 12955], "mapped", "\u5973"], [[12956, 12956], "mapped", "\u9069"], [[12957, 12957], "mapped", "\u512A"], [[12958, 12958], "mapped", "\u5370"], [[12959, 12959], "mapped", "\u6CE8"], [[12960, 12960], "mapped", "\u9805"], [[12961, 12961], "mapped", "\u4F11"], [[12962, 12962], "mapped", "\u5199"], [[12963, 12963], "mapped", "\u6B63"], [[12964, 12964], "mapped", "\u4E0A"], [[12965, 12965], "mapped", "\u4E2D"], [[12966, 12966], "mapped", "\u4E0B"], [[12967, 12967], "mapped", "\u5DE6"], [[12968, 12968], "mapped", "\u53F3"], [[12969, 12969], "mapped", "\u533B"], [[12970, 12970], "mapped", "\u5B97"], [[12971, 12971], "mapped", "\u5B66"], [[12972, 12972], "mapped", "\u76E3"], [[12973, 12973], "mapped", "\u4F01"], [[12974, 12974], "mapped", "\u8CC7"], [[12975, 12975], "mapped", "\u5354"], [[12976, 12976], "mapped", "\u591C"], [[12977, 12977], "mapped", "36"], [[12978, 12978], "mapped", "37"], [[12979, 12979], "mapped", "38"], [[12980, 12980], "mapped", "39"], [[12981, 12981], "mapped", "40"], [[12982, 12982], "mapped", "41"], [[12983, 12983], "mapped", "42"], [[12984, 12984], "mapped", "43"], [[12985, 12985], "mapped", "44"], [[12986, 12986], "mapped", "45"], [[12987, 12987], "mapped", "46"], [[12988, 12988], "mapped", "47"], [[12989, 12989], "mapped", "48"], [[12990, 12990], "mapped", "49"], [[12991, 12991], "mapped", "50"], [[12992, 12992], "mapped", "1\u6708"], [[12993, 12993], "mapped", "2\u6708"], [[12994, 12994], "mapped", "3\u6708"], [[12995, 12995], "mapped", "4\u6708"], [[12996, 12996], "mapped", "5\u6708"], [[12997, 12997], "mapped", "6\u6708"], [[12998, 12998], "mapped", "7\u6708"], [[12999, 12999], "mapped", "8\u6708"], [[13e3, 13e3], "mapped", "9\u6708"], [[13001, 13001], "mapped", "10\u6708"], [[13002, 13002], "mapped", "11\u6708"], [[13003, 13003], "mapped", "12\u6708"], [[13004, 13004], "mapped", "hg"], [[13005, 13005], "mapped", "erg"], [[13006, 13006], "mapped", "ev"], [[13007, 13007], "mapped", "ltd"], [[13008, 13008], "mapped", "\u30A2"], [[13009, 13009], "mapped", "\u30A4"], [[13010, 13010], "mapped", "\u30A6"], [[13011, 13011], "mapped", "\u30A8"], [[13012, 13012], "mapped", "\u30AA"], [[13013, 13013], "mapped", "\u30AB"], [[13014, 13014], "mapped", "\u30AD"], [[13015, 13015], "mapped", "\u30AF"], [[13016, 13016], "mapped", "\u30B1"], [[13017, 13017], "mapped", "\u30B3"], [[13018, 13018], "mapped", "\u30B5"], [[13019, 13019], "mapped", "\u30B7"], [[13020, 13020], "mapped", "\u30B9"], [[13021, 13021], "mapped", "\u30BB"], [[13022, 13022], "mapped", "\u30BD"], [[13023, 13023], "mapped", "\u30BF"], [[13024, 13024], "mapped", "\u30C1"], [[13025, 13025], "mapped", "\u30C4"], [[13026, 13026], "mapped", "\u30C6"], [[13027, 13027], "mapped", "\u30C8"], [[13028, 13028], "mapped", "\u30CA"], [[13029, 13029], "mapped", "\u30CB"], [[13030, 13030], "mapped", "\u30CC"], [[13031, 13031], "mapped", "\u30CD"], [[13032, 13032], "mapped", "\u30CE"], [[13033, 13033], "mapped", "\u30CF"], [[13034, 13034], "mapped", "\u30D2"], [[13035, 13035], "mapped", "\u30D5"], [[13036, 13036], "mapped", "\u30D8"], [[13037, 13037], "mapped", "\u30DB"], [[13038, 13038], "mapped", "\u30DE"], [[13039, 13039], "mapped", "\u30DF"], [[13040, 13040], "mapped", "\u30E0"], [[13041, 13041], "mapped", "\u30E1"], [[13042, 13042], "mapped", "\u30E2"], [[13043, 13043], "mapped", "\u30E4"], [[13044, 13044], "mapped", "\u30E6"], [[13045, 13045], "mapped", "\u30E8"], [[13046, 13046], "mapped", "\u30E9"], [[13047, 13047], "mapped", "\u30EA"], [[13048, 13048], "mapped", "\u30EB"], [[13049, 13049], "mapped", "\u30EC"], [[13050, 13050], "mapped", "\u30ED"], [[13051, 13051], "mapped", "\u30EF"], [[13052, 13052], "mapped", "\u30F0"], [[13053, 13053], "mapped", "\u30F1"], [[13054, 13054], "mapped", "\u30F2"], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", "\u30A2\u30D1\u30FC\u30C8"], [[13057, 13057], "mapped", "\u30A2\u30EB\u30D5\u30A1"], [[13058, 13058], "mapped", "\u30A2\u30F3\u30DA\u30A2"], [[13059, 13059], "mapped", "\u30A2\u30FC\u30EB"], [[13060, 13060], "mapped", "\u30A4\u30CB\u30F3\u30B0"], [[13061, 13061], "mapped", "\u30A4\u30F3\u30C1"], [[13062, 13062], "mapped", "\u30A6\u30A9\u30F3"], [[13063, 13063], "mapped", "\u30A8\u30B9\u30AF\u30FC\u30C9"], [[13064, 13064], "mapped", "\u30A8\u30FC\u30AB\u30FC"], [[13065, 13065], "mapped", "\u30AA\u30F3\u30B9"], [[13066, 13066], "mapped", "\u30AA\u30FC\u30E0"], [[13067, 13067], "mapped", "\u30AB\u30A4\u30EA"], [[13068, 13068], "mapped", "\u30AB\u30E9\u30C3\u30C8"], [[13069, 13069], "mapped", "\u30AB\u30ED\u30EA\u30FC"], [[13070, 13070], "mapped", "\u30AC\u30ED\u30F3"], [[13071, 13071], "mapped", "\u30AC\u30F3\u30DE"], [[13072, 13072], "mapped", "\u30AE\u30AC"], [[13073, 13073], "mapped", "\u30AE\u30CB\u30FC"], [[13074, 13074], "mapped", "\u30AD\u30E5\u30EA\u30FC"], [[13075, 13075], "mapped", "\u30AE\u30EB\u30C0\u30FC"], [[13076, 13076], "mapped", "\u30AD\u30ED"], [[13077, 13077], "mapped", "\u30AD\u30ED\u30B0\u30E9\u30E0"], [[13078, 13078], "mapped", "\u30AD\u30ED\u30E1\u30FC\u30C8\u30EB"], [[13079, 13079], "mapped", "\u30AD\u30ED\u30EF\u30C3\u30C8"], [[13080, 13080], "mapped", "\u30B0\u30E9\u30E0"], [[13081, 13081], "mapped", "\u30B0\u30E9\u30E0\u30C8\u30F3"], [[13082, 13082], "mapped", "\u30AF\u30EB\u30BC\u30A4\u30ED"], [[13083, 13083], "mapped", "\u30AF\u30ED\u30FC\u30CD"], [[13084, 13084], "mapped", "\u30B1\u30FC\u30B9"], [[13085, 13085], "mapped", "\u30B3\u30EB\u30CA"], [[13086, 13086], "mapped", "\u30B3\u30FC\u30DD"], [[13087, 13087], "mapped", "\u30B5\u30A4\u30AF\u30EB"], [[13088, 13088], "mapped", "\u30B5\u30F3\u30C1\u30FC\u30E0"], [[13089, 13089], "mapped", "\u30B7\u30EA\u30F3\u30B0"], [[13090, 13090], "mapped", "\u30BB\u30F3\u30C1"], [[13091, 13091], "mapped", "\u30BB\u30F3\u30C8"], [[13092, 13092], "mapped", "\u30C0\u30FC\u30B9"], [[13093, 13093], "mapped", "\u30C7\u30B7"], [[13094, 13094], "mapped", "\u30C9\u30EB"], [[13095, 13095], "mapped", "\u30C8\u30F3"], [[13096, 13096], "mapped", "\u30CA\u30CE"], [[13097, 13097], "mapped", "\u30CE\u30C3\u30C8"], [[13098, 13098], "mapped", "\u30CF\u30A4\u30C4"], [[13099, 13099], "mapped", "\u30D1\u30FC\u30BB\u30F3\u30C8"], [[13100, 13100], "mapped", "\u30D1\u30FC\u30C4"], [[13101, 13101], "mapped", "\u30D0\u30FC\u30EC\u30EB"], [[13102, 13102], "mapped", "\u30D4\u30A2\u30B9\u30C8\u30EB"], [[13103, 13103], "mapped", "\u30D4\u30AF\u30EB"], [[13104, 13104], "mapped", "\u30D4\u30B3"], [[13105, 13105], "mapped", "\u30D3\u30EB"], [[13106, 13106], "mapped", "\u30D5\u30A1\u30E9\u30C3\u30C9"], [[13107, 13107], "mapped", "\u30D5\u30A3\u30FC\u30C8"], [[13108, 13108], "mapped", "\u30D6\u30C3\u30B7\u30A7\u30EB"], [[13109, 13109], "mapped", "\u30D5\u30E9\u30F3"], [[13110, 13110], "mapped", "\u30D8\u30AF\u30BF\u30FC\u30EB"], [[13111, 13111], "mapped", "\u30DA\u30BD"], [[13112, 13112], "mapped", "\u30DA\u30CB\u30D2"], [[13113, 13113], "mapped", "\u30D8\u30EB\u30C4"], [[13114, 13114], "mapped", "\u30DA\u30F3\u30B9"], [[13115, 13115], "mapped", "\u30DA\u30FC\u30B8"], [[13116, 13116], "mapped", "\u30D9\u30FC\u30BF"], [[13117, 13117], "mapped", "\u30DD\u30A4\u30F3\u30C8"], [[13118, 13118], "mapped", "\u30DC\u30EB\u30C8"], [[13119, 13119], "mapped", "\u30DB\u30F3"], [[13120, 13120], "mapped", "\u30DD\u30F3\u30C9"], [[13121, 13121], "mapped", "\u30DB\u30FC\u30EB"], [[13122, 13122], "mapped", "\u30DB\u30FC\u30F3"], [[13123, 13123], "mapped", "\u30DE\u30A4\u30AF\u30ED"], [[13124, 13124], "mapped", "\u30DE\u30A4\u30EB"], [[13125, 13125], "mapped", "\u30DE\u30C3\u30CF"], [[13126, 13126], "mapped", "\u30DE\u30EB\u30AF"], [[13127, 13127], "mapped", "\u30DE\u30F3\u30B7\u30E7\u30F3"], [[13128, 13128], "mapped", "\u30DF\u30AF\u30ED\u30F3"], [[13129, 13129], "mapped", "\u30DF\u30EA"], [[13130, 13130], "mapped", "\u30DF\u30EA\u30D0\u30FC\u30EB"], [[13131, 13131], "mapped", "\u30E1\u30AC"], [[13132, 13132], "mapped", "\u30E1\u30AC\u30C8\u30F3"], [[13133, 13133], "mapped", "\u30E1\u30FC\u30C8\u30EB"], [[13134, 13134], "mapped", "\u30E4\u30FC\u30C9"], [[13135, 13135], "mapped", "\u30E4\u30FC\u30EB"], [[13136, 13136], "mapped", "\u30E6\u30A2\u30F3"], [[13137, 13137], "mapped", "\u30EA\u30C3\u30C8\u30EB"], [[13138, 13138], "mapped", "\u30EA\u30E9"], [[13139, 13139], "mapped", "\u30EB\u30D4\u30FC"], [[13140, 13140], "mapped", "\u30EB\u30FC\u30D6\u30EB"], [[13141, 13141], "mapped", "\u30EC\u30E0"], [[13142, 13142], "mapped", "\u30EC\u30F3\u30C8\u30B2\u30F3"], [[13143, 13143], "mapped", "\u30EF\u30C3\u30C8"], [[13144, 13144], "mapped", "0\u70B9"], [[13145, 13145], "mapped", "1\u70B9"], [[13146, 13146], "mapped", "2\u70B9"], [[13147, 13147], "mapped", "3\u70B9"], [[13148, 13148], "mapped", "4\u70B9"], [[13149, 13149], "mapped", "5\u70B9"], [[13150, 13150], "mapped", "6\u70B9"], [[13151, 13151], "mapped", "7\u70B9"], [[13152, 13152], "mapped", "8\u70B9"], [[13153, 13153], "mapped", "9\u70B9"], [[13154, 13154], "mapped", "10\u70B9"], [[13155, 13155], "mapped", "11\u70B9"], [[13156, 13156], "mapped", "12\u70B9"], [[13157, 13157], "mapped", "13\u70B9"], [[13158, 13158], "mapped", "14\u70B9"], [[13159, 13159], "mapped", "15\u70B9"], [[13160, 13160], "mapped", "16\u70B9"], [[13161, 13161], "mapped", "17\u70B9"], [[13162, 13162], "mapped", "18\u70B9"], [[13163, 13163], "mapped", "19\u70B9"], [[13164, 13164], "mapped", "20\u70B9"], [[13165, 13165], "mapped", "21\u70B9"], [[13166, 13166], "mapped", "22\u70B9"], [[13167, 13167], "mapped", "23\u70B9"], [[13168, 13168], "mapped", "24\u70B9"], [[13169, 13169], "mapped", "hpa"], [[13170, 13170], "mapped", "da"], [[13171, 13171], "mapped", "au"], [[13172, 13172], "mapped", "bar"], [[13173, 13173], "mapped", "ov"], [[13174, 13174], "mapped", "pc"], [[13175, 13175], "mapped", "dm"], [[13176, 13176], "mapped", "dm2"], [[13177, 13177], "mapped", "dm3"], [[13178, 13178], "mapped", "iu"], [[13179, 13179], "mapped", "\u5E73\u6210"], [[13180, 13180], "mapped", "\u662D\u548C"], [[13181, 13181], "mapped", "\u5927\u6B63"], [[13182, 13182], "mapped", "\u660E\u6CBB"], [[13183, 13183], "mapped", "\u682A\u5F0F\u4F1A\u793E"], [[13184, 13184], "mapped", "pa"], [[13185, 13185], "mapped", "na"], [[13186, 13186], "mapped", "\u03BCa"], [[13187, 13187], "mapped", "ma"], [[13188, 13188], "mapped", "ka"], [[13189, 13189], "mapped", "kb"], [[13190, 13190], "mapped", "mb"], [[13191, 13191], "mapped", "gb"], [[13192, 13192], "mapped", "cal"], [[13193, 13193], "mapped", "kcal"], [[13194, 13194], "mapped", "pf"], [[13195, 13195], "mapped", "nf"], [[13196, 13196], "mapped", "\u03BCf"], [[13197, 13197], "mapped", "\u03BCg"], [[13198, 13198], "mapped", "mg"], [[13199, 13199], "mapped", "kg"], [[13200, 13200], "mapped", "hz"], [[13201, 13201], "mapped", "khz"], [[13202, 13202], "mapped", "mhz"], [[13203, 13203], "mapped", "ghz"], [[13204, 13204], "mapped", "thz"], [[13205, 13205], "mapped", "\u03BCl"], [[13206, 13206], "mapped", "ml"], [[13207, 13207], "mapped", "dl"], [[13208, 13208], "mapped", "kl"], [[13209, 13209], "mapped", "fm"], [[13210, 13210], "mapped", "nm"], [[13211, 13211], "mapped", "\u03BCm"], [[13212, 13212], "mapped", "mm"], [[13213, 13213], "mapped", "cm"], [[13214, 13214], "mapped", "km"], [[13215, 13215], "mapped", "mm2"], [[13216, 13216], "mapped", "cm2"], [[13217, 13217], "mapped", "m2"], [[13218, 13218], "mapped", "km2"], [[13219, 13219], "mapped", "mm3"], [[13220, 13220], "mapped", "cm3"], [[13221, 13221], "mapped", "m3"], [[13222, 13222], "mapped", "km3"], [[13223, 13223], "mapped", "m\u2215s"], [[13224, 13224], "mapped", "m\u2215s2"], [[13225, 13225], "mapped", "pa"], [[13226, 13226], "mapped", "kpa"], [[13227, 13227], "mapped", "mpa"], [[13228, 13228], "mapped", "gpa"], [[13229, 13229], "mapped", "rad"], [[13230, 13230], "mapped", "rad\u2215s"], [[13231, 13231], "mapped", "rad\u2215s2"], [[13232, 13232], "mapped", "ps"], [[13233, 13233], "mapped", "ns"], [[13234, 13234], "mapped", "\u03BCs"], [[13235, 13235], "mapped", "ms"], [[13236, 13236], "mapped", "pv"], [[13237, 13237], "mapped", "nv"], [[13238, 13238], "mapped", "\u03BCv"], [[13239, 13239], "mapped", "mv"], [[13240, 13240], "mapped", "kv"], [[13241, 13241], "mapped", "mv"], [[13242, 13242], "mapped", "pw"], [[13243, 13243], "mapped", "nw"], [[13244, 13244], "mapped", "\u03BCw"], [[13245, 13245], "mapped", "mw"], [[13246, 13246], "mapped", "kw"], [[13247, 13247], "mapped", "mw"], [[13248, 13248], "mapped", "k\u03C9"], [[13249, 13249], "mapped", "m\u03C9"], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", "bq"], [[13252, 13252], "mapped", "cc"], [[13253, 13253], "mapped", "cd"], [[13254, 13254], "mapped", "c\u2215kg"], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", "db"], [[13257, 13257], "mapped", "gy"], [[13258, 13258], "mapped", "ha"], [[13259, 13259], "mapped", "hp"], [[13260, 13260], "mapped", "in"], [[13261, 13261], "mapped", "kk"], [[13262, 13262], "mapped", "km"], [[13263, 13263], "mapped", "kt"], [[13264, 13264], "mapped", "lm"], [[13265, 13265], "mapped", "ln"], [[13266, 13266], "mapped", "log"], [[13267, 13267], "mapped", "lx"], [[13268, 13268], "mapped", "mb"], [[13269, 13269], "mapped", "mil"], [[13270, 13270], "mapped", "mol"], [[13271, 13271], "mapped", "ph"], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", "ppm"], [[13274, 13274], "mapped", "pr"], [[13275, 13275], "mapped", "sr"], [[13276, 13276], "mapped", "sv"], [[13277, 13277], "mapped", "wb"], [[13278, 13278], "mapped", "v\u2215m"], [[13279, 13279], "mapped", "a\u2215m"], [[13280, 13280], "mapped", "1\u65E5"], [[13281, 13281], "mapped", "2\u65E5"], [[13282, 13282], "mapped", "3\u65E5"], [[13283, 13283], "mapped", "4\u65E5"], [[13284, 13284], "mapped", "5\u65E5"], [[13285, 13285], "mapped", "6\u65E5"], [[13286, 13286], "mapped", "7\u65E5"], [[13287, 13287], "mapped", "8\u65E5"], [[13288, 13288], "mapped", "9\u65E5"], [[13289, 13289], "mapped", "10\u65E5"], [[13290, 13290], "mapped", "11\u65E5"], [[13291, 13291], "mapped", "12\u65E5"], [[13292, 13292], "mapped", "13\u65E5"], [[13293, 13293], "mapped", "14\u65E5"], [[13294, 13294], "mapped", "15\u65E5"], [[13295, 13295], "mapped", "16\u65E5"], [[13296, 13296], "mapped", "17\u65E5"], [[13297, 13297], "mapped", "18\u65E5"], [[13298, 13298], "mapped", "19\u65E5"], [[13299, 13299], "mapped", "20\u65E5"], [[13300, 13300], "mapped", "21\u65E5"], [[13301, 13301], "mapped", "22\u65E5"], [[13302, 13302], "mapped", "23\u65E5"], [[13303, 13303], "mapped", "24\u65E5"], [[13304, 13304], "mapped", "25\u65E5"], [[13305, 13305], "mapped", "26\u65E5"], [[13306, 13306], "mapped", "27\u65E5"], [[13307, 13307], "mapped", "28\u65E5"], [[13308, 13308], "mapped", "29\u65E5"], [[13309, 13309], "mapped", "30\u65E5"], [[13310, 13310], "mapped", "31\u65E5"], [[13311, 13311], "mapped", "gal"], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", "", "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40938], "valid"], [[40939, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", "", "NV8"], [[42146, 42147], "valid", "", "NV8"], [[42148, 42163], "valid", "", "NV8"], [[42164, 42164], "valid", "", "NV8"], [[42165, 42176], "valid", "", "NV8"], [[42177, 42177], "valid", "", "NV8"], [[42178, 42180], "valid", "", "NV8"], [[42181, 42181], "valid", "", "NV8"], [[42182, 42182], "valid", "", "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", "", "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", "", "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", "\uA641"], [[42561, 42561], "valid"], [[42562, 42562], "mapped", "\uA643"], [[42563, 42563], "valid"], [[42564, 42564], "mapped", "\uA645"], [[42565, 42565], "valid"], [[42566, 42566], "mapped", "\uA647"], [[42567, 42567], "valid"], [[42568, 42568], "mapped", "\uA649"], [[42569, 42569], "valid"], [[42570, 42570], "mapped", "\uA64B"], [[42571, 42571], "valid"], [[42572, 42572], "mapped", "\uA64D"], [[42573, 42573], "valid"], [[42574, 42574], "mapped", "\uA64F"], [[42575, 42575], "valid"], [[42576, 42576], "mapped", "\uA651"], [[42577, 42577], "valid"], [[42578, 42578], "mapped", "\uA653"], [[42579, 42579], "valid"], [[42580, 42580], "mapped", "\uA655"], [[42581, 42581], "valid"], [[42582, 42582], "mapped", "\uA657"], [[42583, 42583], "valid"], [[42584, 42584], "mapped", "\uA659"], [[42585, 42585], "valid"], [[42586, 42586], "mapped", "\uA65B"], [[42587, 42587], "valid"], [[42588, 42588], "mapped", "\uA65D"], [[42589, 42589], "valid"], [[42590, 42590], "mapped", "\uA65F"], [[42591, 42591], "valid"], [[42592, 42592], "mapped", "\uA661"], [[42593, 42593], "valid"], [[42594, 42594], "mapped", "\uA663"], [[42595, 42595], "valid"], [[42596, 42596], "mapped", "\uA665"], [[42597, 42597], "valid"], [[42598, 42598], "mapped", "\uA667"], [[42599, 42599], "valid"], [[42600, 42600], "mapped", "\uA669"], [[42601, 42601], "valid"], [[42602, 42602], "mapped", "\uA66B"], [[42603, 42603], "valid"], [[42604, 42604], "mapped", "\uA66D"], [[42605, 42607], "valid"], [[42608, 42611], "valid", "", "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", "", "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", "\uA681"], [[42625, 42625], "valid"], [[42626, 42626], "mapped", "\uA683"], [[42627, 42627], "valid"], [[42628, 42628], "mapped", "\uA685"], [[42629, 42629], "valid"], [[42630, 42630], "mapped", "\uA687"], [[42631, 42631], "valid"], [[42632, 42632], "mapped", "\uA689"], [[42633, 42633], "valid"], [[42634, 42634], "mapped", "\uA68B"], [[42635, 42635], "valid"], [[42636, 42636], "mapped", "\uA68D"], [[42637, 42637], "valid"], [[42638, 42638], "mapped", "\uA68F"], [[42639, 42639], "valid"], [[42640, 42640], "mapped", "\uA691"], [[42641, 42641], "valid"], [[42642, 42642], "mapped", "\uA693"], [[42643, 42643], "valid"], [[42644, 42644], "mapped", "\uA695"], [[42645, 42645], "valid"], [[42646, 42646], "mapped", "\uA697"], [[42647, 42647], "valid"], [[42648, 42648], "mapped", "\uA699"], [[42649, 42649], "valid"], [[42650, 42650], "mapped", "\uA69B"], [[42651, 42651], "valid"], [[42652, 42652], "mapped", "\u044A"], [[42653, 42653], "mapped", "\u044C"], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", "", "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", "", "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", "", "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", "", "NV8"], [[42786, 42786], "mapped", "\uA723"], [[42787, 42787], "valid"], [[42788, 42788], "mapped", "\uA725"], [[42789, 42789], "valid"], [[42790, 42790], "mapped", "\uA727"], [[42791, 42791], "valid"], [[42792, 42792], "mapped", "\uA729"], [[42793, 42793], "valid"], [[42794, 42794], "mapped", "\uA72B"], [[42795, 42795], "valid"], [[42796, 42796], "mapped", "\uA72D"], [[42797, 42797], "valid"], [[42798, 42798], "mapped", "\uA72F"], [[42799, 42801], "valid"], [[42802, 42802], "mapped", "\uA733"], [[42803, 42803], "valid"], [[42804, 42804], "mapped", "\uA735"], [[42805, 42805], "valid"], [[42806, 42806], "mapped", "\uA737"], [[42807, 42807], "valid"], [[42808, 42808], "mapped", "\uA739"], [[42809, 42809], "valid"], [[42810, 42810], "mapped", "\uA73B"], [[42811, 42811], "valid"], [[42812, 42812], "mapped", "\uA73D"], [[42813, 42813], "valid"], [[42814, 42814], "mapped", "\uA73F"], [[42815, 42815], "valid"], [[42816, 42816], "mapped", "\uA741"], [[42817, 42817], "valid"], [[42818, 42818], "mapped", "\uA743"], [[42819, 42819], "valid"], [[42820, 42820], "mapped", "\uA745"], [[42821, 42821], "valid"], [[42822, 42822], "mapped", "\uA747"], [[42823, 42823], "valid"], [[42824, 42824], "mapped", "\uA749"], [[42825, 42825], "valid"], [[42826, 42826], "mapped", "\uA74B"], [[42827, 42827], "valid"], [[42828, 42828], "mapped", "\uA74D"], [[42829, 42829], "valid"], [[42830, 42830], "mapped", "\uA74F"], [[42831, 42831], "valid"], [[42832, 42832], "mapped", "\uA751"], [[42833, 42833], "valid"], [[42834, 42834], "mapped", "\uA753"], [[42835, 42835], "valid"], [[42836, 42836], "mapped", "\uA755"], [[42837, 42837], "valid"], [[42838, 42838], "mapped", "\uA757"], [[42839, 42839], "valid"], [[42840, 42840], "mapped", "\uA759"], [[42841, 42841], "valid"], [[42842, 42842], "mapped", "\uA75B"], [[42843, 42843], "valid"], [[42844, 42844], "mapped", "\uA75D"], [[42845, 42845], "valid"], [[42846, 42846], "mapped", "\uA75F"], [[42847, 42847], "valid"], [[42848, 42848], "mapped", "\uA761"], [[42849, 42849], "valid"], [[42850, 42850], "mapped", "\uA763"], [[42851, 42851], "valid"], [[42852, 42852], "mapped", "\uA765"], [[42853, 42853], "valid"], [[42854, 42854], "mapped", "\uA767"], [[42855, 42855], "valid"], [[42856, 42856], "mapped", "\uA769"], [[42857, 42857], "valid"], [[42858, 42858], "mapped", "\uA76B"], [[42859, 42859], "valid"], [[42860, 42860], "mapped", "\uA76D"], [[42861, 42861], "valid"], [[42862, 42862], "mapped", "\uA76F"], [[42863, 42863], "valid"], [[42864, 42864], "mapped", "\uA76F"], [[42865, 42872], "valid"], [[42873, 42873], "mapped", "\uA77A"], [[42874, 42874], "valid"], [[42875, 42875], "mapped", "\uA77C"], [[42876, 42876], "valid"], [[42877, 42877], "mapped", "\u1D79"], [[42878, 42878], "mapped", "\uA77F"], [[42879, 42879], "valid"], [[42880, 42880], "mapped", "\uA781"], [[42881, 42881], "valid"], [[42882, 42882], "mapped", "\uA783"], [[42883, 42883], "valid"], [[42884, 42884], "mapped", "\uA785"], [[42885, 42885], "valid"], [[42886, 42886], "mapped", "\uA787"], [[42887, 42888], "valid"], [[42889, 42890], "valid", "", "NV8"], [[42891, 42891], "mapped", "\uA78C"], [[42892, 42892], "valid"], [[42893, 42893], "mapped", "\u0265"], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", "\uA791"], [[42897, 42897], "valid"], [[42898, 42898], "mapped", "\uA793"], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", "\uA797"], [[42903, 42903], "valid"], [[42904, 42904], "mapped", "\uA799"], [[42905, 42905], "valid"], [[42906, 42906], "mapped", "\uA79B"], [[42907, 42907], "valid"], [[42908, 42908], "mapped", "\uA79D"], [[42909, 42909], "valid"], [[42910, 42910], "mapped", "\uA79F"], [[42911, 42911], "valid"], [[42912, 42912], "mapped", "\uA7A1"], [[42913, 42913], "valid"], [[42914, 42914], "mapped", "\uA7A3"], [[42915, 42915], "valid"], [[42916, 42916], "mapped", "\uA7A5"], [[42917, 42917], "valid"], [[42918, 42918], "mapped", "\uA7A7"], [[42919, 42919], "valid"], [[42920, 42920], "mapped", "\uA7A9"], [[42921, 42921], "valid"], [[42922, 42922], "mapped", "\u0266"], [[42923, 42923], "mapped", "\u025C"], [[42924, 42924], "mapped", "\u0261"], [[42925, 42925], "mapped", "\u026C"], [[42926, 42926], "mapped", "\u026A"], [[42927, 42927], "disallowed"], [[42928, 42928], "mapped", "\u029E"], [[42929, 42929], "mapped", "\u0287"], [[42930, 42930], "mapped", "\u029D"], [[42931, 42931], "mapped", "\uAB53"], [[42932, 42932], "mapped", "\uA7B5"], [[42933, 42933], "valid"], [[42934, 42934], "mapped", "\uA7B7"], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", "\u0127"], [[43001, 43001], "mapped", "\u0153"], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", "", "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", "", "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", "", "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43205], "valid"], [[43206, 43213], "disallowed"], [[43214, 43215], "valid", "", "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", "", "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", "", "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", "", "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", "", "NV8"], [[43360, 43388], "valid", "", "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", "", "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", "", "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", "", "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", "", "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", "", "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", "", "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", "", "NV8"], [[43868, 43868], "mapped", "\uA727"], [[43869, 43869], "mapped", "\uAB37"], [[43870, 43870], "mapped", "\u026B"], [[43871, 43871], "mapped", "\uAB52"], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", "\u13A0"], [[43889, 43889], "mapped", "\u13A1"], [[43890, 43890], "mapped", "\u13A2"], [[43891, 43891], "mapped", "\u13A3"], [[43892, 43892], "mapped", "\u13A4"], [[43893, 43893], "mapped", "\u13A5"], [[43894, 43894], "mapped", "\u13A6"], [[43895, 43895], "mapped", "\u13A7"], [[43896, 43896], "mapped", "\u13A8"], [[43897, 43897], "mapped", "\u13A9"], [[43898, 43898], "mapped", "\u13AA"], [[43899, 43899], "mapped", "\u13AB"], [[43900, 43900], "mapped", "\u13AC"], [[43901, 43901], "mapped", "\u13AD"], [[43902, 43902], "mapped", "\u13AE"], [[43903, 43903], "mapped", "\u13AF"], [[43904, 43904], "mapped", "\u13B0"], [[43905, 43905], "mapped", "\u13B1"], [[43906, 43906], "mapped", "\u13B2"], [[43907, 43907], "mapped", "\u13B3"], [[43908, 43908], "mapped", "\u13B4"], [[43909, 43909], "mapped", "\u13B5"], [[43910, 43910], "mapped", "\u13B6"], [[43911, 43911], "mapped", "\u13B7"], [[43912, 43912], "mapped", "\u13B8"], [[43913, 43913], "mapped", "\u13B9"], [[43914, 43914], "mapped", "\u13BA"], [[43915, 43915], "mapped", "\u13BB"], [[43916, 43916], "mapped", "\u13BC"], [[43917, 43917], "mapped", "\u13BD"], [[43918, 43918], "mapped", "\u13BE"], [[43919, 43919], "mapped", "\u13BF"], [[43920, 43920], "mapped", "\u13C0"], [[43921, 43921], "mapped", "\u13C1"], [[43922, 43922], "mapped", "\u13C2"], [[43923, 43923], "mapped", "\u13C3"], [[43924, 43924], "mapped", "\u13C4"], [[43925, 43925], "mapped", "\u13C5"], [[43926, 43926], "mapped", "\u13C6"], [[43927, 43927], "mapped", "\u13C7"], [[43928, 43928], "mapped", "\u13C8"], [[43929, 43929], "mapped", "\u13C9"], [[43930, 43930], "mapped", "\u13CA"], [[43931, 43931], "mapped", "\u13CB"], [[43932, 43932], "mapped", "\u13CC"], [[43933, 43933], "mapped", "\u13CD"], [[43934, 43934], "mapped", "\u13CE"], [[43935, 43935], "mapped", "\u13CF"], [[43936, 43936], "mapped", "\u13D0"], [[43937, 43937], "mapped", "\u13D1"], [[43938, 43938], "mapped", "\u13D2"], [[43939, 43939], "mapped", "\u13D3"], [[43940, 43940], "mapped", "\u13D4"], [[43941, 43941], "mapped", "\u13D5"], [[43942, 43942], "mapped", "\u13D6"], [[43943, 43943], "mapped", "\u13D7"], [[43944, 43944], "mapped", "\u13D8"], [[43945, 43945], "mapped", "\u13D9"], [[43946, 43946], "mapped", "\u13DA"], [[43947, 43947], "mapped", "\u13DB"], [[43948, 43948], "mapped", "\u13DC"], [[43949, 43949], "mapped", "\u13DD"], [[43950, 43950], "mapped", "\u13DE"], [[43951, 43951], "mapped", "\u13DF"], [[43952, 43952], "mapped", "\u13E0"], [[43953, 43953], "mapped", "\u13E1"], [[43954, 43954], "mapped", "\u13E2"], [[43955, 43955], "mapped", "\u13E3"], [[43956, 43956], "mapped", "\u13E4"], [[43957, 43957], "mapped", "\u13E5"], [[43958, 43958], "mapped", "\u13E6"], [[43959, 43959], "mapped", "\u13E7"], [[43960, 43960], "mapped", "\u13E8"], [[43961, 43961], "mapped", "\u13E9"], [[43962, 43962], "mapped", "\u13EA"], [[43963, 43963], "mapped", "\u13EB"], [[43964, 43964], "mapped", "\u13EC"], [[43965, 43965], "mapped", "\u13ED"], [[43966, 43966], "mapped", "\u13EE"], [[43967, 43967], "mapped", "\u13EF"], [[43968, 44010], "valid"], [[44011, 44011], "valid", "", "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", "", "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", "", "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", "\u8C48"], [[63745, 63745], "mapped", "\u66F4"], [[63746, 63746], "mapped", "\u8ECA"], [[63747, 63747], "mapped", "\u8CC8"], [[63748, 63748], "mapped", "\u6ED1"], [[63749, 63749], "mapped", "\u4E32"], [[63750, 63750], "mapped", "\u53E5"], [[63751, 63752], "mapped", "\u9F9C"], [[63753, 63753], "mapped", "\u5951"], [[63754, 63754], "mapped", "\u91D1"], [[63755, 63755], "mapped", "\u5587"], [[63756, 63756], "mapped", "\u5948"], [[63757, 63757], "mapped", "\u61F6"], [[63758, 63758], "mapped", "\u7669"], [[63759, 63759], "mapped", "\u7F85"], [[63760, 63760], "mapped", "\u863F"], [[63761, 63761], "mapped", "\u87BA"], [[63762, 63762], "mapped", "\u88F8"], [[63763, 63763], "mapped", "\u908F"], [[63764, 63764], "mapped", "\u6A02"], [[63765, 63765], "mapped", "\u6D1B"], [[63766, 63766], "mapped", "\u70D9"], [[63767, 63767], "mapped", "\u73DE"], [[63768, 63768], "mapped", "\u843D"], [[63769, 63769], "mapped", "\u916A"], [[63770, 63770], "mapped", "\u99F1"], [[63771, 63771], "mapped", "\u4E82"], [[63772, 63772], "mapped", "\u5375"], [[63773, 63773], "mapped", "\u6B04"], [[63774, 63774], "mapped", "\u721B"], [[63775, 63775], "mapped", "\u862D"], [[63776, 63776], "mapped", "\u9E1E"], [[63777, 63777], "mapped", "\u5D50"], [[63778, 63778], "mapped", "\u6FEB"], [[63779, 63779], "mapped", "\u85CD"], [[63780, 63780], "mapped", "\u8964"], [[63781, 63781], "mapped", "\u62C9"], [[63782, 63782], "mapped", "\u81D8"], [[63783, 63783], "mapped", "\u881F"], [[63784, 63784], "mapped", "\u5ECA"], [[63785, 63785], "mapped", "\u6717"], [[63786, 63786], "mapped", "\u6D6A"], [[63787, 63787], "mapped", "\u72FC"], [[63788, 63788], "mapped", "\u90CE"], [[63789, 63789], "mapped", "\u4F86"], [[63790, 63790], "mapped", "\u51B7"], [[63791, 63791], "mapped", "\u52DE"], [[63792, 63792], "mapped", "\u64C4"], [[63793, 63793], "mapped", "\u6AD3"], [[63794, 63794], "mapped", "\u7210"], [[63795, 63795], "mapped", "\u76E7"], [[63796, 63796], "mapped", "\u8001"], [[63797, 63797], "mapped", "\u8606"], [[63798, 63798], "mapped", "\u865C"], [[63799, 63799], "mapped", "\u8DEF"], [[63800, 63800], "mapped", "\u9732"], [[63801, 63801], "mapped", "\u9B6F"], [[63802, 63802], "mapped", "\u9DFA"], [[63803, 63803], "mapped", "\u788C"], [[63804, 63804], "mapped", "\u797F"], [[63805, 63805], "mapped", "\u7DA0"], [[63806, 63806], "mapped", "\u83C9"], [[63807, 63807], "mapped", "\u9304"], [[63808, 63808], "mapped", "\u9E7F"], [[63809, 63809], "mapped", "\u8AD6"], [[63810, 63810], "mapped", "\u58DF"], [[63811, 63811], "mapped", "\u5F04"], [[63812, 63812], "mapped", "\u7C60"], [[63813, 63813], "mapped", "\u807E"], [[63814, 63814], "mapped", "\u7262"], [[63815, 63815], "mapped", "\u78CA"], [[63816, 63816], "mapped", "\u8CC2"], [[63817, 63817], "mapped", "\u96F7"], [[63818, 63818], "mapped", "\u58D8"], [[63819, 63819], "mapped", "\u5C62"], [[63820, 63820], "mapped", "\u6A13"], [[63821, 63821], "mapped", "\u6DDA"], [[63822, 63822], "mapped", "\u6F0F"], [[63823, 63823], "mapped", "\u7D2F"], [[63824, 63824], "mapped", "\u7E37"], [[63825, 63825], "mapped", "\u964B"], [[63826, 63826], "mapped", "\u52D2"], [[63827, 63827], "mapped", "\u808B"], [[63828, 63828], "mapped", "\u51DC"], [[63829, 63829], "mapped", "\u51CC"], [[63830, 63830], "mapped", "\u7A1C"], [[63831, 63831], "mapped", "\u7DBE"], [[63832, 63832], "mapped", "\u83F1"], [[63833, 63833], "mapped", "\u9675"], [[63834, 63834], "mapped", "\u8B80"], [[63835, 63835], "mapped", "\u62CF"], [[63836, 63836], "mapped", "\u6A02"], [[63837, 63837], "mapped", "\u8AFE"], [[63838, 63838], "mapped", "\u4E39"], [[63839, 63839], "mapped", "\u5BE7"], [[63840, 63840], "mapped", "\u6012"], [[63841, 63841], "mapped", "\u7387"], [[63842, 63842], "mapped", "\u7570"], [[63843, 63843], "mapped", "\u5317"], [[63844, 63844], "mapped", "\u78FB"], [[63845, 63845], "mapped", "\u4FBF"], [[63846, 63846], "mapped", "\u5FA9"], [[63847, 63847], "mapped", "\u4E0D"], [[63848, 63848], "mapped", "\u6CCC"], [[63849, 63849], "mapped", "\u6578"], [[63850, 63850], "mapped", "\u7D22"], [[63851, 63851], "mapped", "\u53C3"], [[63852, 63852], "mapped", "\u585E"], [[63853, 63853], "mapped", "\u7701"], [[63854, 63854], "mapped", "\u8449"], [[63855, 63855], "mapped", "\u8AAA"], [[63856, 63856], "mapped", "\u6BBA"], [[63857, 63857], "mapped", "\u8FB0"], [[63858, 63858], "mapped", "\u6C88"], [[63859, 63859], "mapped", "\u62FE"], [[63860, 63860], "mapped", "\u82E5"], [[63861, 63861], "mapped", "\u63A0"], [[63862, 63862], "mapped", "\u7565"], [[63863, 63863], "mapped", "\u4EAE"], [[63864, 63864], "mapped", "\u5169"], [[63865, 63865], "mapped", "\u51C9"], [[63866, 63866], "mapped", "\u6881"], [[63867, 63867], "mapped", "\u7CE7"], [[63868, 63868], "mapped", "\u826F"], [[63869, 63869], "mapped", "\u8AD2"], [[63870, 63870], "mapped", "\u91CF"], [[63871, 63871], "mapped", "\u52F5"], [[63872, 63872], "mapped", "\u5442"], [[63873, 63873], "mapped", "\u5973"], [[63874, 63874], "mapped", "\u5EEC"], [[63875, 63875], "mapped", "\u65C5"], [[63876, 63876], "mapped", "\u6FFE"], [[63877, 63877], "mapped", "\u792A"], [[63878, 63878], "mapped", "\u95AD"], [[63879, 63879], "mapped", "\u9A6A"], [[63880, 63880], "mapped", "\u9E97"], [[63881, 63881], "mapped", "\u9ECE"], [[63882, 63882], "mapped", "\u529B"], [[63883, 63883], "mapped", "\u66C6"], [[63884, 63884], "mapped", "\u6B77"], [[63885, 63885], "mapped", "\u8F62"], [[63886, 63886], "mapped", "\u5E74"], [[63887, 63887], "mapped", "\u6190"], [[63888, 63888], "mapped", "\u6200"], [[63889, 63889], "mapped", "\u649A"], [[63890, 63890], "mapped", "\u6F23"], [[63891, 63891], "mapped", "\u7149"], [[63892, 63892], "mapped", "\u7489"], [[63893, 63893], "mapped", "\u79CA"], [[63894, 63894], "mapped", "\u7DF4"], [[63895, 63895], "mapped", "\u806F"], [[63896, 63896], "mapped", "\u8F26"], [[63897, 63897], "mapped", "\u84EE"], [[63898, 63898], "mapped", "\u9023"], [[63899, 63899], "mapped", "\u934A"], [[63900, 63900], "mapped", "\u5217"], [[63901, 63901], "mapped", "\u52A3"], [[63902, 63902], "mapped", "\u54BD"], [[63903, 63903], "mapped", "\u70C8"], [[63904, 63904], "mapped", "\u88C2"], [[63905, 63905], "mapped", "\u8AAA"], [[63906, 63906], "mapped", "\u5EC9"], [[63907, 63907], "mapped", "\u5FF5"], [[63908, 63908], "mapped", "\u637B"], [[63909, 63909], "mapped", "\u6BAE"], [[63910, 63910], "mapped", "\u7C3E"], [[63911, 63911], "mapped", "\u7375"], [[63912, 63912], "mapped", "\u4EE4"], [[63913, 63913], "mapped", "\u56F9"], [[63914, 63914], "mapped", "\u5BE7"], [[63915, 63915], "mapped", "\u5DBA"], [[63916, 63916], "mapped", "\u601C"], [[63917, 63917], "mapped", "\u73B2"], [[63918, 63918], "mapped", "\u7469"], [[63919, 63919], "mapped", "\u7F9A"], [[63920, 63920], "mapped", "\u8046"], [[63921, 63921], "mapped", "\u9234"], [[63922, 63922], "mapped", "\u96F6"], [[63923, 63923], "mapped", "\u9748"], [[63924, 63924], "mapped", "\u9818"], [[63925, 63925], "mapped", "\u4F8B"], [[63926, 63926], "mapped", "\u79AE"], [[63927, 63927], "mapped", "\u91B4"], [[63928, 63928], "mapped", "\u96B8"], [[63929, 63929], "mapped", "\u60E1"], [[63930, 63930], "mapped", "\u4E86"], [[63931, 63931], "mapped", "\u50DA"], [[63932, 63932], "mapped", "\u5BEE"], [[63933, 63933], "mapped", "\u5C3F"], [[63934, 63934], "mapped", "\u6599"], [[63935, 63935], "mapped", "\u6A02"], [[63936, 63936], "mapped", "\u71CE"], [[63937, 63937], "mapped", "\u7642"], [[63938, 63938], "mapped", "\u84FC"], [[63939, 63939], "mapped", "\u907C"], [[63940, 63940], "mapped", "\u9F8D"], [[63941, 63941], "mapped", "\u6688"], [[63942, 63942], "mapped", "\u962E"], [[63943, 63943], "mapped", "\u5289"], [[63944, 63944], "mapped", "\u677B"], [[63945, 63945], "mapped", "\u67F3"], [[63946, 63946], "mapped", "\u6D41"], [[63947, 63947], "mapped", "\u6E9C"], [[63948, 63948], "mapped", "\u7409"], [[63949, 63949], "mapped", "\u7559"], [[63950, 63950], "mapped", "\u786B"], [[63951, 63951], "mapped", "\u7D10"], [[63952, 63952], "mapped", "\u985E"], [[63953, 63953], "mapped", "\u516D"], [[63954, 63954], "mapped", "\u622E"], [[63955, 63955], "mapped", "\u9678"], [[63956, 63956], "mapped", "\u502B"], [[63957, 63957], "mapped", "\u5D19"], [[63958, 63958], "mapped", "\u6DEA"], [[63959, 63959], "mapped", "\u8F2A"], [[63960, 63960], "mapped", "\u5F8B"], [[63961, 63961], "mapped", "\u6144"], [[63962, 63962], "mapped", "\u6817"], [[63963, 63963], "mapped", "\u7387"], [[63964, 63964], "mapped", "\u9686"], [[63965, 63965], "mapped", "\u5229"], [[63966, 63966], "mapped", "\u540F"], [[63967, 63967], "mapped", "\u5C65"], [[63968, 63968], "mapped", "\u6613"], [[63969, 63969], "mapped", "\u674E"], [[63970, 63970], "mapped", "\u68A8"], [[63971, 63971], "mapped", "\u6CE5"], [[63972, 63972], "mapped", "\u7406"], [[63973, 63973], "mapped", "\u75E2"], [[63974, 63974], "mapped", "\u7F79"], [[63975, 63975], "mapped", "\u88CF"], [[63976, 63976], "mapped", "\u88E1"], [[63977, 63977], "mapped", "\u91CC"], [[63978, 63978], "mapped", "\u96E2"], [[63979, 63979], "mapped", "\u533F"], [[63980, 63980], "mapped", "\u6EBA"], [[63981, 63981], "mapped", "\u541D"], [[63982, 63982], "mapped", "\u71D0"], [[63983, 63983], "mapped", "\u7498"], [[63984, 63984], "mapped", "\u85FA"], [[63985, 63985], "mapped", "\u96A3"], [[63986, 63986], "mapped", "\u9C57"], [[63987, 63987], "mapped", "\u9E9F"], [[63988, 63988], "mapped", "\u6797"], [[63989, 63989], "mapped", "\u6DCB"], [[63990, 63990], "mapped", "\u81E8"], [[63991, 63991], "mapped", "\u7ACB"], [[63992, 63992], "mapped", "\u7B20"], [[63993, 63993], "mapped", "\u7C92"], [[63994, 63994], "mapped", "\u72C0"], [[63995, 63995], "mapped", "\u7099"], [[63996, 63996], "mapped", "\u8B58"], [[63997, 63997], "mapped", "\u4EC0"], [[63998, 63998], "mapped", "\u8336"], [[63999, 63999], "mapped", "\u523A"], [[64e3, 64e3], "mapped", "\u5207"], [[64001, 64001], "mapped", "\u5EA6"], [[64002, 64002], "mapped", "\u62D3"], [[64003, 64003], "mapped", "\u7CD6"], [[64004, 64004], "mapped", "\u5B85"], [[64005, 64005], "mapped", "\u6D1E"], [[64006, 64006], "mapped", "\u66B4"], [[64007, 64007], "mapped", "\u8F3B"], [[64008, 64008], "mapped", "\u884C"], [[64009, 64009], "mapped", "\u964D"], [[64010, 64010], "mapped", "\u898B"], [[64011, 64011], "mapped", "\u5ED3"], [[64012, 64012], "mapped", "\u5140"], [[64013, 64013], "mapped", "\u55C0"], [[64014, 64015], "valid"], [[64016, 64016], "mapped", "\u585A"], [[64017, 64017], "valid"], [[64018, 64018], "mapped", "\u6674"], [[64019, 64020], "valid"], [[64021, 64021], "mapped", "\u51DE"], [[64022, 64022], "mapped", "\u732A"], [[64023, 64023], "mapped", "\u76CA"], [[64024, 64024], "mapped", "\u793C"], [[64025, 64025], "mapped", "\u795E"], [[64026, 64026], "mapped", "\u7965"], [[64027, 64027], "mapped", "\u798F"], [[64028, 64028], "mapped", "\u9756"], [[64029, 64029], "mapped", "\u7CBE"], [[64030, 64030], "mapped", "\u7FBD"], [[64031, 64031], "valid"], [[64032, 64032], "mapped", "\u8612"], [[64033, 64033], "valid"], [[64034, 64034], "mapped", "\u8AF8"], [[64035, 64036], "valid"], [[64037, 64037], "mapped", "\u9038"], [[64038, 64038], "mapped", "\u90FD"], [[64039, 64041], "valid"], [[64042, 64042], "mapped", "\u98EF"], [[64043, 64043], "mapped", "\u98FC"], [[64044, 64044], "mapped", "\u9928"], [[64045, 64045], "mapped", "\u9DB4"], [[64046, 64046], "mapped", "\u90DE"], [[64047, 64047], "mapped", "\u96B7"], [[64048, 64048], "mapped", "\u4FAE"], [[64049, 64049], "mapped", "\u50E7"], [[64050, 64050], "mapped", "\u514D"], [[64051, 64051], "mapped", "\u52C9"], [[64052, 64052], "mapped", "\u52E4"], [[64053, 64053], "mapped", "\u5351"], [[64054, 64054], "mapped", "\u559D"], [[64055, 64055], "mapped", "\u5606"], [[64056, 64056], "mapped", "\u5668"], [[64057, 64057], "mapped", "\u5840"], [[64058, 64058], "mapped", "\u58A8"], [[64059, 64059], "mapped", "\u5C64"], [[64060, 64060], "mapped", "\u5C6E"], [[64061, 64061], "mapped", "\u6094"], [[64062, 64062], "mapped", "\u6168"], [[64063, 64063], "mapped", "\u618E"], [[64064, 64064], "mapped", "\u61F2"], [[64065, 64065], "mapped", "\u654F"], [[64066, 64066], "mapped", "\u65E2"], [[64067, 64067], "mapped", "\u6691"], [[64068, 64068], "mapped", "\u6885"], [[64069, 64069], "mapped", "\u6D77"], [[64070, 64070], "mapped", "\u6E1A"], [[64071, 64071], "mapped", "\u6F22"], [[64072, 64072], "mapped", "\u716E"], [[64073, 64073], "mapped", "\u722B"], [[64074, 64074], "mapped", "\u7422"], [[64075, 64075], "mapped", "\u7891"], [[64076, 64076], "mapped", "\u793E"], [[64077, 64077], "mapped", "\u7949"], [[64078, 64078], "mapped", "\u7948"], [[64079, 64079], "mapped", "\u7950"], [[64080, 64080], "mapped", "\u7956"], [[64081, 64081], "mapped", "\u795D"], [[64082, 64082], "mapped", "\u798D"], [[64083, 64083], "mapped", "\u798E"], [[64084, 64084], "mapped", "\u7A40"], [[64085, 64085], "mapped", "\u7A81"], [[64086, 64086], "mapped", "\u7BC0"], [[64087, 64087], "mapped", "\u7DF4"], [[64088, 64088], "mapped", "\u7E09"], [[64089, 64089], "mapped", "\u7E41"], [[64090, 64090], "mapped", "\u7F72"], [[64091, 64091], "mapped", "\u8005"], [[64092, 64092], "mapped", "\u81ED"], [[64093, 64094], "mapped", "\u8279"], [[64095, 64095], "mapped", "\u8457"], [[64096, 64096], "mapped", "\u8910"], [[64097, 64097], "mapped", "\u8996"], [[64098, 64098], "mapped", "\u8B01"], [[64099, 64099], "mapped", "\u8B39"], [[64100, 64100], "mapped", "\u8CD3"], [[64101, 64101], "mapped", "\u8D08"], [[64102, 64102], "mapped", "\u8FB6"], [[64103, 64103], "mapped", "\u9038"], [[64104, 64104], "mapped", "\u96E3"], [[64105, 64105], "mapped", "\u97FF"], [[64106, 64106], "mapped", "\u983B"], [[64107, 64107], "mapped", "\u6075"], [[64108, 64108], "mapped", "\u{242EE}"], [[64109, 64109], "mapped", "\u8218"], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", "\u4E26"], [[64113, 64113], "mapped", "\u51B5"], [[64114, 64114], "mapped", "\u5168"], [[64115, 64115], "mapped", "\u4F80"], [[64116, 64116], "mapped", "\u5145"], [[64117, 64117], "mapped", "\u5180"], [[64118, 64118], "mapped", "\u52C7"], [[64119, 64119], "mapped", "\u52FA"], [[64120, 64120], "mapped", "\u559D"], [[64121, 64121], "mapped", "\u5555"], [[64122, 64122], "mapped", "\u5599"], [[64123, 64123], "mapped", "\u55E2"], [[64124, 64124], "mapped", "\u585A"], [[64125, 64125], "mapped", "\u58B3"], [[64126, 64126], "mapped", "\u5944"], [[64127, 64127], "mapped", "\u5954"], [[64128, 64128], "mapped", "\u5A62"], [[64129, 64129], "mapped", "\u5B28"], [[64130, 64130], "mapped", "\u5ED2"], [[64131, 64131], "mapped", "\u5ED9"], [[64132, 64132], "mapped", "\u5F69"], [[64133, 64133], "mapped", "\u5FAD"], [[64134, 64134], "mapped", "\u60D8"], [[64135, 64135], "mapped", "\u614E"], [[64136, 64136], "mapped", "\u6108"], [[64137, 64137], "mapped", "\u618E"], [[64138, 64138], "mapped", "\u6160"], [[64139, 64139], "mapped", "\u61F2"], [[64140, 64140], "mapped", "\u6234"], [[64141, 64141], "mapped", "\u63C4"], [[64142, 64142], "mapped", "\u641C"], [[64143, 64143], "mapped", "\u6452"], [[64144, 64144], "mapped", "\u6556"], [[64145, 64145], "mapped", "\u6674"], [[64146, 64146], "mapped", "\u6717"], [[64147, 64147], "mapped", "\u671B"], [[64148, 64148], "mapped", "\u6756"], [[64149, 64149], "mapped", "\u6B79"], [[64150, 64150], "mapped", "\u6BBA"], [[64151, 64151], "mapped", "\u6D41"], [[64152, 64152], "mapped", "\u6EDB"], [[64153, 64153], "mapped", "\u6ECB"], [[64154, 64154], "mapped", "\u6F22"], [[64155, 64155], "mapped", "\u701E"], [[64156, 64156], "mapped", "\u716E"], [[64157, 64157], "mapped", "\u77A7"], [[64158, 64158], "mapped", "\u7235"], [[64159, 64159], "mapped", "\u72AF"], [[64160, 64160], "mapped", "\u732A"], [[64161, 64161], "mapped", "\u7471"], [[64162, 64162], "mapped", "\u7506"], [[64163, 64163], "mapped", "\u753B"], [[64164, 64164], "mapped", "\u761D"], [[64165, 64165], "mapped", "\u761F"], [[64166, 64166], "mapped", "\u76CA"], [[64167, 64167], "mapped", "\u76DB"], [[64168, 64168], "mapped", "\u76F4"], [[64169, 64169], "mapped", "\u774A"], [[64170, 64170], "mapped", "\u7740"], [[64171, 64171], "mapped", "\u78CC"], [[64172, 64172], "mapped", "\u7AB1"], [[64173, 64173], "mapped", "\u7BC0"], [[64174, 64174], "mapped", "\u7C7B"], [[64175, 64175], "mapped", "\u7D5B"], [[64176, 64176], "mapped", "\u7DF4"], [[64177, 64177], "mapped", "\u7F3E"], [[64178, 64178], "mapped", "\u8005"], [[64179, 64179], "mapped", "\u8352"], [[64180, 64180], "mapped", "\u83EF"], [[64181, 64181], "mapped", "\u8779"], [[64182, 64182], "mapped", "\u8941"], [[64183, 64183], "mapped", "\u8986"], [[64184, 64184], "mapped", "\u8996"], [[64185, 64185], "mapped", "\u8ABF"], [[64186, 64186], "mapped", "\u8AF8"], [[64187, 64187], "mapped", "\u8ACB"], [[64188, 64188], "mapped", "\u8B01"], [[64189, 64189], "mapped", "\u8AFE"], [[64190, 64190], "mapped", "\u8AED"], [[64191, 64191], "mapped", "\u8B39"], [[64192, 64192], "mapped", "\u8B8A"], [[64193, 64193], "mapped", "\u8D08"], [[64194, 64194], "mapped", "\u8F38"], [[64195, 64195], "mapped", "\u9072"], [[64196, 64196], "mapped", "\u9199"], [[64197, 64197], "mapped", "\u9276"], [[64198, 64198], "mapped", "\u967C"], [[64199, 64199], "mapped", "\u96E3"], [[64200, 64200], "mapped", "\u9756"], [[64201, 64201], "mapped", "\u97DB"], [[64202, 64202], "mapped", "\u97FF"], [[64203, 64203], "mapped", "\u980B"], [[64204, 64204], "mapped", "\u983B"], [[64205, 64205], "mapped", "\u9B12"], [[64206, 64206], "mapped", "\u9F9C"], [[64207, 64207], "mapped", "\u{2284A}"], [[64208, 64208], "mapped", "\u{22844}"], [[64209, 64209], "mapped", "\u{233D5}"], [[64210, 64210], "mapped", "\u3B9D"], [[64211, 64211], "mapped", "\u4018"], [[64212, 64212], "mapped", "\u4039"], [[64213, 64213], "mapped", "\u{25249}"], [[64214, 64214], "mapped", "\u{25CD0}"], [[64215, 64215], "mapped", "\u{27ED3}"], [[64216, 64216], "mapped", "\u9F43"], [[64217, 64217], "mapped", "\u9F8E"], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", "ff"], [[64257, 64257], "mapped", "fi"], [[64258, 64258], "mapped", "fl"], [[64259, 64259], "mapped", "ffi"], [[64260, 64260], "mapped", "ffl"], [[64261, 64262], "mapped", "st"], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", "\u0574\u0576"], [[64276, 64276], "mapped", "\u0574\u0565"], [[64277, 64277], "mapped", "\u0574\u056B"], [[64278, 64278], "mapped", "\u057E\u0576"], [[64279, 64279], "mapped", "\u0574\u056D"], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", "\u05D9\u05B4"], [[64286, 64286], "valid"], [[64287, 64287], "mapped", "\u05F2\u05B7"], [[64288, 64288], "mapped", "\u05E2"], [[64289, 64289], "mapped", "\u05D0"], [[64290, 64290], "mapped", "\u05D3"], [[64291, 64291], "mapped", "\u05D4"], [[64292, 64292], "mapped", "\u05DB"], [[64293, 64293], "mapped", "\u05DC"], [[64294, 64294], "mapped", "\u05DD"], [[64295, 64295], "mapped", "\u05E8"], [[64296, 64296], "mapped", "\u05EA"], [[64297, 64297], "disallowed_STD3_mapped", "+"], [[64298, 64298], "mapped", "\u05E9\u05C1"], [[64299, 64299], "mapped", "\u05E9\u05C2"], [[64300, 64300], "mapped", "\u05E9\u05BC\u05C1"], [[64301, 64301], "mapped", "\u05E9\u05BC\u05C2"], [[64302, 64302], "mapped", "\u05D0\u05B7"], [[64303, 64303], "mapped", "\u05D0\u05B8"], [[64304, 64304], "mapped", "\u05D0\u05BC"], [[64305, 64305], "mapped", "\u05D1\u05BC"], [[64306, 64306], "mapped", "\u05D2\u05BC"], [[64307, 64307], "mapped", "\u05D3\u05BC"], [[64308, 64308], "mapped", "\u05D4\u05BC"], [[64309, 64309], "mapped", "\u05D5\u05BC"], [[64310, 64310], "mapped", "\u05D6\u05BC"], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", "\u05D8\u05BC"], [[64313, 64313], "mapped", "\u05D9\u05BC"], [[64314, 64314], "mapped", "\u05DA\u05BC"], [[64315, 64315], "mapped", "\u05DB\u05BC"], [[64316, 64316], "mapped", "\u05DC\u05BC"], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", "\u05DE\u05BC"], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", "\u05E0\u05BC"], [[64321, 64321], "mapped", "\u05E1\u05BC"], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", "\u05E3\u05BC"], [[64324, 64324], "mapped", "\u05E4\u05BC"], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", "\u05E6\u05BC"], [[64327, 64327], "mapped", "\u05E7\u05BC"], [[64328, 64328], "mapped", "\u05E8\u05BC"], [[64329, 64329], "mapped", "\u05E9\u05BC"], [[64330, 64330], "mapped", "\u05EA\u05BC"], [[64331, 64331], "mapped", "\u05D5\u05B9"], [[64332, 64332], "mapped", "\u05D1\u05BF"], [[64333, 64333], "mapped", "\u05DB\u05BF"], [[64334, 64334], "mapped", "\u05E4\u05BF"], [[64335, 64335], "mapped", "\u05D0\u05DC"], [[64336, 64337], "mapped", "\u0671"], [[64338, 64341], "mapped", "\u067B"], [[64342, 64345], "mapped", "\u067E"], [[64346, 64349], "mapped", "\u0680"], [[64350, 64353], "mapped", "\u067A"], [[64354, 64357], "mapped", "\u067F"], [[64358, 64361], "mapped", "\u0679"], [[64362, 64365], "mapped", "\u06A4"], [[64366, 64369], "mapped", "\u06A6"], [[64370, 64373], "mapped", "\u0684"], [[64374, 64377], "mapped", "\u0683"], [[64378, 64381], "mapped", "\u0686"], [[64382, 64385], "mapped", "\u0687"], [[64386, 64387], "mapped", "\u068D"], [[64388, 64389], "mapped", "\u068C"], [[64390, 64391], "mapped", "\u068E"], [[64392, 64393], "mapped", "\u0688"], [[64394, 64395], "mapped", "\u0698"], [[64396, 64397], "mapped", "\u0691"], [[64398, 64401], "mapped", "\u06A9"], [[64402, 64405], "mapped", "\u06AF"], [[64406, 64409], "mapped", "\u06B3"], [[64410, 64413], "mapped", "\u06B1"], [[64414, 64415], "mapped", "\u06BA"], [[64416, 64419], "mapped", "\u06BB"], [[64420, 64421], "mapped", "\u06C0"], [[64422, 64425], "mapped", "\u06C1"], [[64426, 64429], "mapped", "\u06BE"], [[64430, 64431], "mapped", "\u06D2"], [[64432, 64433], "mapped", "\u06D3"], [[64434, 64449], "valid", "", "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", "\u06AD"], [[64471, 64472], "mapped", "\u06C7"], [[64473, 64474], "mapped", "\u06C6"], [[64475, 64476], "mapped", "\u06C8"], [[64477, 64477], "mapped", "\u06C7\u0674"], [[64478, 64479], "mapped", "\u06CB"], [[64480, 64481], "mapped", "\u06C5"], [[64482, 64483], "mapped", "\u06C9"], [[64484, 64487], "mapped", "\u06D0"], [[64488, 64489], "mapped", "\u0649"], [[64490, 64491], "mapped", "\u0626\u0627"], [[64492, 64493], "mapped", "\u0626\u06D5"], [[64494, 64495], "mapped", "\u0626\u0648"], [[64496, 64497], "mapped", "\u0626\u06C7"], [[64498, 64499], "mapped", "\u0626\u06C6"], [[64500, 64501], "mapped", "\u0626\u06C8"], [[64502, 64504], "mapped", "\u0626\u06D0"], [[64505, 64507], "mapped", "\u0626\u0649"], [[64508, 64511], "mapped", "\u06CC"], [[64512, 64512], "mapped", "\u0626\u062C"], [[64513, 64513], "mapped", "\u0626\u062D"], [[64514, 64514], "mapped", "\u0626\u0645"], [[64515, 64515], "mapped", "\u0626\u0649"], [[64516, 64516], "mapped", "\u0626\u064A"], [[64517, 64517], "mapped", "\u0628\u062C"], [[64518, 64518], "mapped", "\u0628\u062D"], [[64519, 64519], "mapped", "\u0628\u062E"], [[64520, 64520], "mapped", "\u0628\u0645"], [[64521, 64521], "mapped", "\u0628\u0649"], [[64522, 64522], "mapped", "\u0628\u064A"], [[64523, 64523], "mapped", "\u062A\u062C"], [[64524, 64524], "mapped", "\u062A\u062D"], [[64525, 64525], "mapped", "\u062A\u062E"], [[64526, 64526], "mapped", "\u062A\u0645"], [[64527, 64527], "mapped", "\u062A\u0649"], [[64528, 64528], "mapped", "\u062A\u064A"], [[64529, 64529], "mapped", "\u062B\u062C"], [[64530, 64530], "mapped", "\u062B\u0645"], [[64531, 64531], "mapped", "\u062B\u0649"], [[64532, 64532], "mapped", "\u062B\u064A"], [[64533, 64533], "mapped", "\u062C\u062D"], [[64534, 64534], "mapped", "\u062C\u0645"], [[64535, 64535], "mapped", "\u062D\u062C"], [[64536, 64536], "mapped", "\u062D\u0645"], [[64537, 64537], "mapped", "\u062E\u062C"], [[64538, 64538], "mapped", "\u062E\u062D"], [[64539, 64539], "mapped", "\u062E\u0645"], [[64540, 64540], "mapped", "\u0633\u062C"], [[64541, 64541], "mapped", "\u0633\u062D"], [[64542, 64542], "mapped", "\u0633\u062E"], [[64543, 64543], "mapped", "\u0633\u0645"], [[64544, 64544], "mapped", "\u0635\u062D"], [[64545, 64545], "mapped", "\u0635\u0645"], [[64546, 64546], "mapped", "\u0636\u062C"], [[64547, 64547], "mapped", "\u0636\u062D"], [[64548, 64548], "mapped", "\u0636\u062E"], [[64549, 64549], "mapped", "\u0636\u0645"], [[64550, 64550], "mapped", "\u0637\u062D"], [[64551, 64551], "mapped", "\u0637\u0645"], [[64552, 64552], "mapped", "\u0638\u0645"], [[64553, 64553], "mapped", "\u0639\u062C"], [[64554, 64554], "mapped", "\u0639\u0645"], [[64555, 64555], "mapped", "\u063A\u062C"], [[64556, 64556], "mapped", "\u063A\u0645"], [[64557, 64557], "mapped", "\u0641\u062C"], [[64558, 64558], "mapped", "\u0641\u062D"], [[64559, 64559], "mapped", "\u0641\u062E"], [[64560, 64560], "mapped", "\u0641\u0645"], [[64561, 64561], "mapped", "\u0641\u0649"], [[64562, 64562], "mapped", "\u0641\u064A"], [[64563, 64563], "mapped", "\u0642\u062D"], [[64564, 64564], "mapped", "\u0642\u0645"], [[64565, 64565], "mapped", "\u0642\u0649"], [[64566, 64566], "mapped", "\u0642\u064A"], [[64567, 64567], "mapped", "\u0643\u0627"], [[64568, 64568], "mapped", "\u0643\u062C"], [[64569, 64569], "mapped", "\u0643\u062D"], [[64570, 64570], "mapped", "\u0643\u062E"], [[64571, 64571], "mapped", "\u0643\u0644"], [[64572, 64572], "mapped", "\u0643\u0645"], [[64573, 64573], "mapped", "\u0643\u0649"], [[64574, 64574], "mapped", "\u0643\u064A"], [[64575, 64575], "mapped", "\u0644\u062C"], [[64576, 64576], "mapped", "\u0644\u062D"], [[64577, 64577], "mapped", "\u0644\u062E"], [[64578, 64578], "mapped", "\u0644\u0645"], [[64579, 64579], "mapped", "\u0644\u0649"], [[64580, 64580], "mapped", "\u0644\u064A"], [[64581, 64581], "mapped", "\u0645\u062C"], [[64582, 64582], "mapped", "\u0645\u062D"], [[64583, 64583], "mapped", "\u0645\u062E"], [[64584, 64584], "mapped", "\u0645\u0645"], [[64585, 64585], "mapped", "\u0645\u0649"], [[64586, 64586], "mapped", "\u0645\u064A"], [[64587, 64587], "mapped", "\u0646\u062C"], [[64588, 64588], "mapped", "\u0646\u062D"], [[64589, 64589], "mapped", "\u0646\u062E"], [[64590, 64590], "mapped", "\u0646\u0645"], [[64591, 64591], "mapped", "\u0646\u0649"], [[64592, 64592], "mapped", "\u0646\u064A"], [[64593, 64593], "mapped", "\u0647\u062C"], [[64594, 64594], "mapped", "\u0647\u0645"], [[64595, 64595], "mapped", "\u0647\u0649"], [[64596, 64596], "mapped", "\u0647\u064A"], [[64597, 64597], "mapped", "\u064A\u062C"], [[64598, 64598], "mapped", "\u064A\u062D"], [[64599, 64599], "mapped", "\u064A\u062E"], [[64600, 64600], "mapped", "\u064A\u0645"], [[64601, 64601], "mapped", "\u064A\u0649"], [[64602, 64602], "mapped", "\u064A\u064A"], [[64603, 64603], "mapped", "\u0630\u0670"], [[64604, 64604], "mapped", "\u0631\u0670"], [[64605, 64605], "mapped", "\u0649\u0670"], [[64606, 64606], "disallowed_STD3_mapped", " \u064C\u0651"], [[64607, 64607], "disallowed_STD3_mapped", " \u064D\u0651"], [[64608, 64608], "disallowed_STD3_mapped", " \u064E\u0651"], [[64609, 64609], "disallowed_STD3_mapped", " \u064F\u0651"], [[64610, 64610], "disallowed_STD3_mapped", " \u0650\u0651"], [[64611, 64611], "disallowed_STD3_mapped", " \u0651\u0670"], [[64612, 64612], "mapped", "\u0626\u0631"], [[64613, 64613], "mapped", "\u0626\u0632"], [[64614, 64614], "mapped", "\u0626\u0645"], [[64615, 64615], "mapped", "\u0626\u0646"], [[64616, 64616], "mapped", "\u0626\u0649"], [[64617, 64617], "mapped", "\u0626\u064A"], [[64618, 64618], "mapped", "\u0628\u0631"], [[64619, 64619], "mapped", "\u0628\u0632"], [[64620, 64620], "mapped", "\u0628\u0645"], [[64621, 64621], "mapped", "\u0628\u0646"], [[64622, 64622], "mapped", "\u0628\u0649"], [[64623, 64623], "mapped", "\u0628\u064A"], [[64624, 64624], "mapped", "\u062A\u0631"], [[64625, 64625], "mapped", "\u062A\u0632"], [[64626, 64626], "mapped", "\u062A\u0645"], [[64627, 64627], "mapped", "\u062A\u0646"], [[64628, 64628], "mapped", "\u062A\u0649"], [[64629, 64629], "mapped", "\u062A\u064A"], [[64630, 64630], "mapped", "\u062B\u0631"], [[64631, 64631], "mapped", "\u062B\u0632"], [[64632, 64632], "mapped", "\u062B\u0645"], [[64633, 64633], "mapped", "\u062B\u0646"], [[64634, 64634], "mapped", "\u062B\u0649"], [[64635, 64635], "mapped", "\u062B\u064A"], [[64636, 64636], "mapped", "\u0641\u0649"], [[64637, 64637], "mapped", "\u0641\u064A"], [[64638, 64638], "mapped", "\u0642\u0649"], [[64639, 64639], "mapped", "\u0642\u064A"], [[64640, 64640], "mapped", "\u0643\u0627"], [[64641, 64641], "mapped", "\u0643\u0644"], [[64642, 64642], "mapped", "\u0643\u0645"], [[64643, 64643], "mapped", "\u0643\u0649"], [[64644, 64644], "mapped", "\u0643\u064A"], [[64645, 64645], "mapped", "\u0644\u0645"], [[64646, 64646], "mapped", "\u0644\u0649"], [[64647, 64647], "mapped", "\u0644\u064A"], [[64648, 64648], "mapped", "\u0645\u0627"], [[64649, 64649], "mapped", "\u0645\u0645"], [[64650, 64650], "mapped", "\u0646\u0631"], [[64651, 64651], "mapped", "\u0646\u0632"], [[64652, 64652], "mapped", "\u0646\u0645"], [[64653, 64653], "mapped", "\u0646\u0646"], [[64654, 64654], "mapped", "\u0646\u0649"], [[64655, 64655], "mapped", "\u0646\u064A"], [[64656, 64656], "mapped", "\u0649\u0670"], [[64657, 64657], "mapped", "\u064A\u0631"], [[64658, 64658], "mapped", "\u064A\u0632"], [[64659, 64659], "mapped", "\u064A\u0645"], [[64660, 64660], "mapped", "\u064A\u0646"], [[64661, 64661], "mapped", "\u064A\u0649"], [[64662, 64662], "mapped", "\u064A\u064A"], [[64663, 64663], "mapped", "\u0626\u062C"], [[64664, 64664], "mapped", "\u0626\u062D"], [[64665, 64665], "mapped", "\u0626\u062E"], [[64666, 64666], "mapped", "\u0626\u0645"], [[64667, 64667], "mapped", "\u0626\u0647"], [[64668, 64668], "mapped", "\u0628\u062C"], [[64669, 64669], "mapped", "\u0628\u062D"], [[64670, 64670], "mapped", "\u0628\u062E"], [[64671, 64671], "mapped", "\u0628\u0645"], [[64672, 64672], "mapped", "\u0628\u0647"], [[64673, 64673], "mapped", "\u062A\u062C"], [[64674, 64674], "mapped", "\u062A\u062D"], [[64675, 64675], "mapped", "\u062A\u062E"], [[64676, 64676], "mapped", "\u062A\u0645"], [[64677, 64677], "mapped", "\u062A\u0647"], [[64678, 64678], "mapped", "\u062B\u0645"], [[64679, 64679], "mapped", "\u062C\u062D"], [[64680, 64680], "mapped", "\u062C\u0645"], [[64681, 64681], "mapped", "\u062D\u062C"], [[64682, 64682], "mapped", "\u062D\u0645"], [[64683, 64683], "mapped", "\u062E\u062C"], [[64684, 64684], "mapped", "\u062E\u0645"], [[64685, 64685], "mapped", "\u0633\u062C"], [[64686, 64686], "mapped", "\u0633\u062D"], [[64687, 64687], "mapped", "\u0633\u062E"], [[64688, 64688], "mapped", "\u0633\u0645"], [[64689, 64689], "mapped", "\u0635\u062D"], [[64690, 64690], "mapped", "\u0635\u062E"], [[64691, 64691], "mapped", "\u0635\u0645"], [[64692, 64692], "mapped", "\u0636\u062C"], [[64693, 64693], "mapped", "\u0636\u062D"], [[64694, 64694], "mapped", "\u0636\u062E"], [[64695, 64695], "mapped", "\u0636\u0645"], [[64696, 64696], "mapped", "\u0637\u062D"], [[64697, 64697], "mapped", "\u0638\u0645"], [[64698, 64698], "mapped", "\u0639\u062C"], [[64699, 64699], "mapped", "\u0639\u0645"], [[64700, 64700], "mapped", "\u063A\u062C"], [[64701, 64701], "mapped", "\u063A\u0645"], [[64702, 64702], "mapped", "\u0641\u062C"], [[64703, 64703], "mapped", "\u0641\u062D"], [[64704, 64704], "mapped", "\u0641\u062E"], [[64705, 64705], "mapped", "\u0641\u0645"], [[64706, 64706], "mapped", "\u0642\u062D"], [[64707, 64707], "mapped", "\u0642\u0645"], [[64708, 64708], "mapped", "\u0643\u062C"], [[64709, 64709], "mapped", "\u0643\u062D"], [[64710, 64710], "mapped", "\u0643\u062E"], [[64711, 64711], "mapped", "\u0643\u0644"], [[64712, 64712], "mapped", "\u0643\u0645"], [[64713, 64713], "mapped", "\u0644\u062C"], [[64714, 64714], "mapped", "\u0644\u062D"], [[64715, 64715], "mapped", "\u0644\u062E"], [[64716, 64716], "mapped", "\u0644\u0645"], [[64717, 64717], "mapped", "\u0644\u0647"], [[64718, 64718], "mapped", "\u0645\u062C"], [[64719, 64719], "mapped", "\u0645\u062D"], [[64720, 64720], "mapped", "\u0645\u062E"], [[64721, 64721], "mapped", "\u0645\u0645"], [[64722, 64722], "mapped", "\u0646\u062C"], [[64723, 64723], "mapped", "\u0646\u062D"], [[64724, 64724], "mapped", "\u0646\u062E"], [[64725, 64725], "mapped", "\u0646\u0645"], [[64726, 64726], "mapped", "\u0646\u0647"], [[64727, 64727], "mapped", "\u0647\u062C"], [[64728, 64728], "mapped", "\u0647\u0645"], [[64729, 64729], "mapped", "\u0647\u0670"], [[64730, 64730], "mapped", "\u064A\u062C"], [[64731, 64731], "mapped", "\u064A\u062D"], [[64732, 64732], "mapped", "\u064A\u062E"], [[64733, 64733], "mapped", "\u064A\u0645"], [[64734, 64734], "mapped", "\u064A\u0647"], [[64735, 64735], "mapped", "\u0626\u0645"], [[64736, 64736], "mapped", "\u0626\u0647"], [[64737, 64737], "mapped", "\u0628\u0645"], [[64738, 64738], "mapped", "\u0628\u0647"], [[64739, 64739], "mapped", "\u062A\u0645"], [[64740, 64740], "mapped", "\u062A\u0647"], [[64741, 64741], "mapped", "\u062B\u0645"], [[64742, 64742], "mapped", "\u062B\u0647"], [[64743, 64743], "mapped", "\u0633\u0645"], [[64744, 64744], "mapped", "\u0633\u0647"], [[64745, 64745], "mapped", "\u0634\u0645"], [[64746, 64746], "mapped", "\u0634\u0647"], [[64747, 64747], "mapped", "\u0643\u0644"], [[64748, 64748], "mapped", "\u0643\u0645"], [[64749, 64749], "mapped", "\u0644\u0645"], [[64750, 64750], "mapped", "\u0646\u0645"], [[64751, 64751], "mapped", "\u0646\u0647"], [[64752, 64752], "mapped", "\u064A\u0645"], [[64753, 64753], "mapped", "\u064A\u0647"], [[64754, 64754], "mapped", "\u0640\u064E\u0651"], [[64755, 64755], "mapped", "\u0640\u064F\u0651"], [[64756, 64756], "mapped", "\u0640\u0650\u0651"], [[64757, 64757], "mapped", "\u0637\u0649"], [[64758, 64758], "mapped", "\u0637\u064A"], [[64759, 64759], "mapped", "\u0639\u0649"], [[64760, 64760], "mapped", "\u0639\u064A"], [[64761, 64761], "mapped", "\u063A\u0649"], [[64762, 64762], "mapped", "\u063A\u064A"], [[64763, 64763], "mapped", "\u0633\u0649"], [[64764, 64764], "mapped", "\u0633\u064A"], [[64765, 64765], "mapped", "\u0634\u0649"], [[64766, 64766], "mapped", "\u0634\u064A"], [[64767, 64767], "mapped", "\u062D\u0649"], [[64768, 64768], "mapped", "\u062D\u064A"], [[64769, 64769], "mapped", "\u062C\u0649"], [[64770, 64770], "mapped", "\u062C\u064A"], [[64771, 64771], "mapped", "\u062E\u0649"], [[64772, 64772], "mapped", "\u062E\u064A"], [[64773, 64773], "mapped", "\u0635\u0649"], [[64774, 64774], "mapped", "\u0635\u064A"], [[64775, 64775], "mapped", "\u0636\u0649"], [[64776, 64776], "mapped", "\u0636\u064A"], [[64777, 64777], "mapped", "\u0634\u062C"], [[64778, 64778], "mapped", "\u0634\u062D"], [[64779, 64779], "mapped", "\u0634\u062E"], [[64780, 64780], "mapped", "\u0634\u0645"], [[64781, 64781], "mapped", "\u0634\u0631"], [[64782, 64782], "mapped", "\u0633\u0631"], [[64783, 64783], "mapped", "\u0635\u0631"], [[64784, 64784], "mapped", "\u0636\u0631"], [[64785, 64785], "mapped", "\u0637\u0649"], [[64786, 64786], "mapped", "\u0637\u064A"], [[64787, 64787], "mapped", "\u0639\u0649"], [[64788, 64788], "mapped", "\u0639\u064A"], [[64789, 64789], "mapped", "\u063A\u0649"], [[64790, 64790], "mapped", "\u063A\u064A"], [[64791, 64791], "mapped", "\u0633\u0649"], [[64792, 64792], "mapped", "\u0633\u064A"], [[64793, 64793], "mapped", "\u0634\u0649"], [[64794, 64794], "mapped", "\u0634\u064A"], [[64795, 64795], "mapped", "\u062D\u0649"], [[64796, 64796], "mapped", "\u062D\u064A"], [[64797, 64797], "mapped", "\u062C\u0649"], [[64798, 64798], "mapped", "\u062C\u064A"], [[64799, 64799], "mapped", "\u062E\u0649"], [[64800, 64800], "mapped", "\u062E\u064A"], [[64801, 64801], "mapped", "\u0635\u0649"], [[64802, 64802], "mapped", "\u0635\u064A"], [[64803, 64803], "mapped", "\u0636\u0649"], [[64804, 64804], "mapped", "\u0636\u064A"], [[64805, 64805], "mapped", "\u0634\u062C"], [[64806, 64806], "mapped", "\u0634\u062D"], [[64807, 64807], "mapped", "\u0634\u062E"], [[64808, 64808], "mapped", "\u0634\u0645"], [[64809, 64809], "mapped", "\u0634\u0631"], [[64810, 64810], "mapped", "\u0633\u0631"], [[64811, 64811], "mapped", "\u0635\u0631"], [[64812, 64812], "mapped", "\u0636\u0631"], [[64813, 64813], "mapped", "\u0634\u062C"], [[64814, 64814], "mapped", "\u0634\u062D"], [[64815, 64815], "mapped", "\u0634\u062E"], [[64816, 64816], "mapped", "\u0634\u0645"], [[64817, 64817], "mapped", "\u0633\u0647"], [[64818, 64818], "mapped", "\u0634\u0647"], [[64819, 64819], "mapped", "\u0637\u0645"], [[64820, 64820], "mapped", "\u0633\u062C"], [[64821, 64821], "mapped", "\u0633\u062D"], [[64822, 64822], "mapped", "\u0633\u062E"], [[64823, 64823], "mapped", "\u0634\u062C"], [[64824, 64824], "mapped", "\u0634\u062D"], [[64825, 64825], "mapped", "\u0634\u062E"], [[64826, 64826], "mapped", "\u0637\u0645"], [[64827, 64827], "mapped", "\u0638\u0645"], [[64828, 64829], "mapped", "\u0627\u064B"], [[64830, 64831], "valid", "", "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", "\u062A\u062C\u0645"], [[64849, 64850], "mapped", "\u062A\u062D\u062C"], [[64851, 64851], "mapped", "\u062A\u062D\u0645"], [[64852, 64852], "mapped", "\u062A\u062E\u0645"], [[64853, 64853], "mapped", "\u062A\u0645\u062C"], [[64854, 64854], "mapped", "\u062A\u0645\u062D"], [[64855, 64855], "mapped", "\u062A\u0645\u062E"], [[64856, 64857], "mapped", "\u062C\u0645\u062D"], [[64858, 64858], "mapped", "\u062D\u0645\u064A"], [[64859, 64859], "mapped", "\u062D\u0645\u0649"], [[64860, 64860], "mapped", "\u0633\u062D\u062C"], [[64861, 64861], "mapped", "\u0633\u062C\u062D"], [[64862, 64862], "mapped", "\u0633\u062C\u0649"], [[64863, 64864], "mapped", "\u0633\u0645\u062D"], [[64865, 64865], "mapped", "\u0633\u0645\u062C"], [[64866, 64867], "mapped", "\u0633\u0645\u0645"], [[64868, 64869], "mapped", "\u0635\u062D\u062D"], [[64870, 64870], "mapped", "\u0635\u0645\u0645"], [[64871, 64872], "mapped", "\u0634\u062D\u0645"], [[64873, 64873], "mapped", "\u0634\u062C\u064A"], [[64874, 64875], "mapped", "\u0634\u0645\u062E"], [[64876, 64877], "mapped", "\u0634\u0645\u0645"], [[64878, 64878], "mapped", "\u0636\u062D\u0649"], [[64879, 64880], "mapped", "\u0636\u062E\u0645"], [[64881, 64882], "mapped", "\u0637\u0645\u062D"], [[64883, 64883], "mapped", "\u0637\u0645\u0645"], [[64884, 64884], "mapped", "\u0637\u0645\u064A"], [[64885, 64885], "mapped", "\u0639\u062C\u0645"], [[64886, 64887], "mapped", "\u0639\u0645\u0645"], [[64888, 64888], "mapped", "\u0639\u0645\u0649"], [[64889, 64889], "mapped", "\u063A\u0645\u0645"], [[64890, 64890], "mapped", "\u063A\u0645\u064A"], [[64891, 64891], "mapped", "\u063A\u0645\u0649"], [[64892, 64893], "mapped", "\u0641\u062E\u0645"], [[64894, 64894], "mapped", "\u0642\u0645\u062D"], [[64895, 64895], "mapped", "\u0642\u0645\u0645"], [[64896, 64896], "mapped", "\u0644\u062D\u0645"], [[64897, 64897], "mapped", "\u0644\u062D\u064A"], [[64898, 64898], "mapped", "\u0644\u062D\u0649"], [[64899, 64900], "mapped", "\u0644\u062C\u062C"], [[64901, 64902], "mapped", "\u0644\u062E\u0645"], [[64903, 64904], "mapped", "\u0644\u0645\u062D"], [[64905, 64905], "mapped", "\u0645\u062D\u062C"], [[64906, 64906], "mapped", "\u0645\u062D\u0645"], [[64907, 64907], "mapped", "\u0645\u062D\u064A"], [[64908, 64908], "mapped", "\u0645\u062C\u062D"], [[64909, 64909], "mapped", "\u0645\u062C\u0645"], [[64910, 64910], "mapped", "\u0645\u062E\u062C"], [[64911, 64911], "mapped", "\u0645\u062E\u0645"], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", "\u0645\u062C\u062E"], [[64915, 64915], "mapped", "\u0647\u0645\u062C"], [[64916, 64916], "mapped", "\u0647\u0645\u0645"], [[64917, 64917], "mapped", "\u0646\u062D\u0645"], [[64918, 64918], "mapped", "\u0646\u062D\u0649"], [[64919, 64920], "mapped", "\u0646\u062C\u0645"], [[64921, 64921], "mapped", "\u0646\u062C\u0649"], [[64922, 64922], "mapped", "\u0646\u0645\u064A"], [[64923, 64923], "mapped", "\u0646\u0645\u0649"], [[64924, 64925], "mapped", "\u064A\u0645\u0645"], [[64926, 64926], "mapped", "\u0628\u062E\u064A"], [[64927, 64927], "mapped", "\u062A\u062C\u064A"], [[64928, 64928], "mapped", "\u062A\u062C\u0649"], [[64929, 64929], "mapped", "\u062A\u062E\u064A"], [[64930, 64930], "mapped", "\u062A\u062E\u0649"], [[64931, 64931], "mapped", "\u062A\u0645\u064A"], [[64932, 64932], "mapped", "\u062A\u0645\u0649"], [[64933, 64933], "mapped", "\u062C\u0645\u064A"], [[64934, 64934], "mapped", "\u062C\u062D\u0649"], [[64935, 64935], "mapped", "\u062C\u0645\u0649"], [[64936, 64936], "mapped", "\u0633\u062E\u0649"], [[64937, 64937], "mapped", "\u0635\u062D\u064A"], [[64938, 64938], "mapped", "\u0634\u062D\u064A"], [[64939, 64939], "mapped", "\u0636\u062D\u064A"], [[64940, 64940], "mapped", "\u0644\u062C\u064A"], [[64941, 64941], "mapped", "\u0644\u0645\u064A"], [[64942, 64942], "mapped", "\u064A\u062D\u064A"], [[64943, 64943], "mapped", "\u064A\u062C\u064A"], [[64944, 64944], "mapped", "\u064A\u0645\u064A"], [[64945, 64945], "mapped", "\u0645\u0645\u064A"], [[64946, 64946], "mapped", "\u0642\u0645\u064A"], [[64947, 64947], "mapped", "\u0646\u062D\u064A"], [[64948, 64948], "mapped", "\u0642\u0645\u062D"], [[64949, 64949], "mapped", "\u0644\u062D\u0645"], [[64950, 64950], "mapped", "\u0639\u0645\u064A"], [[64951, 64951], "mapped", "\u0643\u0645\u064A"], [[64952, 64952], "mapped", "\u0646\u062C\u062D"], [[64953, 64953], "mapped", "\u0645\u062E\u064A"], [[64954, 64954], "mapped", "\u0644\u062C\u0645"], [[64955, 64955], "mapped", "\u0643\u0645\u0645"], [[64956, 64956], "mapped", "\u0644\u062C\u0645"], [[64957, 64957], "mapped", "\u0646\u062C\u062D"], [[64958, 64958], "mapped", "\u062C\u062D\u064A"], [[64959, 64959], "mapped", "\u062D\u062C\u064A"], [[64960, 64960], "mapped", "\u0645\u062C\u064A"], [[64961, 64961], "mapped", "\u0641\u0645\u064A"], [[64962, 64962], "mapped", "\u0628\u062D\u064A"], [[64963, 64963], "mapped", "\u0643\u0645\u0645"], [[64964, 64964], "mapped", "\u0639\u062C\u0645"], [[64965, 64965], "mapped", "\u0635\u0645\u0645"], [[64966, 64966], "mapped", "\u0633\u062E\u064A"], [[64967, 64967], "mapped", "\u0646\u062C\u064A"], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", "\u0635\u0644\u06D2"], [[65009, 65009], "mapped", "\u0642\u0644\u06D2"], [[65010, 65010], "mapped", "\u0627\u0644\u0644\u0647"], [[65011, 65011], "mapped", "\u0627\u0643\u0628\u0631"], [[65012, 65012], "mapped", "\u0645\u062D\u0645\u062F"], [[65013, 65013], "mapped", "\u0635\u0644\u0639\u0645"], [[65014, 65014], "mapped", "\u0631\u0633\u0648\u0644"], [[65015, 65015], "mapped", "\u0639\u0644\u064A\u0647"], [[65016, 65016], "mapped", "\u0648\u0633\u0644\u0645"], [[65017, 65017], "mapped", "\u0635\u0644\u0649"], [[65018, 65018], "disallowed_STD3_mapped", "\u0635\u0644\u0649 \u0627\u0644\u0644\u0647 \u0639\u0644\u064A\u0647 \u0648\u0633\u0644\u0645"], [[65019, 65019], "disallowed_STD3_mapped", "\u062C\u0644 \u062C\u0644\u0627\u0644\u0647"], [[65020, 65020], "mapped", "\u0631\u06CC\u0627\u0644"], [[65021, 65021], "valid", "", "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", ","], [[65041, 65041], "mapped", "\u3001"], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", ":"], [[65044, 65044], "disallowed_STD3_mapped", ";"], [[65045, 65045], "disallowed_STD3_mapped", "!"], [[65046, 65046], "disallowed_STD3_mapped", "?"], [[65047, 65047], "mapped", "\u3016"], [[65048, 65048], "mapped", "\u3017"], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", "\u2014"], [[65074, 65074], "mapped", "\u2013"], [[65075, 65076], "disallowed_STD3_mapped", "_"], [[65077, 65077], "disallowed_STD3_mapped", "("], [[65078, 65078], "disallowed_STD3_mapped", ")"], [[65079, 65079], "disallowed_STD3_mapped", "{"], [[65080, 65080], "disallowed_STD3_mapped", "}"], [[65081, 65081], "mapped", "\u3014"], [[65082, 65082], "mapped", "\u3015"], [[65083, 65083], "mapped", "\u3010"], [[65084, 65084], "mapped", "\u3011"], [[65085, 65085], "mapped", "\u300A"], [[65086, 65086], "mapped", "\u300B"], [[65087, 65087], "mapped", "\u3008"], [[65088, 65088], "mapped", "\u3009"], [[65089, 65089], "mapped", "\u300C"], [[65090, 65090], "mapped", "\u300D"], [[65091, 65091], "mapped", "\u300E"], [[65092, 65092], "mapped", "\u300F"], [[65093, 65094], "valid", "", "NV8"], [[65095, 65095], "disallowed_STD3_mapped", "["], [[65096, 65096], "disallowed_STD3_mapped", "]"], [[65097, 65100], "disallowed_STD3_mapped", " \u0305"], [[65101, 65103], "disallowed_STD3_mapped", "_"], [[65104, 65104], "disallowed_STD3_mapped", ","], [[65105, 65105], "mapped", "\u3001"], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", ";"], [[65109, 65109], "disallowed_STD3_mapped", ":"], [[65110, 65110], "disallowed_STD3_mapped", "?"], [[65111, 65111], "disallowed_STD3_mapped", "!"], [[65112, 65112], "mapped", "\u2014"], [[65113, 65113], "disallowed_STD3_mapped", "("], [[65114, 65114], "disallowed_STD3_mapped", ")"], [[65115, 65115], "disallowed_STD3_mapped", "{"], [[65116, 65116], "disallowed_STD3_mapped", "}"], [[65117, 65117], "mapped", "\u3014"], [[65118, 65118], "mapped", "\u3015"], [[65119, 65119], "disallowed_STD3_mapped", "#"], [[65120, 65120], "disallowed_STD3_mapped", "&"], [[65121, 65121], "disallowed_STD3_mapped", "*"], [[65122, 65122], "disallowed_STD3_mapped", "+"], [[65123, 65123], "mapped", "-"], [[65124, 65124], "disallowed_STD3_mapped", "<"], [[65125, 65125], "disallowed_STD3_mapped", ">"], [[65126, 65126], "disallowed_STD3_mapped", "="], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", "\\"], [[65129, 65129], "disallowed_STD3_mapped", "$"], [[65130, 65130], "disallowed_STD3_mapped", "%"], [[65131, 65131], "disallowed_STD3_mapped", "@"], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", " \u064B"], [[65137, 65137], "mapped", "\u0640\u064B"], [[65138, 65138], "disallowed_STD3_mapped", " \u064C"], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", " \u064D"], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", " \u064E"], [[65143, 65143], "mapped", "\u0640\u064E"], [[65144, 65144], "disallowed_STD3_mapped", " \u064F"], [[65145, 65145], "mapped", "\u0640\u064F"], [[65146, 65146], "disallowed_STD3_mapped", " \u0650"], [[65147, 65147], "mapped", "\u0640\u0650"], [[65148, 65148], "disallowed_STD3_mapped", " \u0651"], [[65149, 65149], "mapped", "\u0640\u0651"], [[65150, 65150], "disallowed_STD3_mapped", " \u0652"], [[65151, 65151], "mapped", "\u0640\u0652"], [[65152, 65152], "mapped", "\u0621"], [[65153, 65154], "mapped", "\u0622"], [[65155, 65156], "mapped", "\u0623"], [[65157, 65158], "mapped", "\u0624"], [[65159, 65160], "mapped", "\u0625"], [[65161, 65164], "mapped", "\u0626"], [[65165, 65166], "mapped", "\u0627"], [[65167, 65170], "mapped", "\u0628"], [[65171, 65172], "mapped", "\u0629"], [[65173, 65176], "mapped", "\u062A"], [[65177, 65180], "mapped", "\u062B"], [[65181, 65184], "mapped", "\u062C"], [[65185, 65188], "mapped", "\u062D"], [[65189, 65192], "mapped", "\u062E"], [[65193, 65194], "mapped", "\u062F"], [[65195, 65196], "mapped", "\u0630"], [[65197, 65198], "mapped", "\u0631"], [[65199, 65200], "mapped", "\u0632"], [[65201, 65204], "mapped", "\u0633"], [[65205, 65208], "mapped", "\u0634"], [[65209, 65212], "mapped", "\u0635"], [[65213, 65216], "mapped", "\u0636"], [[65217, 65220], "mapped", "\u0637"], [[65221, 65224], "mapped", "\u0638"], [[65225, 65228], "mapped", "\u0639"], [[65229, 65232], "mapped", "\u063A"], [[65233, 65236], "mapped", "\u0641"], [[65237, 65240], "mapped", "\u0642"], [[65241, 65244], "mapped", "\u0643"], [[65245, 65248], "mapped", "\u0644"], [[65249, 65252], "mapped", "\u0645"], [[65253, 65256], "mapped", "\u0646"], [[65257, 65260], "mapped", "\u0647"], [[65261, 65262], "mapped", "\u0648"], [[65263, 65264], "mapped", "\u0649"], [[65265, 65268], "mapped", "\u064A"], [[65269, 65270], "mapped", "\u0644\u0622"], [[65271, 65272], "mapped", "\u0644\u0623"], [[65273, 65274], "mapped", "\u0644\u0625"], [[65275, 65276], "mapped", "\u0644\u0627"], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", "!"], [[65282, 65282], "disallowed_STD3_mapped", '"'], [[65283, 65283], "disallowed_STD3_mapped", "#"], [[65284, 65284], "disallowed_STD3_mapped", "$"], [[65285, 65285], "disallowed_STD3_mapped", "%"], [[65286, 65286], "disallowed_STD3_mapped", "&"], [[65287, 65287], "disallowed_STD3_mapped", "'"], [[65288, 65288], "disallowed_STD3_mapped", "("], [[65289, 65289], "disallowed_STD3_mapped", ")"], [[65290, 65290], "disallowed_STD3_mapped", "*"], [[65291, 65291], "disallowed_STD3_mapped", "+"], [[65292, 65292], "disallowed_STD3_mapped", ","], [[65293, 65293], "mapped", "-"], [[65294, 65294], "mapped", "."], [[65295, 65295], "disallowed_STD3_mapped", "/"], [[65296, 65296], "mapped", "0"], [[65297, 65297], "mapped", "1"], [[65298, 65298], "mapped", "2"], [[65299, 65299], "mapped", "3"], [[65300, 65300], "mapped", "4"], [[65301, 65301], "mapped", "5"], [[65302, 65302], "mapped", "6"], [[65303, 65303], "mapped", "7"], [[65304, 65304], "mapped", "8"], [[65305, 65305], "mapped", "9"], [[65306, 65306], "disallowed_STD3_mapped", ":"], [[65307, 65307], "disallowed_STD3_mapped", ";"], [[65308, 65308], "disallowed_STD3_mapped", "<"], [[65309, 65309], "disallowed_STD3_mapped", "="], [[65310, 65310], "disallowed_STD3_mapped", ">"], [[65311, 65311], "disallowed_STD3_mapped", "?"], [[65312, 65312], "disallowed_STD3_mapped", "@"], [[65313, 65313], "mapped", "a"], [[65314, 65314], "mapped", "b"], [[65315, 65315], "mapped", "c"], [[65316, 65316], "mapped", "d"], [[65317, 65317], "mapped", "e"], [[65318, 65318], "mapped", "f"], [[65319, 65319], "mapped", "g"], [[65320, 65320], "mapped", "h"], [[65321, 65321], "mapped", "i"], [[65322, 65322], "mapped", "j"], [[65323, 65323], "mapped", "k"], [[65324, 65324], "mapped", "l"], [[65325, 65325], "mapped", "m"], [[65326, 65326], "mapped", "n"], [[65327, 65327], "mapped", "o"], [[65328, 65328], "mapped", "p"], [[65329, 65329], "mapped", "q"], [[65330, 65330], "mapped", "r"], [[65331, 65331], "mapped", "s"], [[65332, 65332], "mapped", "t"], [[65333, 65333], "mapped", "u"], [[65334, 65334], "mapped", "v"], [[65335, 65335], "mapped", "w"], [[65336, 65336], "mapped", "x"], [[65337, 65337], "mapped", "y"], [[65338, 65338], "mapped", "z"], [[65339, 65339], "disallowed_STD3_mapped", "["], [[65340, 65340], "disallowed_STD3_mapped", "\\"], [[65341, 65341], "disallowed_STD3_mapped", "]"], [[65342, 65342], "disallowed_STD3_mapped", "^"], [[65343, 65343], "disallowed_STD3_mapped", "_"], [[65344, 65344], "disallowed_STD3_mapped", "`"], [[65345, 65345], "mapped", "a"], [[65346, 65346], "mapped", "b"], [[65347, 65347], "mapped", "c"], [[65348, 65348], "mapped", "d"], [[65349, 65349], "mapped", "e"], [[65350, 65350], "mapped", "f"], [[65351, 65351], "mapped", "g"], [[65352, 65352], "mapped", "h"], [[65353, 65353], "mapped", "i"], [[65354, 65354], "mapped", "j"], [[65355, 65355], "mapped", "k"], [[65356, 65356], "mapped", "l"], [[65357, 65357], "mapped", "m"], [[65358, 65358], "mapped", "n"], [[65359, 65359], "mapped", "o"], [[65360, 65360], "mapped", "p"], [[65361, 65361], "mapped", "q"], [[65362, 65362], "mapped", "r"], [[65363, 65363], "mapped", "s"], [[65364, 65364], "mapped", "t"], [[65365, 65365], "mapped", "u"], [[65366, 65366], "mapped", "v"], [[65367, 65367], "mapped", "w"], [[65368, 65368], "mapped", "x"], [[65369, 65369], "mapped", "y"], [[65370, 65370], "mapped", "z"], [[65371, 65371], "disallowed_STD3_mapped", "{"], [[65372, 65372], "disallowed_STD3_mapped", "|"], [[65373, 65373], "disallowed_STD3_mapped", "}"], [[65374, 65374], "disallowed_STD3_mapped", "~"], [[65375, 65375], "mapped", "\u2985"], [[65376, 65376], "mapped", "\u2986"], [[65377, 65377], "mapped", "."], [[65378, 65378], "mapped", "\u300C"], [[65379, 65379], "mapped", "\u300D"], [[65380, 65380], "mapped", "\u3001"], [[65381, 65381], "mapped", "\u30FB"], [[65382, 65382], "mapped", "\u30F2"], [[65383, 65383], "mapped", "\u30A1"], [[65384, 65384], "mapped", "\u30A3"], [[65385, 65385], "mapped", "\u30A5"], [[65386, 65386], "mapped", "\u30A7"], [[65387, 65387], "mapped", "\u30A9"], [[65388, 65388], "mapped", "\u30E3"], [[65389, 65389], "mapped", "\u30E5"], [[65390, 65390], "mapped", "\u30E7"], [[65391, 65391], "mapped", "\u30C3"], [[65392, 65392], "mapped", "\u30FC"], [[65393, 65393], "mapped", "\u30A2"], [[65394, 65394], "mapped", "\u30A4"], [[65395, 65395], "mapped", "\u30A6"], [[65396, 65396], "mapped", "\u30A8"], [[65397, 65397], "mapped", "\u30AA"], [[65398, 65398], "mapped", "\u30AB"], [[65399, 65399], "mapped", "\u30AD"], [[65400, 65400], "mapped", "\u30AF"], [[65401, 65401], "mapped", "\u30B1"], [[65402, 65402], "mapped", "\u30B3"], [[65403, 65403], "mapped", "\u30B5"], [[65404, 65404], "mapped", "\u30B7"], [[65405, 65405], "mapped", "\u30B9"], [[65406, 65406], "mapped", "\u30BB"], [[65407, 65407], "mapped", "\u30BD"], [[65408, 65408], "mapped", "\u30BF"], [[65409, 65409], "mapped", "\u30C1"], [[65410, 65410], "mapped", "\u30C4"], [[65411, 65411], "mapped", "\u30C6"], [[65412, 65412], "mapped", "\u30C8"], [[65413, 65413], "mapped", "\u30CA"], [[65414, 65414], "mapped", "\u30CB"], [[65415, 65415], "mapped", "\u30CC"], [[65416, 65416], "mapped", "\u30CD"], [[65417, 65417], "mapped", "\u30CE"], [[65418, 65418], "mapped", "\u30CF"], [[65419, 65419], "mapped", "\u30D2"], [[65420, 65420], "mapped", "\u30D5"], [[65421, 65421], "mapped", "\u30D8"], [[65422, 65422], "mapped", "\u30DB"], [[65423, 65423], "mapped", "\u30DE"], [[65424, 65424], "mapped", "\u30DF"], [[65425, 65425], "mapped", "\u30E0"], [[65426, 65426], "mapped", "\u30E1"], [[65427, 65427], "mapped", "\u30E2"], [[65428, 65428], "mapped", "\u30E4"], [[65429, 65429], "mapped", "\u30E6"], [[65430, 65430], "mapped", "\u30E8"], [[65431, 65431], "mapped", "\u30E9"], [[65432, 65432], "mapped", "\u30EA"], [[65433, 65433], "mapped", "\u30EB"], [[65434, 65434], "mapped", "\u30EC"], [[65435, 65435], "mapped", "\u30ED"], [[65436, 65436], "mapped", "\u30EF"], [[65437, 65437], "mapped", "\u30F3"], [[65438, 65438], "mapped", "\u3099"], [[65439, 65439], "mapped", "\u309A"], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", "\u1100"], [[65442, 65442], "mapped", "\u1101"], [[65443, 65443], "mapped", "\u11AA"], [[65444, 65444], "mapped", "\u1102"], [[65445, 65445], "mapped", "\u11AC"], [[65446, 65446], "mapped", "\u11AD"], [[65447, 65447], "mapped", "\u1103"], [[65448, 65448], "mapped", "\u1104"], [[65449, 65449], "mapped", "\u1105"], [[65450, 65450], "mapped", "\u11B0"], [[65451, 65451], "mapped", "\u11B1"], [[65452, 65452], "mapped", "\u11B2"], [[65453, 65453], "mapped", "\u11B3"], [[65454, 65454], "mapped", "\u11B4"], [[65455, 65455], "mapped", "\u11B5"], [[65456, 65456], "mapped", "\u111A"], [[65457, 65457], "mapped", "\u1106"], [[65458, 65458], "mapped", "\u1107"], [[65459, 65459], "mapped", "\u1108"], [[65460, 65460], "mapped", "\u1121"], [[65461, 65461], "mapped", "\u1109"], [[65462, 65462], "mapped", "\u110A"], [[65463, 65463], "mapped", "\u110B"], [[65464, 65464], "mapped", "\u110C"], [[65465, 65465], "mapped", "\u110D"], [[65466, 65466], "mapped", "\u110E"], [[65467, 65467], "mapped", "\u110F"], [[65468, 65468], "mapped", "\u1110"], [[65469, 65469], "mapped", "\u1111"], [[65470, 65470], "mapped", "\u1112"], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", "\u1161"], [[65475, 65475], "mapped", "\u1162"], [[65476, 65476], "mapped", "\u1163"], [[65477, 65477], "mapped", "\u1164"], [[65478, 65478], "mapped", "\u1165"], [[65479, 65479], "mapped", "\u1166"], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", "\u1167"], [[65483, 65483], "mapped", "\u1168"], [[65484, 65484], "mapped", "\u1169"], [[65485, 65485], "mapped", "\u116A"], [[65486, 65486], "mapped", "\u116B"], [[65487, 65487], "mapped", "\u116C"], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", "\u116D"], [[65491, 65491], "mapped", "\u116E"], [[65492, 65492], "mapped", "\u116F"], [[65493, 65493], "mapped", "\u1170"], [[65494, 65494], "mapped", "\u1171"], [[65495, 65495], "mapped", "\u1172"], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", "\u1173"], [[65499, 65499], "mapped", "\u1174"], [[65500, 65500], "mapped", "\u1175"], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", "\xA2"], [[65505, 65505], "mapped", "\xA3"], [[65506, 65506], "mapped", "\xAC"], [[65507, 65507], "disallowed_STD3_mapped", " \u0304"], [[65508, 65508], "mapped", "\xA6"], [[65509, 65509], "mapped", "\xA5"], [[65510, 65510], "mapped", "\u20A9"], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", "\u2502"], [[65513, 65513], "mapped", "\u2190"], [[65514, 65514], "mapped", "\u2191"], [[65515, 65515], "mapped", "\u2192"], [[65516, 65516], "mapped", "\u2193"], [[65517, 65517], "mapped", "\u25A0"], [[65518, 65518], "mapped", "\u25CB"], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", "", "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", "", "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", "", "NV8"], [[65856, 65930], "valid", "", "NV8"], [[65931, 65932], "valid", "", "NV8"], [[65933, 65934], "valid", "", "NV8"], [[65935, 65935], "disallowed"], [[65936, 65947], "valid", "", "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", "", "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", "", "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", "", "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", "", "NV8"], [[66340, 66348], "disallowed"], [[66349, 66351], "valid"], [[66352, 66368], "valid"], [[66369, 66369], "valid", "", "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", "", "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", "", "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", "", "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", "\u{10428}"], [[66561, 66561], "mapped", "\u{10429}"], [[66562, 66562], "mapped", "\u{1042A}"], [[66563, 66563], "mapped", "\u{1042B}"], [[66564, 66564], "mapped", "\u{1042C}"], [[66565, 66565], "mapped", "\u{1042D}"], [[66566, 66566], "mapped", "\u{1042E}"], [[66567, 66567], "mapped", "\u{1042F}"], [[66568, 66568], "mapped", "\u{10430}"], [[66569, 66569], "mapped", "\u{10431}"], [[66570, 66570], "mapped", "\u{10432}"], [[66571, 66571], "mapped", "\u{10433}"], [[66572, 66572], "mapped", "\u{10434}"], [[66573, 66573], "mapped", "\u{10435}"], [[66574, 66574], "mapped", "\u{10436}"], [[66575, 66575], "mapped", "\u{10437}"], [[66576, 66576], "mapped", "\u{10438}"], [[66577, 66577], "mapped", "\u{10439}"], [[66578, 66578], "mapped", "\u{1043A}"], [[66579, 66579], "mapped", "\u{1043B}"], [[66580, 66580], "mapped", "\u{1043C}"], [[66581, 66581], "mapped", "\u{1043D}"], [[66582, 66582], "mapped", "\u{1043E}"], [[66583, 66583], "mapped", "\u{1043F}"], [[66584, 66584], "mapped", "\u{10440}"], [[66585, 66585], "mapped", "\u{10441}"], [[66586, 66586], "mapped", "\u{10442}"], [[66587, 66587], "mapped", "\u{10443}"], [[66588, 66588], "mapped", "\u{10444}"], [[66589, 66589], "mapped", "\u{10445}"], [[66590, 66590], "mapped", "\u{10446}"], [[66591, 66591], "mapped", "\u{10447}"], [[66592, 66592], "mapped", "\u{10448}"], [[66593, 66593], "mapped", "\u{10449}"], [[66594, 66594], "mapped", "\u{1044A}"], [[66595, 66595], "mapped", "\u{1044B}"], [[66596, 66596], "mapped", "\u{1044C}"], [[66597, 66597], "mapped", "\u{1044D}"], [[66598, 66598], "mapped", "\u{1044E}"], [[66599, 66599], "mapped", "\u{1044F}"], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66735], "disallowed"], [[66736, 66736], "mapped", "\u{104D8}"], [[66737, 66737], "mapped", "\u{104D9}"], [[66738, 66738], "mapped", "\u{104DA}"], [[66739, 66739], "mapped", "\u{104DB}"], [[66740, 66740], "mapped", "\u{104DC}"], [[66741, 66741], "mapped", "\u{104DD}"], [[66742, 66742], "mapped", "\u{104DE}"], [[66743, 66743], "mapped", "\u{104DF}"], [[66744, 66744], "mapped", "\u{104E0}"], [[66745, 66745], "mapped", "\u{104E1}"], [[66746, 66746], "mapped", "\u{104E2}"], [[66747, 66747], "mapped", "\u{104E3}"], [[66748, 66748], "mapped", "\u{104E4}"], [[66749, 66749], "mapped", "\u{104E5}"], [[66750, 66750], "mapped", "\u{104E6}"], [[66751, 66751], "mapped", "\u{104E7}"], [[66752, 66752], "mapped", "\u{104E8}"], [[66753, 66753], "mapped", "\u{104E9}"], [[66754, 66754], "mapped", "\u{104EA}"], [[66755, 66755], "mapped", "\u{104EB}"], [[66756, 66756], "mapped", "\u{104EC}"], [[66757, 66757], "mapped", "\u{104ED}"], [[66758, 66758], "mapped", "\u{104EE}"], [[66759, 66759], "mapped", "\u{104EF}"], [[66760, 66760], "mapped", "\u{104F0}"], [[66761, 66761], "mapped", "\u{104F1}"], [[66762, 66762], "mapped", "\u{104F2}"], [[66763, 66763], "mapped", "\u{104F3}"], [[66764, 66764], "mapped", "\u{104F4}"], [[66765, 66765], "mapped", "\u{104F5}"], [[66766, 66766], "mapped", "\u{104F6}"], [[66767, 66767], "mapped", "\u{104F7}"], [[66768, 66768], "mapped", "\u{104F8}"], [[66769, 66769], "mapped", "\u{104F9}"], [[66770, 66770], "mapped", "\u{104FA}"], [[66771, 66771], "mapped", "\u{104FB}"], [[66772, 66775], "disallowed"], [[66776, 66811], "valid"], [[66812, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", "", "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", "", "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", "", "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", "", "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", "", "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", "", "NV8"], [[67866, 67867], "valid", "", "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", "", "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", "", "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", "", "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", "", "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", "", "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", "", "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", "", "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", "", "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", "", "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", "", "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", "", "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", "", "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", "", "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", "", "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", "", "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", "", "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", "\u{10CC0}"], [[68737, 68737], "mapped", "\u{10CC1}"], [[68738, 68738], "mapped", "\u{10CC2}"], [[68739, 68739], "mapped", "\u{10CC3}"], [[68740, 68740], "mapped", "\u{10CC4}"], [[68741, 68741], "mapped", "\u{10CC5}"], [[68742, 68742], "mapped", "\u{10CC6}"], [[68743, 68743], "mapped", "\u{10CC7}"], [[68744, 68744], "mapped", "\u{10CC8}"], [[68745, 68745], "mapped", "\u{10CC9}"], [[68746, 68746], "mapped", "\u{10CCA}"], [[68747, 68747], "mapped", "\u{10CCB}"], [[68748, 68748], "mapped", "\u{10CCC}"], [[68749, 68749], "mapped", "\u{10CCD}"], [[68750, 68750], "mapped", "\u{10CCE}"], [[68751, 68751], "mapped", "\u{10CCF}"], [[68752, 68752], "mapped", "\u{10CD0}"], [[68753, 68753], "mapped", "\u{10CD1}"], [[68754, 68754], "mapped", "\u{10CD2}"], [[68755, 68755], "mapped", "\u{10CD3}"], [[68756, 68756], "mapped", "\u{10CD4}"], [[68757, 68757], "mapped", "\u{10CD5}"], [[68758, 68758], "mapped", "\u{10CD6}"], [[68759, 68759], "mapped", "\u{10CD7}"], [[68760, 68760], "mapped", "\u{10CD8}"], [[68761, 68761], "mapped", "\u{10CD9}"], [[68762, 68762], "mapped", "\u{10CDA}"], [[68763, 68763], "mapped", "\u{10CDB}"], [[68764, 68764], "mapped", "\u{10CDC}"], [[68765, 68765], "mapped", "\u{10CDD}"], [[68766, 68766], "mapped", "\u{10CDE}"], [[68767, 68767], "mapped", "\u{10CDF}"], [[68768, 68768], "mapped", "\u{10CE0}"], [[68769, 68769], "mapped", "\u{10CE1}"], [[68770, 68770], "mapped", "\u{10CE2}"], [[68771, 68771], "mapped", "\u{10CE3}"], [[68772, 68772], "mapped", "\u{10CE4}"], [[68773, 68773], "mapped", "\u{10CE5}"], [[68774, 68774], "mapped", "\u{10CE6}"], [[68775, 68775], "mapped", "\u{10CE7}"], [[68776, 68776], "mapped", "\u{10CE8}"], [[68777, 68777], "mapped", "\u{10CE9}"], [[68778, 68778], "mapped", "\u{10CEA}"], [[68779, 68779], "mapped", "\u{10CEB}"], [[68780, 68780], "mapped", "\u{10CEC}"], [[68781, 68781], "mapped", "\u{10CED}"], [[68782, 68782], "mapped", "\u{10CEE}"], [[68783, 68783], "mapped", "\u{10CEF}"], [[68784, 68784], "mapped", "\u{10CF0}"], [[68785, 68785], "mapped", "\u{10CF1}"], [[68786, 68786], "mapped", "\u{10CF2}"], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", "", "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", "", "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", "", "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", "", "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", "", "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", "", "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", "", "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", "", "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", "", "NV8"], [[70089, 70089], "valid", "", "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", "", "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", "", "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", "", "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", "", "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", "", "NV8"], [[70206, 70206], "valid"], [[70207, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", "", "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70655], "disallowed"], [[70656, 70730], "valid"], [[70731, 70735], "valid", "", "NV8"], [[70736, 70745], "valid"], [[70746, 70746], "disallowed"], [[70747, 70747], "valid", "", "NV8"], [[70748, 70748], "disallowed"], [[70749, 70749], "valid", "", "NV8"], [[70750, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", "", "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", "", "NV8"], [[71114, 71127], "valid", "", "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", "", "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71263], "disallowed"], [[71264, 71276], "valid", "", "NV8"], [[71277, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", "", "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", "\u{118C0}"], [[71841, 71841], "mapped", "\u{118C1}"], [[71842, 71842], "mapped", "\u{118C2}"], [[71843, 71843], "mapped", "\u{118C3}"], [[71844, 71844], "mapped", "\u{118C4}"], [[71845, 71845], "mapped", "\u{118C5}"], [[71846, 71846], "mapped", "\u{118C6}"], [[71847, 71847], "mapped", "\u{118C7}"], [[71848, 71848], "mapped", "\u{118C8}"], [[71849, 71849], "mapped", "\u{118C9}"], [[71850, 71850], "mapped", "\u{118CA}"], [[71851, 71851], "mapped", "\u{118CB}"], [[71852, 71852], "mapped", "\u{118CC}"], [[71853, 71853], "mapped", "\u{118CD}"], [[71854, 71854], "mapped", "\u{118CE}"], [[71855, 71855], "mapped", "\u{118CF}"], [[71856, 71856], "mapped", "\u{118D0}"], [[71857, 71857], "mapped", "\u{118D1}"], [[71858, 71858], "mapped", "\u{118D2}"], [[71859, 71859], "mapped", "\u{118D3}"], [[71860, 71860], "mapped", "\u{118D4}"], [[71861, 71861], "mapped", "\u{118D5}"], [[71862, 71862], "mapped", "\u{118D6}"], [[71863, 71863], "mapped", "\u{118D7}"], [[71864, 71864], "mapped", "\u{118D8}"], [[71865, 71865], "mapped", "\u{118D9}"], [[71866, 71866], "mapped", "\u{118DA}"], [[71867, 71867], "mapped", "\u{118DB}"], [[71868, 71868], "mapped", "\u{118DC}"], [[71869, 71869], "mapped", "\u{118DD}"], [[71870, 71870], "mapped", "\u{118DE}"], [[71871, 71871], "mapped", "\u{118DF}"], [[71872, 71913], "valid"], [[71914, 71922], "valid", "", "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72191], "disallowed"], [[72192, 72254], "valid"], [[72255, 72262], "valid", "", "NV8"], [[72263, 72263], "valid"], [[72264, 72271], "disallowed"], [[72272, 72323], "valid"], [[72324, 72325], "disallowed"], [[72326, 72345], "valid"], [[72346, 72348], "valid", "", "NV8"], [[72349, 72349], "disallowed"], [[72350, 72354], "valid", "", "NV8"], [[72355, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 72703], "disallowed"], [[72704, 72712], "valid"], [[72713, 72713], "disallowed"], [[72714, 72758], "valid"], [[72759, 72759], "disallowed"], [[72760, 72768], "valid"], [[72769, 72773], "valid", "", "NV8"], [[72774, 72783], "disallowed"], [[72784, 72793], "valid"], [[72794, 72812], "valid", "", "NV8"], [[72813, 72815], "disallowed"], [[72816, 72817], "valid", "", "NV8"], [[72818, 72847], "valid"], [[72848, 72849], "disallowed"], [[72850, 72871], "valid"], [[72872, 72872], "disallowed"], [[72873, 72886], "valid"], [[72887, 72959], "disallowed"], [[72960, 72966], "valid"], [[72967, 72967], "disallowed"], [[72968, 72969], "valid"], [[72970, 72970], "disallowed"], [[72971, 73014], "valid"], [[73015, 73017], "disallowed"], [[73018, 73018], "valid"], [[73019, 73019], "disallowed"], [[73020, 73021], "valid"], [[73022, 73022], "disallowed"], [[73023, 73031], "valid"], [[73032, 73039], "disallowed"], [[73040, 73049], "valid"], [[73050, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", "", "NV8"], [[74851, 74862], "valid", "", "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", "", "NV8"], [[74868, 74868], "valid", "", "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", "", "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", "", "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", "", "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", "", "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", "", "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 94175], "disallowed"], [[94176, 94176], "valid"], [[94177, 94177], "valid"], [[94178, 94207], "disallowed"], [[94208, 100332], "valid"], [[100333, 100351], "disallowed"], [[100352, 101106], "valid"], [[101107, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 110878], "valid"], [[110879, 110959], "disallowed"], [[110960, 111355], "valid"], [[111356, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", "", "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", "", "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", "", "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", "", "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", "", "NV8"], [[119082, 119133], "valid", "", "NV8"], [[119134, 119134], "mapped", "\u{1D157}\u{1D165}"], [[119135, 119135], "mapped", "\u{1D158}\u{1D165}"], [[119136, 119136], "mapped", "\u{1D158}\u{1D165}\u{1D16E}"], [[119137, 119137], "mapped", "\u{1D158}\u{1D165}\u{1D16F}"], [[119138, 119138], "mapped", "\u{1D158}\u{1D165}\u{1D170}"], [[119139, 119139], "mapped", "\u{1D158}\u{1D165}\u{1D171}"], [[119140, 119140], "mapped", "\u{1D158}\u{1D165}\u{1D172}"], [[119141, 119154], "valid", "", "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", "", "NV8"], [[119227, 119227], "mapped", "\u{1D1B9}\u{1D165}"], [[119228, 119228], "mapped", "\u{1D1BA}\u{1D165}"], [[119229, 119229], "mapped", "\u{1D1B9}\u{1D165}\u{1D16E}"], [[119230, 119230], "mapped", "\u{1D1BA}\u{1D165}\u{1D16E}"], [[119231, 119231], "mapped", "\u{1D1B9}\u{1D165}\u{1D16F}"], [[119232, 119232], "mapped", "\u{1D1BA}\u{1D165}\u{1D16F}"], [[119233, 119261], "valid", "", "NV8"], [[119262, 119272], "valid", "", "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", "", "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", "", "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", "", "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", "a"], [[119809, 119809], "mapped", "b"], [[119810, 119810], "mapped", "c"], [[119811, 119811], "mapped", "d"], [[119812, 119812], "mapped", "e"], [[119813, 119813], "mapped", "f"], [[119814, 119814], "mapped", "g"], [[119815, 119815], "mapped", "h"], [[119816, 119816], "mapped", "i"], [[119817, 119817], "mapped", "j"], [[119818, 119818], "mapped", "k"], [[119819, 119819], "mapped", "l"], [[119820, 119820], "mapped", "m"], [[119821, 119821], "mapped", "n"], [[119822, 119822], "mapped", "o"], [[119823, 119823], "mapped", "p"], [[119824, 119824], "mapped", "q"], [[119825, 119825], "mapped", "r"], [[119826, 119826], "mapped", "s"], [[119827, 119827], "mapped", "t"], [[119828, 119828], "mapped", "u"], [[119829, 119829], "mapped", "v"], [[119830, 119830], "mapped", "w"], [[119831, 119831], "mapped", "x"], [[119832, 119832], "mapped", "y"], [[119833, 119833], "mapped", "z"], [[119834, 119834], "mapped", "a"], [[119835, 119835], "mapped", "b"], [[119836, 119836], "mapped", "c"], [[119837, 119837], "mapped", "d"], [[119838, 119838], "mapped", "e"], [[119839, 119839], "mapped", "f"], [[119840, 119840], "mapped", "g"], [[119841, 119841], "mapped", "h"], [[119842, 119842], "mapped", "i"], [[119843, 119843], "mapped", "j"], [[119844, 119844], "mapped", "k"], [[119845, 119845], "mapped", "l"], [[119846, 119846], "mapped", "m"], [[119847, 119847], "mapped", "n"], [[119848, 119848], "mapped", "o"], [[119849, 119849], "mapped", "p"], [[119850, 119850], "mapped", "q"], [[119851, 119851], "mapped", "r"], [[119852, 119852], "mapped", "s"], [[119853, 119853], "mapped", "t"], [[119854, 119854], "mapped", "u"], [[119855, 119855], "mapped", "v"], [[119856, 119856], "mapped", "w"], [[119857, 119857], "mapped", "x"], [[119858, 119858], "mapped", "y"], [[119859, 119859], "mapped", "z"], [[119860, 119860], "mapped", "a"], [[119861, 119861], "mapped", "b"], [[119862, 119862], "mapped", "c"], [[119863, 119863], "mapped", "d"], [[119864, 119864], "mapped", "e"], [[119865, 119865], "mapped", "f"], [[119866, 119866], "mapped", "g"], [[119867, 119867], "mapped", "h"], [[119868, 119868], "mapped", "i"], [[119869, 119869], "mapped", "j"], [[119870, 119870], "mapped", "k"], [[119871, 119871], "mapped", "l"], [[119872, 119872], "mapped", "m"], [[119873, 119873], "mapped", "n"], [[119874, 119874], "mapped", "o"], [[119875, 119875], "mapped", "p"], [[119876, 119876], "mapped", "q"], [[119877, 119877], "mapped", "r"], [[119878, 119878], "mapped", "s"], [[119879, 119879], "mapped", "t"], [[119880, 119880], "mapped", "u"], [[119881, 119881], "mapped", "v"], [[119882, 119882], "mapped", "w"], [[119883, 119883], "mapped", "x"], [[119884, 119884], "mapped", "y"], [[119885, 119885], "mapped", "z"], [[119886, 119886], "mapped", "a"], [[119887, 119887], "mapped", "b"], [[119888, 119888], "mapped", "c"], [[119889, 119889], "mapped", "d"], [[119890, 119890], "mapped", "e"], [[119891, 119891], "mapped", "f"], [[119892, 119892], "mapped", "g"], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", "i"], [[119895, 119895], "mapped", "j"], [[119896, 119896], "mapped", "k"], [[119897, 119897], "mapped", "l"], [[119898, 119898], "mapped", "m"], [[119899, 119899], "mapped", "n"], [[119900, 119900], "mapped", "o"], [[119901, 119901], "mapped", "p"], [[119902, 119902], "mapped", "q"], [[119903, 119903], "mapped", "r"], [[119904, 119904], "mapped", "s"], [[119905, 119905], "mapped", "t"], [[119906, 119906], "mapped", "u"], [[119907, 119907], "mapped", "v"], [[119908, 119908], "mapped", "w"], [[119909, 119909], "mapped", "x"], [[119910, 119910], "mapped", "y"], [[119911, 119911], "mapped", "z"], [[119912, 119912], "mapped", "a"], [[119913, 119913], "mapped", "b"], [[119914, 119914], "mapped", "c"], [[119915, 119915], "mapped", "d"], [[119916, 119916], "mapped", "e"], [[119917, 119917], "mapped", "f"], [[119918, 119918], "mapped", "g"], [[119919, 119919], "mapped", "h"], [[119920, 119920], "mapped", "i"], [[119921, 119921], "mapped", "j"], [[119922, 119922], "mapped", "k"], [[119923, 119923], "mapped", "l"], [[119924, 119924], "mapped", "m"], [[119925, 119925], "mapped", "n"], [[119926, 119926], "mapped", "o"], [[119927, 119927], "mapped", "p"], [[119928, 119928], "mapped", "q"], [[119929, 119929], "mapped", "r"], [[119930, 119930], "mapped", "s"], [[119931, 119931], "mapped", "t"], [[119932, 119932], "mapped", "u"], [[119933, 119933], "mapped", "v"], [[119934, 119934], "mapped", "w"], [[119935, 119935], "mapped", "x"], [[119936, 119936], "mapped", "y"], [[119937, 119937], "mapped", "z"], [[119938, 119938], "mapped", "a"], [[119939, 119939], "mapped", "b"], [[119940, 119940], "mapped", "c"], [[119941, 119941], "mapped", "d"], [[119942, 119942], "mapped", "e"], [[119943, 119943], "mapped", "f"], [[119944, 119944], "mapped", "g"], [[119945, 119945], "mapped", "h"], [[119946, 119946], "mapped", "i"], [[119947, 119947], "mapped", "j"], [[119948, 119948], "mapped", "k"], [[119949, 119949], "mapped", "l"], [[119950, 119950], "mapped", "m"], [[119951, 119951], "mapped", "n"], [[119952, 119952], "mapped", "o"], [[119953, 119953], "mapped", "p"], [[119954, 119954], "mapped", "q"], [[119955, 119955], "mapped", "r"], [[119956, 119956], "mapped", "s"], [[119957, 119957], "mapped", "t"], [[119958, 119958], "mapped", "u"], [[119959, 119959], "mapped", "v"], [[119960, 119960], "mapped", "w"], [[119961, 119961], "mapped", "x"], [[119962, 119962], "mapped", "y"], [[119963, 119963], "mapped", "z"], [[119964, 119964], "mapped", "a"], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", "c"], [[119967, 119967], "mapped", "d"], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", "g"], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", "j"], [[119974, 119974], "mapped", "k"], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", "n"], [[119978, 119978], "mapped", "o"], [[119979, 119979], "mapped", "p"], [[119980, 119980], "mapped", "q"], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", "s"], [[119983, 119983], "mapped", "t"], [[119984, 119984], "mapped", "u"], [[119985, 119985], "mapped", "v"], [[119986, 119986], "mapped", "w"], [[119987, 119987], "mapped", "x"], [[119988, 119988], "mapped", "y"], [[119989, 119989], "mapped", "z"], [[119990, 119990], "mapped", "a"], [[119991, 119991], "mapped", "b"], [[119992, 119992], "mapped", "c"], [[119993, 119993], "mapped", "d"], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", "f"], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", "h"], [[119998, 119998], "mapped", "i"], [[119999, 119999], "mapped", "j"], [[12e4, 12e4], "mapped", "k"], [[120001, 120001], "mapped", "l"], [[120002, 120002], "mapped", "m"], [[120003, 120003], "mapped", "n"], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", "p"], [[120006, 120006], "mapped", "q"], [[120007, 120007], "mapped", "r"], [[120008, 120008], "mapped", "s"], [[120009, 120009], "mapped", "t"], [[120010, 120010], "mapped", "u"], [[120011, 120011], "mapped", "v"], [[120012, 120012], "mapped", "w"], [[120013, 120013], "mapped", "x"], [[120014, 120014], "mapped", "y"], [[120015, 120015], "mapped", "z"], [[120016, 120016], "mapped", "a"], [[120017, 120017], "mapped", "b"], [[120018, 120018], "mapped", "c"], [[120019, 120019], "mapped", "d"], [[120020, 120020], "mapped", "e"], [[120021, 120021], "mapped", "f"], [[120022, 120022], "mapped", "g"], [[120023, 120023], "mapped", "h"], [[120024, 120024], "mapped", "i"], [[120025, 120025], "mapped", "j"], [[120026, 120026], "mapped", "k"], [[120027, 120027], "mapped", "l"], [[120028, 120028], "mapped", "m"], [[120029, 120029], "mapped", "n"], [[120030, 120030], "mapped", "o"], [[120031, 120031], "mapped", "p"], [[120032, 120032], "mapped", "q"], [[120033, 120033], "mapped", "r"], [[120034, 120034], "mapped", "s"], [[120035, 120035], "mapped", "t"], [[120036, 120036], "mapped", "u"], [[120037, 120037], "mapped", "v"], [[120038, 120038], "mapped", "w"], [[120039, 120039], "mapped", "x"], [[120040, 120040], "mapped", "y"], [[120041, 120041], "mapped", "z"], [[120042, 120042], "mapped", "a"], [[120043, 120043], "mapped", "b"], [[120044, 120044], "mapped", "c"], [[120045, 120045], "mapped", "d"], [[120046, 120046], "mapped", "e"], [[120047, 120047], "mapped", "f"], [[120048, 120048], "mapped", "g"], [[120049, 120049], "mapped", "h"], [[120050, 120050], "mapped", "i"], [[120051, 120051], "mapped", "j"], [[120052, 120052], "mapped", "k"], [[120053, 120053], "mapped", "l"], [[120054, 120054], "mapped", "m"], [[120055, 120055], "mapped", "n"], [[120056, 120056], "mapped", "o"], [[120057, 120057], "mapped", "p"], [[120058, 120058], "mapped", "q"], [[120059, 120059], "mapped", "r"], [[120060, 120060], "mapped", "s"], [[120061, 120061], "mapped", "t"], [[120062, 120062], "mapped", "u"], [[120063, 120063], "mapped", "v"], [[120064, 120064], "mapped", "w"], [[120065, 120065], "mapped", "x"], [[120066, 120066], "mapped", "y"], [[120067, 120067], "mapped", "z"], [[120068, 120068], "mapped", "a"], [[120069, 120069], "mapped", "b"], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", "d"], [[120072, 120072], "mapped", "e"], [[120073, 120073], "mapped", "f"], [[120074, 120074], "mapped", "g"], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", "j"], [[120078, 120078], "mapped", "k"], [[120079, 120079], "mapped", "l"], [[120080, 120080], "mapped", "m"], [[120081, 120081], "mapped", "n"], [[120082, 120082], "mapped", "o"], [[120083, 120083], "mapped", "p"], [[120084, 120084], "mapped", "q"], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", "s"], [[120087, 120087], "mapped", "t"], [[120088, 120088], "mapped", "u"], [[120089, 120089], "mapped", "v"], [[120090, 120090], "mapped", "w"], [[120091, 120091], "mapped", "x"], [[120092, 120092], "mapped", "y"], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", "a"], [[120095, 120095], "mapped", "b"], [[120096, 120096], "mapped", "c"], [[120097, 120097], "mapped", "d"], [[120098, 120098], "mapped", "e"], [[120099, 120099], "mapped", "f"], [[120100, 120100], "mapped", "g"], [[120101, 120101], "mapped", "h"], [[120102, 120102], "mapped", "i"], [[120103, 120103], "mapped", "j"], [[120104, 120104], "mapped", "k"], [[120105, 120105], "mapped", "l"], [[120106, 120106], "mapped", "m"], [[120107, 120107], "mapped", "n"], [[120108, 120108], "mapped", "o"], [[120109, 120109], "mapped", "p"], [[120110, 120110], "mapped", "q"], [[120111, 120111], "mapped", "r"], [[120112, 120112], "mapped", "s"], [[120113, 120113], "mapped", "t"], [[120114, 120114], "mapped", "u"], [[120115, 120115], "mapped", "v"], [[120116, 120116], "mapped", "w"], [[120117, 120117], "mapped", "x"], [[120118, 120118], "mapped", "y"], [[120119, 120119], "mapped", "z"], [[120120, 120120], "mapped", "a"], [[120121, 120121], "mapped", "b"], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", "d"], [[120124, 120124], "mapped", "e"], [[120125, 120125], "mapped", "f"], [[120126, 120126], "mapped", "g"], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", "i"], [[120129, 120129], "mapped", "j"], [[120130, 120130], "mapped", "k"], [[120131, 120131], "mapped", "l"], [[120132, 120132], "mapped", "m"], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", "o"], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", "s"], [[120139, 120139], "mapped", "t"], [[120140, 120140], "mapped", "u"], [[120141, 120141], "mapped", "v"], [[120142, 120142], "mapped", "w"], [[120143, 120143], "mapped", "x"], [[120144, 120144], "mapped", "y"], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", "a"], [[120147, 120147], "mapped", "b"], [[120148, 120148], "mapped", "c"], [[120149, 120149], "mapped", "d"], [[120150, 120150], "mapped", "e"], [[120151, 120151], "mapped", "f"], [[120152, 120152], "mapped", "g"], [[120153, 120153], "mapped", "h"], [[120154, 120154], "mapped", "i"], [[120155, 120155], "mapped", "j"], [[120156, 120156], "mapped", "k"], [[120157, 120157], "mapped", "l"], [[120158, 120158], "mapped", "m"], [[120159, 120159], "mapped", "n"], [[120160, 120160], "mapped", "o"], [[120161, 120161], "mapped", "p"], [[120162, 120162], "mapped", "q"], [[120163, 120163], "mapped", "r"], [[120164, 120164], "mapped", "s"], [[120165, 120165], "mapped", "t"], [[120166, 120166], "mapped", "u"], [[120167, 120167], "mapped", "v"], [[120168, 120168], "mapped", "w"], [[120169, 120169], "mapped", "x"], [[120170, 120170], "mapped", "y"], [[120171, 120171], "mapped", "z"], [[120172, 120172], "mapped", "a"], [[120173, 120173], "mapped", "b"], [[120174, 120174], "mapped", "c"], [[120175, 120175], "mapped", "d"], [[120176, 120176], "mapped", "e"], [[120177, 120177], "mapped", "f"], [[120178, 120178], "mapped", "g"], [[120179, 120179], "mapped", "h"], [[120180, 120180], "mapped", "i"], [[120181, 120181], "mapped", "j"], [[120182, 120182], "mapped", "k"], [[120183, 120183], "mapped", "l"], [[120184, 120184], "mapped", "m"], [[120185, 120185], "mapped", "n"], [[120186, 120186], "mapped", "o"], [[120187, 120187], "mapped", "p"], [[120188, 120188], "mapped", "q"], [[120189, 120189], "mapped", "r"], [[120190, 120190], "mapped", "s"], [[120191, 120191], "mapped", "t"], [[120192, 120192], "mapped", "u"], [[120193, 120193], "mapped", "v"], [[120194, 120194], "mapped", "w"], [[120195, 120195], "mapped", "x"], [[120196, 120196], "mapped", "y"], [[120197, 120197], "mapped", "z"], [[120198, 120198], "mapped", "a"], [[120199, 120199], "mapped", "b"], [[120200, 120200], "mapped", "c"], [[120201, 120201], "mapped", "d"], [[120202, 120202], "mapped", "e"], [[120203, 120203], "mapped", "f"], [[120204, 120204], "mapped", "g"], [[120205, 120205], "mapped", "h"], [[120206, 120206], "mapped", "i"], [[120207, 120207], "mapped", "j"], [[120208, 120208], "mapped", "k"], [[120209, 120209], "mapped", "l"], [[120210, 120210], "mapped", "m"], [[120211, 120211], "mapped", "n"], [[120212, 120212], "mapped", "o"], [[120213, 120213], "mapped", "p"], [[120214, 120214], "mapped", "q"], [[120215, 120215], "mapped", "r"], [[120216, 120216], "mapped", "s"], [[120217, 120217], "mapped", "t"], [[120218, 120218], "mapped", "u"], [[120219, 120219], "mapped", "v"], [[120220, 120220], "mapped", "w"], [[120221, 120221], "mapped", "x"], [[120222, 120222], "mapped", "y"], [[120223, 120223], "mapped", "z"], [[120224, 120224], "mapped", "a"], [[120225, 120225], "mapped", "b"], [[120226, 120226], "mapped", "c"], [[120227, 120227], "mapped", "d"], [[120228, 120228], "mapped", "e"], [[120229, 120229], "mapped", "f"], [[120230, 120230], "mapped", "g"], [[120231, 120231], "mapped", "h"], [[120232, 120232], "mapped", "i"], [[120233, 120233], "mapped", "j"], [[120234, 120234], "mapped", "k"], [[120235, 120235], "mapped", "l"], [[120236, 120236], "mapped", "m"], [[120237, 120237], "mapped", "n"], [[120238, 120238], "mapped", "o"], [[120239, 120239], "mapped", "p"], [[120240, 120240], "mapped", "q"], [[120241, 120241], "mapped", "r"], [[120242, 120242], "mapped", "s"], [[120243, 120243], "mapped", "t"], [[120244, 120244], "mapped", "u"], [[120245, 120245], "mapped", "v"], [[120246, 120246], "mapped", "w"], [[120247, 120247], "mapped", "x"], [[120248, 120248], "mapped", "y"], [[120249, 120249], "mapped", "z"], [[120250, 120250], "mapped", "a"], [[120251, 120251], "mapped", "b"], [[120252, 120252], "mapped", "c"], [[120253, 120253], "mapped", "d"], [[120254, 120254], "mapped", "e"], [[120255, 120255], "mapped", "f"], [[120256, 120256], "mapped", "g"], [[120257, 120257], "mapped", "h"], [[120258, 120258], "mapped", "i"], [[120259, 120259], "mapped", "j"], [[120260, 120260], "mapped", "k"], [[120261, 120261], "mapped", "l"], [[120262, 120262], "mapped", "m"], [[120263, 120263], "mapped", "n"], [[120264, 120264], "mapped", "o"], [[120265, 120265], "mapped", "p"], [[120266, 120266], "mapped", "q"], [[120267, 120267], "mapped", "r"], [[120268, 120268], "mapped", "s"], [[120269, 120269], "mapped", "t"], [[120270, 120270], "mapped", "u"], [[120271, 120271], "mapped", "v"], [[120272, 120272], "mapped", "w"], [[120273, 120273], "mapped", "x"], [[120274, 120274], "mapped", "y"], [[120275, 120275], "mapped", "z"], [[120276, 120276], "mapped", "a"], [[120277, 120277], "mapped", "b"], [[120278, 120278], "mapped", "c"], [[120279, 120279], "mapped", "d"], [[120280, 120280], "mapped", "e"], [[120281, 120281], "mapped", "f"], [[120282, 120282], "mapped", "g"], [[120283, 120283], "mapped", "h"], [[120284, 120284], "mapped", "i"], [[120285, 120285], "mapped", "j"], [[120286, 120286], "mapped", "k"], [[120287, 120287], "mapped", "l"], [[120288, 120288], "mapped", "m"], [[120289, 120289], "mapped", "n"], [[120290, 120290], "mapped", "o"], [[120291, 120291], "mapped", "p"], [[120292, 120292], "mapped", "q"], [[120293, 120293], "mapped", "r"], [[120294, 120294], "mapped", "s"], [[120295, 120295], "mapped", "t"], [[120296, 120296], "mapped", "u"], [[120297, 120297], "mapped", "v"], [[120298, 120298], "mapped", "w"], [[120299, 120299], "mapped", "x"], [[120300, 120300], "mapped", "y"], [[120301, 120301], "mapped", "z"], [[120302, 120302], "mapped", "a"], [[120303, 120303], "mapped", "b"], [[120304, 120304], "mapped", "c"], [[120305, 120305], "mapped", "d"], [[120306, 120306], "mapped", "e"], [[120307, 120307], "mapped", "f"], [[120308, 120308], "mapped", "g"], [[120309, 120309], "mapped", "h"], [[120310, 120310], "mapped", "i"], [[120311, 120311], "mapped", "j"], [[120312, 120312], "mapped", "k"], [[120313, 120313], "mapped", "l"], [[120314, 120314], "mapped", "m"], [[120315, 120315], "mapped", "n"], [[120316, 120316], "mapped", "o"], [[120317, 120317], "mapped", "p"], [[120318, 120318], "mapped", "q"], [[120319, 120319], "mapped", "r"], [[120320, 120320], "mapped", "s"], [[120321, 120321], "mapped", "t"], [[120322, 120322], "mapped", "u"], [[120323, 120323], "mapped", "v"], [[120324, 120324], "mapped", "w"], [[120325, 120325], "mapped", "x"], [[120326, 120326], "mapped", "y"], [[120327, 120327], "mapped", "z"], [[120328, 120328], "mapped", "a"], [[120329, 120329], "mapped", "b"], [[120330, 120330], "mapped", "c"], [[120331, 120331], "mapped", "d"], [[120332, 120332], "mapped", "e"], [[120333, 120333], "mapped", "f"], [[120334, 120334], "mapped", "g"], [[120335, 120335], "mapped", "h"], [[120336, 120336], "mapped", "i"], [[120337, 120337], "mapped", "j"], [[120338, 120338], "mapped", "k"], [[120339, 120339], "mapped", "l"], [[120340, 120340], "mapped", "m"], [[120341, 120341], "mapped", "n"], [[120342, 120342], "mapped", "o"], [[120343, 120343], "mapped", "p"], [[120344, 120344], "mapped", "q"], [[120345, 120345], "mapped", "r"], [[120346, 120346], "mapped", "s"], [[120347, 120347], "mapped", "t"], [[120348, 120348], "mapped", "u"], [[120349, 120349], "mapped", "v"], [[120350, 120350], "mapped", "w"], [[120351, 120351], "mapped", "x"], [[120352, 120352], "mapped", "y"], [[120353, 120353], "mapped", "z"], [[120354, 120354], "mapped", "a"], [[120355, 120355], "mapped", "b"], [[120356, 120356], "mapped", "c"], [[120357, 120357], "mapped", "d"], [[120358, 120358], "mapped", "e"], [[120359, 120359], "mapped", "f"], [[120360, 120360], "mapped", "g"], [[120361, 120361], "mapped", "h"], [[120362, 120362], "mapped", "i"], [[120363, 120363], "mapped", "j"], [[120364, 120364], "mapped", "k"], [[120365, 120365], "mapped", "l"], [[120366, 120366], "mapped", "m"], [[120367, 120367], "mapped", "n"], [[120368, 120368], "mapped", "o"], [[120369, 120369], "mapped", "p"], [[120370, 120370], "mapped", "q"], [[120371, 120371], "mapped", "r"], [[120372, 120372], "mapped", "s"], [[120373, 120373], "mapped", "t"], [[120374, 120374], "mapped", "u"], [[120375, 120375], "mapped", "v"], [[120376, 120376], "mapped", "w"], [[120377, 120377], "mapped", "x"], [[120378, 120378], "mapped", "y"], [[120379, 120379], "mapped", "z"], [[120380, 120380], "mapped", "a"], [[120381, 120381], "mapped", "b"], [[120382, 120382], "mapped", "c"], [[120383, 120383], "mapped", "d"], [[120384, 120384], "mapped", "e"], [[120385, 120385], "mapped", "f"], [[120386, 120386], "mapped", "g"], [[120387, 120387], "mapped", "h"], [[120388, 120388], "mapped", "i"], [[120389, 120389], "mapped", "j"], [[120390, 120390], "mapped", "k"], [[120391, 120391], "mapped", "l"], [[120392, 120392], "mapped", "m"], [[120393, 120393], "mapped", "n"], [[120394, 120394], "mapped", "o"], [[120395, 120395], "mapped", "p"], [[120396, 120396], "mapped", "q"], [[120397, 120397], "mapped", "r"], [[120398, 120398], "mapped", "s"], [[120399, 120399], "mapped", "t"], [[120400, 120400], "mapped", "u"], [[120401, 120401], "mapped", "v"], [[120402, 120402], "mapped", "w"], [[120403, 120403], "mapped", "x"], [[120404, 120404], "mapped", "y"], [[120405, 120405], "mapped", "z"], [[120406, 120406], "mapped", "a"], [[120407, 120407], "mapped", "b"], [[120408, 120408], "mapped", "c"], [[120409, 120409], "mapped", "d"], [[120410, 120410], "mapped", "e"], [[120411, 120411], "mapped", "f"], [[120412, 120412], "mapped", "g"], [[120413, 120413], "mapped", "h"], [[120414, 120414], "mapped", "i"], [[120415, 120415], "mapped", "j"], [[120416, 120416], "mapped", "k"], [[120417, 120417], "mapped", "l"], [[120418, 120418], "mapped", "m"], [[120419, 120419], "mapped", "n"], [[120420, 120420], "mapped", "o"], [[120421, 120421], "mapped", "p"], [[120422, 120422], "mapped", "q"], [[120423, 120423], "mapped", "r"], [[120424, 120424], "mapped", "s"], [[120425, 120425], "mapped", "t"], [[120426, 120426], "mapped", "u"], [[120427, 120427], "mapped", "v"], [[120428, 120428], "mapped", "w"], [[120429, 120429], "mapped", "x"], [[120430, 120430], "mapped", "y"], [[120431, 120431], "mapped", "z"], [[120432, 120432], "mapped", "a"], [[120433, 120433], "mapped", "b"], [[120434, 120434], "mapped", "c"], [[120435, 120435], "mapped", "d"], [[120436, 120436], "mapped", "e"], [[120437, 120437], "mapped", "f"], [[120438, 120438], "mapped", "g"], [[120439, 120439], "mapped", "h"], [[120440, 120440], "mapped", "i"], [[120441, 120441], "mapped", "j"], [[120442, 120442], "mapped", "k"], [[120443, 120443], "mapped", "l"], [[120444, 120444], "mapped", "m"], [[120445, 120445], "mapped", "n"], [[120446, 120446], "mapped", "o"], [[120447, 120447], "mapped", "p"], [[120448, 120448], "mapped", "q"], [[120449, 120449], "mapped", "r"], [[120450, 120450], "mapped", "s"], [[120451, 120451], "mapped", "t"], [[120452, 120452], "mapped", "u"], [[120453, 120453], "mapped", "v"], [[120454, 120454], "mapped", "w"], [[120455, 120455], "mapped", "x"], [[120456, 120456], "mapped", "y"], [[120457, 120457], "mapped", "z"], [[120458, 120458], "mapped", "a"], [[120459, 120459], "mapped", "b"], [[120460, 120460], "mapped", "c"], [[120461, 120461], "mapped", "d"], [[120462, 120462], "mapped", "e"], [[120463, 120463], "mapped", "f"], [[120464, 120464], "mapped", "g"], [[120465, 120465], "mapped", "h"], [[120466, 120466], "mapped", "i"], [[120467, 120467], "mapped", "j"], [[120468, 120468], "mapped", "k"], [[120469, 120469], "mapped", "l"], [[120470, 120470], "mapped", "m"], [[120471, 120471], "mapped", "n"], [[120472, 120472], "mapped", "o"], [[120473, 120473], "mapped", "p"], [[120474, 120474], "mapped", "q"], [[120475, 120475], "mapped", "r"], [[120476, 120476], "mapped", "s"], [[120477, 120477], "mapped", "t"], [[120478, 120478], "mapped", "u"], [[120479, 120479], "mapped", "v"], [[120480, 120480], "mapped", "w"], [[120481, 120481], "mapped", "x"], [[120482, 120482], "mapped", "y"], [[120483, 120483], "mapped", "z"], [[120484, 120484], "mapped", "\u0131"], [[120485, 120485], "mapped", "\u0237"], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", "\u03B1"], [[120489, 120489], "mapped", "\u03B2"], [[120490, 120490], "mapped", "\u03B3"], [[120491, 120491], "mapped", "\u03B4"], [[120492, 120492], "mapped", "\u03B5"], [[120493, 120493], "mapped", "\u03B6"], [[120494, 120494], "mapped", "\u03B7"], [[120495, 120495], "mapped", "\u03B8"], [[120496, 120496], "mapped", "\u03B9"], [[120497, 120497], "mapped", "\u03BA"], [[120498, 120498], "mapped", "\u03BB"], [[120499, 120499], "mapped", "\u03BC"], [[120500, 120500], "mapped", "\u03BD"], [[120501, 120501], "mapped", "\u03BE"], [[120502, 120502], "mapped", "\u03BF"], [[120503, 120503], "mapped", "\u03C0"], [[120504, 120504], "mapped", "\u03C1"], [[120505, 120505], "mapped", "\u03B8"], [[120506, 120506], "mapped", "\u03C3"], [[120507, 120507], "mapped", "\u03C4"], [[120508, 120508], "mapped", "\u03C5"], [[120509, 120509], "mapped", "\u03C6"], [[120510, 120510], "mapped", "\u03C7"], [[120511, 120511], "mapped", "\u03C8"], [[120512, 120512], "mapped", "\u03C9"], [[120513, 120513], "mapped", "\u2207"], [[120514, 120514], "mapped", "\u03B1"], [[120515, 120515], "mapped", "\u03B2"], [[120516, 120516], "mapped", "\u03B3"], [[120517, 120517], "mapped", "\u03B4"], [[120518, 120518], "mapped", "\u03B5"], [[120519, 120519], "mapped", "\u03B6"], [[120520, 120520], "mapped", "\u03B7"], [[120521, 120521], "mapped", "\u03B8"], [[120522, 120522], "mapped", "\u03B9"], [[120523, 120523], "mapped", "\u03BA"], [[120524, 120524], "mapped", "\u03BB"], [[120525, 120525], "mapped", "\u03BC"], [[120526, 120526], "mapped", "\u03BD"], [[120527, 120527], "mapped", "\u03BE"], [[120528, 120528], "mapped", "\u03BF"], [[120529, 120529], "mapped", "\u03C0"], [[120530, 120530], "mapped", "\u03C1"], [[120531, 120532], "mapped", "\u03C3"], [[120533, 120533], "mapped", "\u03C4"], [[120534, 120534], "mapped", "\u03C5"], [[120535, 120535], "mapped", "\u03C6"], [[120536, 120536], "mapped", "\u03C7"], [[120537, 120537], "mapped", "\u03C8"], [[120538, 120538], "mapped", "\u03C9"], [[120539, 120539], "mapped", "\u2202"], [[120540, 120540], "mapped", "\u03B5"], [[120541, 120541], "mapped", "\u03B8"], [[120542, 120542], "mapped", "\u03BA"], [[120543, 120543], "mapped", "\u03C6"], [[120544, 120544], "mapped", "\u03C1"], [[120545, 120545], "mapped", "\u03C0"], [[120546, 120546], "mapped", "\u03B1"], [[120547, 120547], "mapped", "\u03B2"], [[120548, 120548], "mapped", "\u03B3"], [[120549, 120549], "mapped", "\u03B4"], [[120550, 120550], "mapped", "\u03B5"], [[120551, 120551], "mapped", "\u03B6"], [[120552, 120552], "mapped", "\u03B7"], [[120553, 120553], "mapped", "\u03B8"], [[120554, 120554], "mapped", "\u03B9"], [[120555, 120555], "mapped", "\u03BA"], [[120556, 120556], "mapped", "\u03BB"], [[120557, 120557], "mapped", "\u03BC"], [[120558, 120558], "mapped", "\u03BD"], [[120559, 120559], "mapped", "\u03BE"], [[120560, 120560], "mapped", "\u03BF"], [[120561, 120561], "mapped", "\u03C0"], [[120562, 120562], "mapped", "\u03C1"], [[120563, 120563], "mapped", "\u03B8"], [[120564, 120564], "mapped", "\u03C3"], [[120565, 120565], "mapped", "\u03C4"], [[120566, 120566], "mapped", "\u03C5"], [[120567, 120567], "mapped", "\u03C6"], [[120568, 120568], "mapped", "\u03C7"], [[120569, 120569], "mapped", "\u03C8"], [[120570, 120570], "mapped", "\u03C9"], [[120571, 120571], "mapped", "\u2207"], [[120572, 120572], "mapped", "\u03B1"], [[120573, 120573], "mapped", "\u03B2"], [[120574, 120574], "mapped", "\u03B3"], [[120575, 120575], "mapped", "\u03B4"], [[120576, 120576], "mapped", "\u03B5"], [[120577, 120577], "mapped", "\u03B6"], [[120578, 120578], "mapped", "\u03B7"], [[120579, 120579], "mapped", "\u03B8"], [[120580, 120580], "mapped", "\u03B9"], [[120581, 120581], "mapped", "\u03BA"], [[120582, 120582], "mapped", "\u03BB"], [[120583, 120583], "mapped", "\u03BC"], [[120584, 120584], "mapped", "\u03BD"], [[120585, 120585], "mapped", "\u03BE"], [[120586, 120586], "mapped", "\u03BF"], [[120587, 120587], "mapped", "\u03C0"], [[120588, 120588], "mapped", "\u03C1"], [[120589, 120590], "mapped", "\u03C3"], [[120591, 120591], "mapped", "\u03C4"], [[120592, 120592], "mapped", "\u03C5"], [[120593, 120593], "mapped", "\u03C6"], [[120594, 120594], "mapped", "\u03C7"], [[120595, 120595], "mapped", "\u03C8"], [[120596, 120596], "mapped", "\u03C9"], [[120597, 120597], "mapped", "\u2202"], [[120598, 120598], "mapped", "\u03B5"], [[120599, 120599], "mapped", "\u03B8"], [[120600, 120600], "mapped", "\u03BA"], [[120601, 120601], "mapped", "\u03C6"], [[120602, 120602], "mapped", "\u03C1"], [[120603, 120603], "mapped", "\u03C0"], [[120604, 120604], "mapped", "\u03B1"], [[120605, 120605], "mapped", "\u03B2"], [[120606, 120606], "mapped", "\u03B3"], [[120607, 120607], "mapped", "\u03B4"], [[120608, 120608], "mapped", "\u03B5"], [[120609, 120609], "mapped", "\u03B6"], [[120610, 120610], "mapped", "\u03B7"], [[120611, 120611], "mapped", "\u03B8"], [[120612, 120612], "mapped", "\u03B9"], [[120613, 120613], "mapped", "\u03BA"], [[120614, 120614], "mapped", "\u03BB"], [[120615, 120615], "mapped", "\u03BC"], [[120616, 120616], "mapped", "\u03BD"], [[120617, 120617], "mapped", "\u03BE"], [[120618, 120618], "mapped", "\u03BF"], [[120619, 120619], "mapped", "\u03C0"], [[120620, 120620], "mapped", "\u03C1"], [[120621, 120621], "mapped", "\u03B8"], [[120622, 120622], "mapped", "\u03C3"], [[120623, 120623], "mapped", "\u03C4"], [[120624, 120624], "mapped", "\u03C5"], [[120625, 120625], "mapped", "\u03C6"], [[120626, 120626], "mapped", "\u03C7"], [[120627, 120627], "mapped", "\u03C8"], [[120628, 120628], "mapped", "\u03C9"], [[120629, 120629], "mapped", "\u2207"], [[120630, 120630], "mapped", "\u03B1"], [[120631, 120631], "mapped", "\u03B2"], [[120632, 120632], "mapped", "\u03B3"], [[120633, 120633], "mapped", "\u03B4"], [[120634, 120634], "mapped", "\u03B5"], [[120635, 120635], "mapped", "\u03B6"], [[120636, 120636], "mapped", "\u03B7"], [[120637, 120637], "mapped", "\u03B8"], [[120638, 120638], "mapped", "\u03B9"], [[120639, 120639], "mapped", "\u03BA"], [[120640, 120640], "mapped", "\u03BB"], [[120641, 120641], "mapped", "\u03BC"], [[120642, 120642], "mapped", "\u03BD"], [[120643, 120643], "mapped", "\u03BE"], [[120644, 120644], "mapped", "\u03BF"], [[120645, 120645], "mapped", "\u03C0"], [[120646, 120646], "mapped", "\u03C1"], [[120647, 120648], "mapped", "\u03C3"], [[120649, 120649], "mapped", "\u03C4"], [[120650, 120650], "mapped", "\u03C5"], [[120651, 120651], "mapped", "\u03C6"], [[120652, 120652], "mapped", "\u03C7"], [[120653, 120653], "mapped", "\u03C8"], [[120654, 120654], "mapped", "\u03C9"], [[120655, 120655], "mapped", "\u2202"], [[120656, 120656], "mapped", "\u03B5"], [[120657, 120657], "mapped", "\u03B8"], [[120658, 120658], "mapped", "\u03BA"], [[120659, 120659], "mapped", "\u03C6"], [[120660, 120660], "mapped", "\u03C1"], [[120661, 120661], "mapped", "\u03C0"], [[120662, 120662], "mapped", "\u03B1"], [[120663, 120663], "mapped", "\u03B2"], [[120664, 120664], "mapped", "\u03B3"], [[120665, 120665], "mapped", "\u03B4"], [[120666, 120666], "mapped", "\u03B5"], [[120667, 120667], "mapped", "\u03B6"], [[120668, 120668], "mapped", "\u03B7"], [[120669, 120669], "mapped", "\u03B8"], [[120670, 120670], "mapped", "\u03B9"], [[120671, 120671], "mapped", "\u03BA"], [[120672, 120672], "mapped", "\u03BB"], [[120673, 120673], "mapped", "\u03BC"], [[120674, 120674], "mapped", "\u03BD"], [[120675, 120675], "mapped", "\u03BE"], [[120676, 120676], "mapped", "\u03BF"], [[120677, 120677], "mapped", "\u03C0"], [[120678, 120678], "mapped", "\u03C1"], [[120679, 120679], "mapped", "\u03B8"], [[120680, 120680], "mapped", "\u03C3"], [[120681, 120681], "mapped", "\u03C4"], [[120682, 120682], "mapped", "\u03C5"], [[120683, 120683], "mapped", "\u03C6"], [[120684, 120684], "mapped", "\u03C7"], [[120685, 120685], "mapped", "\u03C8"], [[120686, 120686], "mapped", "\u03C9"], [[120687, 120687], "mapped", "\u2207"], [[120688, 120688], "mapped", "\u03B1"], [[120689, 120689], "mapped", "\u03B2"], [[120690, 120690], "mapped", "\u03B3"], [[120691, 120691], "mapped", "\u03B4"], [[120692, 120692], "mapped", "\u03B5"], [[120693, 120693], "mapped", "\u03B6"], [[120694, 120694], "mapped", "\u03B7"], [[120695, 120695], "mapped", "\u03B8"], [[120696, 120696], "mapped", "\u03B9"], [[120697, 120697], "mapped", "\u03BA"], [[120698, 120698], "mapped", "\u03BB"], [[120699, 120699], "mapped", "\u03BC"], [[120700, 120700], "mapped", "\u03BD"], [[120701, 120701], "mapped", "\u03BE"], [[120702, 120702], "mapped", "\u03BF"], [[120703, 120703], "mapped", "\u03C0"], [[120704, 120704], "mapped", "\u03C1"], [[120705, 120706], "mapped", "\u03C3"], [[120707, 120707], "mapped", "\u03C4"], [[120708, 120708], "mapped", "\u03C5"], [[120709, 120709], "mapped", "\u03C6"], [[120710, 120710], "mapped", "\u03C7"], [[120711, 120711], "mapped", "\u03C8"], [[120712, 120712], "mapped", "\u03C9"], [[120713, 120713], "mapped", "\u2202"], [[120714, 120714], "mapped", "\u03B5"], [[120715, 120715], "mapped", "\u03B8"], [[120716, 120716], "mapped", "\u03BA"], [[120717, 120717], "mapped", "\u03C6"], [[120718, 120718], "mapped", "\u03C1"], [[120719, 120719], "mapped", "\u03C0"], [[120720, 120720], "mapped", "\u03B1"], [[120721, 120721], "mapped", "\u03B2"], [[120722, 120722], "mapped", "\u03B3"], [[120723, 120723], "mapped", "\u03B4"], [[120724, 120724], "mapped", "\u03B5"], [[120725, 120725], "mapped", "\u03B6"], [[120726, 120726], "mapped", "\u03B7"], [[120727, 120727], "mapped", "\u03B8"], [[120728, 120728], "mapped", "\u03B9"], [[120729, 120729], "mapped", "\u03BA"], [[120730, 120730], "mapped", "\u03BB"], [[120731, 120731], "mapped", "\u03BC"], [[120732, 120732], "mapped", "\u03BD"], [[120733, 120733], "mapped", "\u03BE"], [[120734, 120734], "mapped", "\u03BF"], [[120735, 120735], "mapped", "\u03C0"], [[120736, 120736], "mapped", "\u03C1"], [[120737, 120737], "mapped", "\u03B8"], [[120738, 120738], "mapped", "\u03C3"], [[120739, 120739], "mapped", "\u03C4"], [[120740, 120740], "mapped", "\u03C5"], [[120741, 120741], "mapped", "\u03C6"], [[120742, 120742], "mapped", "\u03C7"], [[120743, 120743], "mapped", "\u03C8"], [[120744, 120744], "mapped", "\u03C9"], [[120745, 120745], "mapped", "\u2207"], [[120746, 120746], "mapped", "\u03B1"], [[120747, 120747], "mapped", "\u03B2"], [[120748, 120748], "mapped", "\u03B3"], [[120749, 120749], "mapped", "\u03B4"], [[120750, 120750], "mapped", "\u03B5"], [[120751, 120751], "mapped", "\u03B6"], [[120752, 120752], "mapped", "\u03B7"], [[120753, 120753], "mapped", "\u03B8"], [[120754, 120754], "mapped", "\u03B9"], [[120755, 120755], "mapped", "\u03BA"], [[120756, 120756], "mapped", "\u03BB"], [[120757, 120757], "mapped", "\u03BC"], [[120758, 120758], "mapped", "\u03BD"], [[120759, 120759], "mapped", "\u03BE"], [[120760, 120760], "mapped", "\u03BF"], [[120761, 120761], "mapped", "\u03C0"], [[120762, 120762], "mapped", "\u03C1"], [[120763, 120764], "mapped", "\u03C3"], [[120765, 120765], "mapped", "\u03C4"], [[120766, 120766], "mapped", "\u03C5"], [[120767, 120767], "mapped", "\u03C6"], [[120768, 120768], "mapped", "\u03C7"], [[120769, 120769], "mapped", "\u03C8"], [[120770, 120770], "mapped", "\u03C9"], [[120771, 120771], "mapped", "\u2202"], [[120772, 120772], "mapped", "\u03B5"], [[120773, 120773], "mapped", "\u03B8"], [[120774, 120774], "mapped", "\u03BA"], [[120775, 120775], "mapped", "\u03C6"], [[120776, 120776], "mapped", "\u03C1"], [[120777, 120777], "mapped", "\u03C0"], [[120778, 120779], "mapped", "\u03DD"], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", "0"], [[120783, 120783], "mapped", "1"], [[120784, 120784], "mapped", "2"], [[120785, 120785], "mapped", "3"], [[120786, 120786], "mapped", "4"], [[120787, 120787], "mapped", "5"], [[120788, 120788], "mapped", "6"], [[120789, 120789], "mapped", "7"], [[120790, 120790], "mapped", "8"], [[120791, 120791], "mapped", "9"], [[120792, 120792], "mapped", "0"], [[120793, 120793], "mapped", "1"], [[120794, 120794], "mapped", "2"], [[120795, 120795], "mapped", "3"], [[120796, 120796], "mapped", "4"], [[120797, 120797], "mapped", "5"], [[120798, 120798], "mapped", "6"], [[120799, 120799], "mapped", "7"], [[120800, 120800], "mapped", "8"], [[120801, 120801], "mapped", "9"], [[120802, 120802], "mapped", "0"], [[120803, 120803], "mapped", "1"], [[120804, 120804], "mapped", "2"], [[120805, 120805], "mapped", "3"], [[120806, 120806], "mapped", "4"], [[120807, 120807], "mapped", "5"], [[120808, 120808], "mapped", "6"], [[120809, 120809], "mapped", "7"], [[120810, 120810], "mapped", "8"], [[120811, 120811], "mapped", "9"], [[120812, 120812], "mapped", "0"], [[120813, 120813], "mapped", "1"], [[120814, 120814], "mapped", "2"], [[120815, 120815], "mapped", "3"], [[120816, 120816], "mapped", "4"], [[120817, 120817], "mapped", "5"], [[120818, 120818], "mapped", "6"], [[120819, 120819], "mapped", "7"], [[120820, 120820], "mapped", "8"], [[120821, 120821], "mapped", "9"], [[120822, 120822], "mapped", "0"], [[120823, 120823], "mapped", "1"], [[120824, 120824], "mapped", "2"], [[120825, 120825], "mapped", "3"], [[120826, 120826], "mapped", "4"], [[120827, 120827], "mapped", "5"], [[120828, 120828], "mapped", "6"], [[120829, 120829], "mapped", "7"], [[120830, 120830], "mapped", "8"], [[120831, 120831], "mapped", "9"], [[120832, 121343], "valid", "", "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", "", "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", "", "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", "", "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", "", "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 122879], "disallowed"], [[122880, 122886], "valid"], [[122887, 122887], "disallowed"], [[122888, 122904], "valid"], [[122905, 122906], "disallowed"], [[122907, 122913], "valid"], [[122914, 122914], "disallowed"], [[122915, 122916], "valid"], [[122917, 122917], "disallowed"], [[122918, 122922], "valid"], [[122923, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", "", "NV8"], [[125136, 125142], "valid"], [[125143, 125183], "disallowed"], [[125184, 125184], "mapped", "\u{1E922}"], [[125185, 125185], "mapped", "\u{1E923}"], [[125186, 125186], "mapped", "\u{1E924}"], [[125187, 125187], "mapped", "\u{1E925}"], [[125188, 125188], "mapped", "\u{1E926}"], [[125189, 125189], "mapped", "\u{1E927}"], [[125190, 125190], "mapped", "\u{1E928}"], [[125191, 125191], "mapped", "\u{1E929}"], [[125192, 125192], "mapped", "\u{1E92A}"], [[125193, 125193], "mapped", "\u{1E92B}"], [[125194, 125194], "mapped", "\u{1E92C}"], [[125195, 125195], "mapped", "\u{1E92D}"], [[125196, 125196], "mapped", "\u{1E92E}"], [[125197, 125197], "mapped", "\u{1E92F}"], [[125198, 125198], "mapped", "\u{1E930}"], [[125199, 125199], "mapped", "\u{1E931}"], [[125200, 125200], "mapped", "\u{1E932}"], [[125201, 125201], "mapped", "\u{1E933}"], [[125202, 125202], "mapped", "\u{1E934}"], [[125203, 125203], "mapped", "\u{1E935}"], [[125204, 125204], "mapped", "\u{1E936}"], [[125205, 125205], "mapped", "\u{1E937}"], [[125206, 125206], "mapped", "\u{1E938}"], [[125207, 125207], "mapped", "\u{1E939}"], [[125208, 125208], "mapped", "\u{1E93A}"], [[125209, 125209], "mapped", "\u{1E93B}"], [[125210, 125210], "mapped", "\u{1E93C}"], [[125211, 125211], "mapped", "\u{1E93D}"], [[125212, 125212], "mapped", "\u{1E93E}"], [[125213, 125213], "mapped", "\u{1E93F}"], [[125214, 125214], "mapped", "\u{1E940}"], [[125215, 125215], "mapped", "\u{1E941}"], [[125216, 125216], "mapped", "\u{1E942}"], [[125217, 125217], "mapped", "\u{1E943}"], [[125218, 125258], "valid"], [[125259, 125263], "disallowed"], [[125264, 125273], "valid"], [[125274, 125277], "disallowed"], [[125278, 125279], "valid", "", "NV8"], [[125280, 126463], "disallowed"], [[126464, 126464], "mapped", "\u0627"], [[126465, 126465], "mapped", "\u0628"], [[126466, 126466], "mapped", "\u062C"], [[126467, 126467], "mapped", "\u062F"], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", "\u0648"], [[126470, 126470], "mapped", "\u0632"], [[126471, 126471], "mapped", "\u062D"], [[126472, 126472], "mapped", "\u0637"], [[126473, 126473], "mapped", "\u064A"], [[126474, 126474], "mapped", "\u0643"], [[126475, 126475], "mapped", "\u0644"], [[126476, 126476], "mapped", "\u0645"], [[126477, 126477], "mapped", "\u0646"], [[126478, 126478], "mapped", "\u0633"], [[126479, 126479], "mapped", "\u0639"], [[126480, 126480], "mapped", "\u0641"], [[126481, 126481], "mapped", "\u0635"], [[126482, 126482], "mapped", "\u0642"], [[126483, 126483], "mapped", "\u0631"], [[126484, 126484], "mapped", "\u0634"], [[126485, 126485], "mapped", "\u062A"], [[126486, 126486], "mapped", "\u062B"], [[126487, 126487], "mapped", "\u062E"], [[126488, 126488], "mapped", "\u0630"], [[126489, 126489], "mapped", "\u0636"], [[126490, 126490], "mapped", "\u0638"], [[126491, 126491], "mapped", "\u063A"], [[126492, 126492], "mapped", "\u066E"], [[126493, 126493], "mapped", "\u06BA"], [[126494, 126494], "mapped", "\u06A1"], [[126495, 126495], "mapped", "\u066F"], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", "\u0628"], [[126498, 126498], "mapped", "\u062C"], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", "\u0647"], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", "\u062D"], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", "\u064A"], [[126506, 126506], "mapped", "\u0643"], [[126507, 126507], "mapped", "\u0644"], [[126508, 126508], "mapped", "\u0645"], [[126509, 126509], "mapped", "\u0646"], [[126510, 126510], "mapped", "\u0633"], [[126511, 126511], "mapped", "\u0639"], [[126512, 126512], "mapped", "\u0641"], [[126513, 126513], "mapped", "\u0635"], [[126514, 126514], "mapped", "\u0642"], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", "\u0634"], [[126517, 126517], "mapped", "\u062A"], [[126518, 126518], "mapped", "\u062B"], [[126519, 126519], "mapped", "\u062E"], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", "\u0636"], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", "\u063A"], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", "\u062C"], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", "\u062D"], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", "\u064A"], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", "\u0644"], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", "\u0646"], [[126542, 126542], "mapped", "\u0633"], [[126543, 126543], "mapped", "\u0639"], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", "\u0635"], [[126546, 126546], "mapped", "\u0642"], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", "\u0634"], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", "\u062E"], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", "\u0636"], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", "\u063A"], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", "\u06BA"], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", "\u066F"], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", "\u0628"], [[126562, 126562], "mapped", "\u062C"], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", "\u0647"], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", "\u062D"], [[126568, 126568], "mapped", "\u0637"], [[126569, 126569], "mapped", "\u064A"], [[126570, 126570], "mapped", "\u0643"], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", "\u0645"], [[126573, 126573], "mapped", "\u0646"], [[126574, 126574], "mapped", "\u0633"], [[126575, 126575], "mapped", "\u0639"], [[126576, 126576], "mapped", "\u0641"], [[126577, 126577], "mapped", "\u0635"], [[126578, 126578], "mapped", "\u0642"], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", "\u0634"], [[126581, 126581], "mapped", "\u062A"], [[126582, 126582], "mapped", "\u062B"], [[126583, 126583], "mapped", "\u062E"], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", "\u0636"], [[126586, 126586], "mapped", "\u0638"], [[126587, 126587], "mapped", "\u063A"], [[126588, 126588], "mapped", "\u066E"], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", "\u06A1"], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", "\u0627"], [[126593, 126593], "mapped", "\u0628"], [[126594, 126594], "mapped", "\u062C"], [[126595, 126595], "mapped", "\u062F"], [[126596, 126596], "mapped", "\u0647"], [[126597, 126597], "mapped", "\u0648"], [[126598, 126598], "mapped", "\u0632"], [[126599, 126599], "mapped", "\u062D"], [[126600, 126600], "mapped", "\u0637"], [[126601, 126601], "mapped", "\u064A"], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", "\u0644"], [[126604, 126604], "mapped", "\u0645"], [[126605, 126605], "mapped", "\u0646"], [[126606, 126606], "mapped", "\u0633"], [[126607, 126607], "mapped", "\u0639"], [[126608, 126608], "mapped", "\u0641"], [[126609, 126609], "mapped", "\u0635"], [[126610, 126610], "mapped", "\u0642"], [[126611, 126611], "mapped", "\u0631"], [[126612, 126612], "mapped", "\u0634"], [[126613, 126613], "mapped", "\u062A"], [[126614, 126614], "mapped", "\u062B"], [[126615, 126615], "mapped", "\u062E"], [[126616, 126616], "mapped", "\u0630"], [[126617, 126617], "mapped", "\u0636"], [[126618, 126618], "mapped", "\u0638"], [[126619, 126619], "mapped", "\u063A"], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", "\u0628"], [[126626, 126626], "mapped", "\u062C"], [[126627, 126627], "mapped", "\u062F"], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", "\u0648"], [[126630, 126630], "mapped", "\u0632"], [[126631, 126631], "mapped", "\u062D"], [[126632, 126632], "mapped", "\u0637"], [[126633, 126633], "mapped", "\u064A"], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", "\u0644"], [[126636, 126636], "mapped", "\u0645"], [[126637, 126637], "mapped", "\u0646"], [[126638, 126638], "mapped", "\u0633"], [[126639, 126639], "mapped", "\u0639"], [[126640, 126640], "mapped", "\u0641"], [[126641, 126641], "mapped", "\u0635"], [[126642, 126642], "mapped", "\u0642"], [[126643, 126643], "mapped", "\u0631"], [[126644, 126644], "mapped", "\u0634"], [[126645, 126645], "mapped", "\u062A"], [[126646, 126646], "mapped", "\u062B"], [[126647, 126647], "mapped", "\u062E"], [[126648, 126648], "mapped", "\u0630"], [[126649, 126649], "mapped", "\u0636"], [[126650, 126650], "mapped", "\u0638"], [[126651, 126651], "mapped", "\u063A"], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", "", "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", "", "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", "", "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", "", "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", "", "NV8"], [[127167, 127167], "valid", "", "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", "", "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", "", "NV8"], [[127200, 127221], "valid", "", "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", "0,"], [[127234, 127234], "disallowed_STD3_mapped", "1,"], [[127235, 127235], "disallowed_STD3_mapped", "2,"], [[127236, 127236], "disallowed_STD3_mapped", "3,"], [[127237, 127237], "disallowed_STD3_mapped", "4,"], [[127238, 127238], "disallowed_STD3_mapped", "5,"], [[127239, 127239], "disallowed_STD3_mapped", "6,"], [[127240, 127240], "disallowed_STD3_mapped", "7,"], [[127241, 127241], "disallowed_STD3_mapped", "8,"], [[127242, 127242], "disallowed_STD3_mapped", "9,"], [[127243, 127244], "valid", "", "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", "(a)"], [[127249, 127249], "disallowed_STD3_mapped", "(b)"], [[127250, 127250], "disallowed_STD3_mapped", "(c)"], [[127251, 127251], "disallowed_STD3_mapped", "(d)"], [[127252, 127252], "disallowed_STD3_mapped", "(e)"], [[127253, 127253], "disallowed_STD3_mapped", "(f)"], [[127254, 127254], "disallowed_STD3_mapped", "(g)"], [[127255, 127255], "disallowed_STD3_mapped", "(h)"], [[127256, 127256], "disallowed_STD3_mapped", "(i)"], [[127257, 127257], "disallowed_STD3_mapped", "(j)"], [[127258, 127258], "disallowed_STD3_mapped", "(k)"], [[127259, 127259], "disallowed_STD3_mapped", "(l)"], [[127260, 127260], "disallowed_STD3_mapped", "(m)"], [[127261, 127261], "disallowed_STD3_mapped", "(n)"], [[127262, 127262], "disallowed_STD3_mapped", "(o)"], [[127263, 127263], "disallowed_STD3_mapped", "(p)"], [[127264, 127264], "disallowed_STD3_mapped", "(q)"], [[127265, 127265], "disallowed_STD3_mapped", "(r)"], [[127266, 127266], "disallowed_STD3_mapped", "(s)"], [[127267, 127267], "disallowed_STD3_mapped", "(t)"], [[127268, 127268], "disallowed_STD3_mapped", "(u)"], [[127269, 127269], "disallowed_STD3_mapped", "(v)"], [[127270, 127270], "disallowed_STD3_mapped", "(w)"], [[127271, 127271], "disallowed_STD3_mapped", "(x)"], [[127272, 127272], "disallowed_STD3_mapped", "(y)"], [[127273, 127273], "disallowed_STD3_mapped", "(z)"], [[127274, 127274], "mapped", "\u3014s\u3015"], [[127275, 127275], "mapped", "c"], [[127276, 127276], "mapped", "r"], [[127277, 127277], "mapped", "cd"], [[127278, 127278], "mapped", "wz"], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", "a"], [[127281, 127281], "mapped", "b"], [[127282, 127282], "mapped", "c"], [[127283, 127283], "mapped", "d"], [[127284, 127284], "mapped", "e"], [[127285, 127285], "mapped", "f"], [[127286, 127286], "mapped", "g"], [[127287, 127287], "mapped", "h"], [[127288, 127288], "mapped", "i"], [[127289, 127289], "mapped", "j"], [[127290, 127290], "mapped", "k"], [[127291, 127291], "mapped", "l"], [[127292, 127292], "mapped", "m"], [[127293, 127293], "mapped", "n"], [[127294, 127294], "mapped", "o"], [[127295, 127295], "mapped", "p"], [[127296, 127296], "mapped", "q"], [[127297, 127297], "mapped", "r"], [[127298, 127298], "mapped", "s"], [[127299, 127299], "mapped", "t"], [[127300, 127300], "mapped", "u"], [[127301, 127301], "mapped", "v"], [[127302, 127302], "mapped", "w"], [[127303, 127303], "mapped", "x"], [[127304, 127304], "mapped", "y"], [[127305, 127305], "mapped", "z"], [[127306, 127306], "mapped", "hv"], [[127307, 127307], "mapped", "mv"], [[127308, 127308], "mapped", "sd"], [[127309, 127309], "mapped", "ss"], [[127310, 127310], "mapped", "ppv"], [[127311, 127311], "mapped", "wc"], [[127312, 127318], "valid", "", "NV8"], [[127319, 127319], "valid", "", "NV8"], [[127320, 127326], "valid", "", "NV8"], [[127327, 127327], "valid", "", "NV8"], [[127328, 127337], "valid", "", "NV8"], [[127338, 127338], "mapped", "mc"], [[127339, 127339], "mapped", "md"], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", "", "NV8"], [[127353, 127353], "valid", "", "NV8"], [[127354, 127354], "valid", "", "NV8"], [[127355, 127356], "valid", "", "NV8"], [[127357, 127358], "valid", "", "NV8"], [[127359, 127359], "valid", "", "NV8"], [[127360, 127369], "valid", "", "NV8"], [[127370, 127373], "valid", "", "NV8"], [[127374, 127375], "valid", "", "NV8"], [[127376, 127376], "mapped", "dj"], [[127377, 127386], "valid", "", "NV8"], [[127387, 127404], "valid", "", "NV8"], [[127405, 127461], "disallowed"], [[127462, 127487], "valid", "", "NV8"], [[127488, 127488], "mapped", "\u307B\u304B"], [[127489, 127489], "mapped", "\u30B3\u30B3"], [[127490, 127490], "mapped", "\u30B5"], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", "\u624B"], [[127505, 127505], "mapped", "\u5B57"], [[127506, 127506], "mapped", "\u53CC"], [[127507, 127507], "mapped", "\u30C7"], [[127508, 127508], "mapped", "\u4E8C"], [[127509, 127509], "mapped", "\u591A"], [[127510, 127510], "mapped", "\u89E3"], [[127511, 127511], "mapped", "\u5929"], [[127512, 127512], "mapped", "\u4EA4"], [[127513, 127513], "mapped", "\u6620"], [[127514, 127514], "mapped", "\u7121"], [[127515, 127515], "mapped", "\u6599"], [[127516, 127516], "mapped", "\u524D"], [[127517, 127517], "mapped", "\u5F8C"], [[127518, 127518], "mapped", "\u518D"], [[127519, 127519], "mapped", "\u65B0"], [[127520, 127520], "mapped", "\u521D"], [[127521, 127521], "mapped", "\u7D42"], [[127522, 127522], "mapped", "\u751F"], [[127523, 127523], "mapped", "\u8CA9"], [[127524, 127524], "mapped", "\u58F0"], [[127525, 127525], "mapped", "\u5439"], [[127526, 127526], "mapped", "\u6F14"], [[127527, 127527], "mapped", "\u6295"], [[127528, 127528], "mapped", "\u6355"], [[127529, 127529], "mapped", "\u4E00"], [[127530, 127530], "mapped", "\u4E09"], [[127531, 127531], "mapped", "\u904A"], [[127532, 127532], "mapped", "\u5DE6"], [[127533, 127533], "mapped", "\u4E2D"], [[127534, 127534], "mapped", "\u53F3"], [[127535, 127535], "mapped", "\u6307"], [[127536, 127536], "mapped", "\u8D70"], [[127537, 127537], "mapped", "\u6253"], [[127538, 127538], "mapped", "\u7981"], [[127539, 127539], "mapped", "\u7A7A"], [[127540, 127540], "mapped", "\u5408"], [[127541, 127541], "mapped", "\u6E80"], [[127542, 127542], "mapped", "\u6709"], [[127543, 127543], "mapped", "\u6708"], [[127544, 127544], "mapped", "\u7533"], [[127545, 127545], "mapped", "\u5272"], [[127546, 127546], "mapped", "\u55B6"], [[127547, 127547], "mapped", "\u914D"], [[127548, 127551], "disallowed"], [[127552, 127552], "mapped", "\u3014\u672C\u3015"], [[127553, 127553], "mapped", "\u3014\u4E09\u3015"], [[127554, 127554], "mapped", "\u3014\u4E8C\u3015"], [[127555, 127555], "mapped", "\u3014\u5B89\u3015"], [[127556, 127556], "mapped", "\u3014\u70B9\u3015"], [[127557, 127557], "mapped", "\u3014\u6253\u3015"], [[127558, 127558], "mapped", "\u3014\u76D7\u3015"], [[127559, 127559], "mapped", "\u3014\u52DD\u3015"], [[127560, 127560], "mapped", "\u3014\u6557\u3015"], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", "\u5F97"], [[127569, 127569], "mapped", "\u53EF"], [[127570, 127583], "disallowed"], [[127584, 127589], "valid", "", "NV8"], [[127590, 127743], "disallowed"], [[127744, 127776], "valid", "", "NV8"], [[127777, 127788], "valid", "", "NV8"], [[127789, 127791], "valid", "", "NV8"], [[127792, 127797], "valid", "", "NV8"], [[127798, 127798], "valid", "", "NV8"], [[127799, 127868], "valid", "", "NV8"], [[127869, 127869], "valid", "", "NV8"], [[127870, 127871], "valid", "", "NV8"], [[127872, 127891], "valid", "", "NV8"], [[127892, 127903], "valid", "", "NV8"], [[127904, 127940], "valid", "", "NV8"], [[127941, 127941], "valid", "", "NV8"], [[127942, 127946], "valid", "", "NV8"], [[127947, 127950], "valid", "", "NV8"], [[127951, 127955], "valid", "", "NV8"], [[127956, 127967], "valid", "", "NV8"], [[127968, 127984], "valid", "", "NV8"], [[127985, 127991], "valid", "", "NV8"], [[127992, 127999], "valid", "", "NV8"], [[128e3, 128062], "valid", "", "NV8"], [[128063, 128063], "valid", "", "NV8"], [[128064, 128064], "valid", "", "NV8"], [[128065, 128065], "valid", "", "NV8"], [[128066, 128247], "valid", "", "NV8"], [[128248, 128248], "valid", "", "NV8"], [[128249, 128252], "valid", "", "NV8"], [[128253, 128254], "valid", "", "NV8"], [[128255, 128255], "valid", "", "NV8"], [[128256, 128317], "valid", "", "NV8"], [[128318, 128319], "valid", "", "NV8"], [[128320, 128323], "valid", "", "NV8"], [[128324, 128330], "valid", "", "NV8"], [[128331, 128335], "valid", "", "NV8"], [[128336, 128359], "valid", "", "NV8"], [[128360, 128377], "valid", "", "NV8"], [[128378, 128378], "valid", "", "NV8"], [[128379, 128419], "valid", "", "NV8"], [[128420, 128420], "valid", "", "NV8"], [[128421, 128506], "valid", "", "NV8"], [[128507, 128511], "valid", "", "NV8"], [[128512, 128512], "valid", "", "NV8"], [[128513, 128528], "valid", "", "NV8"], [[128529, 128529], "valid", "", "NV8"], [[128530, 128532], "valid", "", "NV8"], [[128533, 128533], "valid", "", "NV8"], [[128534, 128534], "valid", "", "NV8"], [[128535, 128535], "valid", "", "NV8"], [[128536, 128536], "valid", "", "NV8"], [[128537, 128537], "valid", "", "NV8"], [[128538, 128538], "valid", "", "NV8"], [[128539, 128539], "valid", "", "NV8"], [[128540, 128542], "valid", "", "NV8"], [[128543, 128543], "valid", "", "NV8"], [[128544, 128549], "valid", "", "NV8"], [[128550, 128551], "valid", "", "NV8"], [[128552, 128555], "valid", "", "NV8"], [[128556, 128556], "valid", "", "NV8"], [[128557, 128557], "valid", "", "NV8"], [[128558, 128559], "valid", "", "NV8"], [[128560, 128563], "valid", "", "NV8"], [[128564, 128564], "valid", "", "NV8"], [[128565, 128576], "valid", "", "NV8"], [[128577, 128578], "valid", "", "NV8"], [[128579, 128580], "valid", "", "NV8"], [[128581, 128591], "valid", "", "NV8"], [[128592, 128639], "valid", "", "NV8"], [[128640, 128709], "valid", "", "NV8"], [[128710, 128719], "valid", "", "NV8"], [[128720, 128720], "valid", "", "NV8"], [[128721, 128722], "valid", "", "NV8"], [[128723, 128724], "valid", "", "NV8"], [[128725, 128735], "disallowed"], [[128736, 128748], "valid", "", "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", "", "NV8"], [[128756, 128758], "valid", "", "NV8"], [[128759, 128760], "valid", "", "NV8"], [[128761, 128767], "disallowed"], [[128768, 128883], "valid", "", "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", "", "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", "", "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", "", "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", "", "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", "", "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", "", "NV8"], [[129198, 129279], "disallowed"], [[129280, 129291], "valid", "", "NV8"], [[129292, 129295], "disallowed"], [[129296, 129304], "valid", "", "NV8"], [[129305, 129310], "valid", "", "NV8"], [[129311, 129311], "valid", "", "NV8"], [[129312, 129319], "valid", "", "NV8"], [[129320, 129327], "valid", "", "NV8"], [[129328, 129328], "valid", "", "NV8"], [[129329, 129330], "valid", "", "NV8"], [[129331, 129342], "valid", "", "NV8"], [[129343, 129343], "disallowed"], [[129344, 129355], "valid", "", "NV8"], [[129356, 129356], "valid", "", "NV8"], [[129357, 129359], "disallowed"], [[129360, 129374], "valid", "", "NV8"], [[129375, 129387], "valid", "", "NV8"], [[129388, 129407], "disallowed"], [[129408, 129412], "valid", "", "NV8"], [[129413, 129425], "valid", "", "NV8"], [[129426, 129431], "valid", "", "NV8"], [[129432, 129471], "disallowed"], [[129472, 129472], "valid", "", "NV8"], [[129473, 129487], "disallowed"], [[129488, 129510], "valid", "", "NV8"], [[129511, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 183983], "disallowed"], [[183984, 191456], "valid"], [[191457, 194559], "disallowed"], [[194560, 194560], "mapped", "\u4E3D"], [[194561, 194561], "mapped", "\u4E38"], [[194562, 194562], "mapped", "\u4E41"], [[194563, 194563], "mapped", "\u{20122}"], [[194564, 194564], "mapped", "\u4F60"], [[194565, 194565], "mapped", "\u4FAE"], [[194566, 194566], "mapped", "\u4FBB"], [[194567, 194567], "mapped", "\u5002"], [[194568, 194568], "mapped", "\u507A"], [[194569, 194569], "mapped", "\u5099"], [[194570, 194570], "mapped", "\u50E7"], [[194571, 194571], "mapped", "\u50CF"], [[194572, 194572], "mapped", "\u349E"], [[194573, 194573], "mapped", "\u{2063A}"], [[194574, 194574], "mapped", "\u514D"], [[194575, 194575], "mapped", "\u5154"], [[194576, 194576], "mapped", "\u5164"], [[194577, 194577], "mapped", "\u5177"], [[194578, 194578], "mapped", "\u{2051C}"], [[194579, 194579], "mapped", "\u34B9"], [[194580, 194580], "mapped", "\u5167"], [[194581, 194581], "mapped", "\u518D"], [[194582, 194582], "mapped", "\u{2054B}"], [[194583, 194583], "mapped", "\u5197"], [[194584, 194584], "mapped", "\u51A4"], [[194585, 194585], "mapped", "\u4ECC"], [[194586, 194586], "mapped", "\u51AC"], [[194587, 194587], "mapped", "\u51B5"], [[194588, 194588], "mapped", "\u{291DF}"], [[194589, 194589], "mapped", "\u51F5"], [[194590, 194590], "mapped", "\u5203"], [[194591, 194591], "mapped", "\u34DF"], [[194592, 194592], "mapped", "\u523B"], [[194593, 194593], "mapped", "\u5246"], [[194594, 194594], "mapped", "\u5272"], [[194595, 194595], "mapped", "\u5277"], [[194596, 194596], "mapped", "\u3515"], [[194597, 194597], "mapped", "\u52C7"], [[194598, 194598], "mapped", "\u52C9"], [[194599, 194599], "mapped", "\u52E4"], [[194600, 194600], "mapped", "\u52FA"], [[194601, 194601], "mapped", "\u5305"], [[194602, 194602], "mapped", "\u5306"], [[194603, 194603], "mapped", "\u5317"], [[194604, 194604], "mapped", "\u5349"], [[194605, 194605], "mapped", "\u5351"], [[194606, 194606], "mapped", "\u535A"], [[194607, 194607], "mapped", "\u5373"], [[194608, 194608], "mapped", "\u537D"], [[194609, 194611], "mapped", "\u537F"], [[194612, 194612], "mapped", "\u{20A2C}"], [[194613, 194613], "mapped", "\u7070"], [[194614, 194614], "mapped", "\u53CA"], [[194615, 194615], "mapped", "\u53DF"], [[194616, 194616], "mapped", "\u{20B63}"], [[194617, 194617], "mapped", "\u53EB"], [[194618, 194618], "mapped", "\u53F1"], [[194619, 194619], "mapped", "\u5406"], [[194620, 194620], "mapped", "\u549E"], [[194621, 194621], "mapped", "\u5438"], [[194622, 194622], "mapped", "\u5448"], [[194623, 194623], "mapped", "\u5468"], [[194624, 194624], "mapped", "\u54A2"], [[194625, 194625], "mapped", "\u54F6"], [[194626, 194626], "mapped", "\u5510"], [[194627, 194627], "mapped", "\u5553"], [[194628, 194628], "mapped", "\u5563"], [[194629, 194630], "mapped", "\u5584"], [[194631, 194631], "mapped", "\u5599"], [[194632, 194632], "mapped", "\u55AB"], [[194633, 194633], "mapped", "\u55B3"], [[194634, 194634], "mapped", "\u55C2"], [[194635, 194635], "mapped", "\u5716"], [[194636, 194636], "mapped", "\u5606"], [[194637, 194637], "mapped", "\u5717"], [[194638, 194638], "mapped", "\u5651"], [[194639, 194639], "mapped", "\u5674"], [[194640, 194640], "mapped", "\u5207"], [[194641, 194641], "mapped", "\u58EE"], [[194642, 194642], "mapped", "\u57CE"], [[194643, 194643], "mapped", "\u57F4"], [[194644, 194644], "mapped", "\u580D"], [[194645, 194645], "mapped", "\u578B"], [[194646, 194646], "mapped", "\u5832"], [[194647, 194647], "mapped", "\u5831"], [[194648, 194648], "mapped", "\u58AC"], [[194649, 194649], "mapped", "\u{214E4}"], [[194650, 194650], "mapped", "\u58F2"], [[194651, 194651], "mapped", "\u58F7"], [[194652, 194652], "mapped", "\u5906"], [[194653, 194653], "mapped", "\u591A"], [[194654, 194654], "mapped", "\u5922"], [[194655, 194655], "mapped", "\u5962"], [[194656, 194656], "mapped", "\u{216A8}"], [[194657, 194657], "mapped", "\u{216EA}"], [[194658, 194658], "mapped", "\u59EC"], [[194659, 194659], "mapped", "\u5A1B"], [[194660, 194660], "mapped", "\u5A27"], [[194661, 194661], "mapped", "\u59D8"], [[194662, 194662], "mapped", "\u5A66"], [[194663, 194663], "mapped", "\u36EE"], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", "\u5B08"], [[194666, 194667], "mapped", "\u5B3E"], [[194668, 194668], "mapped", "\u{219C8}"], [[194669, 194669], "mapped", "\u5BC3"], [[194670, 194670], "mapped", "\u5BD8"], [[194671, 194671], "mapped", "\u5BE7"], [[194672, 194672], "mapped", "\u5BF3"], [[194673, 194673], "mapped", "\u{21B18}"], [[194674, 194674], "mapped", "\u5BFF"], [[194675, 194675], "mapped", "\u5C06"], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", "\u5C22"], [[194678, 194678], "mapped", "\u3781"], [[194679, 194679], "mapped", "\u5C60"], [[194680, 194680], "mapped", "\u5C6E"], [[194681, 194681], "mapped", "\u5CC0"], [[194682, 194682], "mapped", "\u5C8D"], [[194683, 194683], "mapped", "\u{21DE4}"], [[194684, 194684], "mapped", "\u5D43"], [[194685, 194685], "mapped", "\u{21DE6}"], [[194686, 194686], "mapped", "\u5D6E"], [[194687, 194687], "mapped", "\u5D6B"], [[194688, 194688], "mapped", "\u5D7C"], [[194689, 194689], "mapped", "\u5DE1"], [[194690, 194690], "mapped", "\u5DE2"], [[194691, 194691], "mapped", "\u382F"], [[194692, 194692], "mapped", "\u5DFD"], [[194693, 194693], "mapped", "\u5E28"], [[194694, 194694], "mapped", "\u5E3D"], [[194695, 194695], "mapped", "\u5E69"], [[194696, 194696], "mapped", "\u3862"], [[194697, 194697], "mapped", "\u{22183}"], [[194698, 194698], "mapped", "\u387C"], [[194699, 194699], "mapped", "\u5EB0"], [[194700, 194700], "mapped", "\u5EB3"], [[194701, 194701], "mapped", "\u5EB6"], [[194702, 194702], "mapped", "\u5ECA"], [[194703, 194703], "mapped", "\u{2A392}"], [[194704, 194704], "mapped", "\u5EFE"], [[194705, 194706], "mapped", "\u{22331}"], [[194707, 194707], "mapped", "\u8201"], [[194708, 194709], "mapped", "\u5F22"], [[194710, 194710], "mapped", "\u38C7"], [[194711, 194711], "mapped", "\u{232B8}"], [[194712, 194712], "mapped", "\u{261DA}"], [[194713, 194713], "mapped", "\u5F62"], [[194714, 194714], "mapped", "\u5F6B"], [[194715, 194715], "mapped", "\u38E3"], [[194716, 194716], "mapped", "\u5F9A"], [[194717, 194717], "mapped", "\u5FCD"], [[194718, 194718], "mapped", "\u5FD7"], [[194719, 194719], "mapped", "\u5FF9"], [[194720, 194720], "mapped", "\u6081"], [[194721, 194721], "mapped", "\u393A"], [[194722, 194722], "mapped", "\u391C"], [[194723, 194723], "mapped", "\u6094"], [[194724, 194724], "mapped", "\u{226D4}"], [[194725, 194725], "mapped", "\u60C7"], [[194726, 194726], "mapped", "\u6148"], [[194727, 194727], "mapped", "\u614C"], [[194728, 194728], "mapped", "\u614E"], [[194729, 194729], "mapped", "\u614C"], [[194730, 194730], "mapped", "\u617A"], [[194731, 194731], "mapped", "\u618E"], [[194732, 194732], "mapped", "\u61B2"], [[194733, 194733], "mapped", "\u61A4"], [[194734, 194734], "mapped", "\u61AF"], [[194735, 194735], "mapped", "\u61DE"], [[194736, 194736], "mapped", "\u61F2"], [[194737, 194737], "mapped", "\u61F6"], [[194738, 194738], "mapped", "\u6210"], [[194739, 194739], "mapped", "\u621B"], [[194740, 194740], "mapped", "\u625D"], [[194741, 194741], "mapped", "\u62B1"], [[194742, 194742], "mapped", "\u62D4"], [[194743, 194743], "mapped", "\u6350"], [[194744, 194744], "mapped", "\u{22B0C}"], [[194745, 194745], "mapped", "\u633D"], [[194746, 194746], "mapped", "\u62FC"], [[194747, 194747], "mapped", "\u6368"], [[194748, 194748], "mapped", "\u6383"], [[194749, 194749], "mapped", "\u63E4"], [[194750, 194750], "mapped", "\u{22BF1}"], [[194751, 194751], "mapped", "\u6422"], [[194752, 194752], "mapped", "\u63C5"], [[194753, 194753], "mapped", "\u63A9"], [[194754, 194754], "mapped", "\u3A2E"], [[194755, 194755], "mapped", "\u6469"], [[194756, 194756], "mapped", "\u647E"], [[194757, 194757], "mapped", "\u649D"], [[194758, 194758], "mapped", "\u6477"], [[194759, 194759], "mapped", "\u3A6C"], [[194760, 194760], "mapped", "\u654F"], [[194761, 194761], "mapped", "\u656C"], [[194762, 194762], "mapped", "\u{2300A}"], [[194763, 194763], "mapped", "\u65E3"], [[194764, 194764], "mapped", "\u66F8"], [[194765, 194765], "mapped", "\u6649"], [[194766, 194766], "mapped", "\u3B19"], [[194767, 194767], "mapped", "\u6691"], [[194768, 194768], "mapped", "\u3B08"], [[194769, 194769], "mapped", "\u3AE4"], [[194770, 194770], "mapped", "\u5192"], [[194771, 194771], "mapped", "\u5195"], [[194772, 194772], "mapped", "\u6700"], [[194773, 194773], "mapped", "\u669C"], [[194774, 194774], "mapped", "\u80AD"], [[194775, 194775], "mapped", "\u43D9"], [[194776, 194776], "mapped", "\u6717"], [[194777, 194777], "mapped", "\u671B"], [[194778, 194778], "mapped", "\u6721"], [[194779, 194779], "mapped", "\u675E"], [[194780, 194780], "mapped", "\u6753"], [[194781, 194781], "mapped", "\u{233C3}"], [[194782, 194782], "mapped", "\u3B49"], [[194783, 194783], "mapped", "\u67FA"], [[194784, 194784], "mapped", "\u6785"], [[194785, 194785], "mapped", "\u6852"], [[194786, 194786], "mapped", "\u6885"], [[194787, 194787], "mapped", "\u{2346D}"], [[194788, 194788], "mapped", "\u688E"], [[194789, 194789], "mapped", "\u681F"], [[194790, 194790], "mapped", "\u6914"], [[194791, 194791], "mapped", "\u3B9D"], [[194792, 194792], "mapped", "\u6942"], [[194793, 194793], "mapped", "\u69A3"], [[194794, 194794], "mapped", "\u69EA"], [[194795, 194795], "mapped", "\u6AA8"], [[194796, 194796], "mapped", "\u{236A3}"], [[194797, 194797], "mapped", "\u6ADB"], [[194798, 194798], "mapped", "\u3C18"], [[194799, 194799], "mapped", "\u6B21"], [[194800, 194800], "mapped", "\u{238A7}"], [[194801, 194801], "mapped", "\u6B54"], [[194802, 194802], "mapped", "\u3C4E"], [[194803, 194803], "mapped", "\u6B72"], [[194804, 194804], "mapped", "\u6B9F"], [[194805, 194805], "mapped", "\u6BBA"], [[194806, 194806], "mapped", "\u6BBB"], [[194807, 194807], "mapped", "\u{23A8D}"], [[194808, 194808], "mapped", "\u{21D0B}"], [[194809, 194809], "mapped", "\u{23AFA}"], [[194810, 194810], "mapped", "\u6C4E"], [[194811, 194811], "mapped", "\u{23CBC}"], [[194812, 194812], "mapped", "\u6CBF"], [[194813, 194813], "mapped", "\u6CCD"], [[194814, 194814], "mapped", "\u6C67"], [[194815, 194815], "mapped", "\u6D16"], [[194816, 194816], "mapped", "\u6D3E"], [[194817, 194817], "mapped", "\u6D77"], [[194818, 194818], "mapped", "\u6D41"], [[194819, 194819], "mapped", "\u6D69"], [[194820, 194820], "mapped", "\u6D78"], [[194821, 194821], "mapped", "\u6D85"], [[194822, 194822], "mapped", "\u{23D1E}"], [[194823, 194823], "mapped", "\u6D34"], [[194824, 194824], "mapped", "\u6E2F"], [[194825, 194825], "mapped", "\u6E6E"], [[194826, 194826], "mapped", "\u3D33"], [[194827, 194827], "mapped", "\u6ECB"], [[194828, 194828], "mapped", "\u6EC7"], [[194829, 194829], "mapped", "\u{23ED1}"], [[194830, 194830], "mapped", "\u6DF9"], [[194831, 194831], "mapped", "\u6F6E"], [[194832, 194832], "mapped", "\u{23F5E}"], [[194833, 194833], "mapped", "\u{23F8E}"], [[194834, 194834], "mapped", "\u6FC6"], [[194835, 194835], "mapped", "\u7039"], [[194836, 194836], "mapped", "\u701E"], [[194837, 194837], "mapped", "\u701B"], [[194838, 194838], "mapped", "\u3D96"], [[194839, 194839], "mapped", "\u704A"], [[194840, 194840], "mapped", "\u707D"], [[194841, 194841], "mapped", "\u7077"], [[194842, 194842], "mapped", "\u70AD"], [[194843, 194843], "mapped", "\u{20525}"], [[194844, 194844], "mapped", "\u7145"], [[194845, 194845], "mapped", "\u{24263}"], [[194846, 194846], "mapped", "\u719C"], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", "\u7228"], [[194849, 194849], "mapped", "\u7235"], [[194850, 194850], "mapped", "\u7250"], [[194851, 194851], "mapped", "\u{24608}"], [[194852, 194852], "mapped", "\u7280"], [[194853, 194853], "mapped", "\u7295"], [[194854, 194854], "mapped", "\u{24735}"], [[194855, 194855], "mapped", "\u{24814}"], [[194856, 194856], "mapped", "\u737A"], [[194857, 194857], "mapped", "\u738B"], [[194858, 194858], "mapped", "\u3EAC"], [[194859, 194859], "mapped", "\u73A5"], [[194860, 194861], "mapped", "\u3EB8"], [[194862, 194862], "mapped", "\u7447"], [[194863, 194863], "mapped", "\u745C"], [[194864, 194864], "mapped", "\u7471"], [[194865, 194865], "mapped", "\u7485"], [[194866, 194866], "mapped", "\u74CA"], [[194867, 194867], "mapped", "\u3F1B"], [[194868, 194868], "mapped", "\u7524"], [[194869, 194869], "mapped", "\u{24C36}"], [[194870, 194870], "mapped", "\u753E"], [[194871, 194871], "mapped", "\u{24C92}"], [[194872, 194872], "mapped", "\u7570"], [[194873, 194873], "mapped", "\u{2219F}"], [[194874, 194874], "mapped", "\u7610"], [[194875, 194875], "mapped", "\u{24FA1}"], [[194876, 194876], "mapped", "\u{24FB8}"], [[194877, 194877], "mapped", "\u{25044}"], [[194878, 194878], "mapped", "\u3FFC"], [[194879, 194879], "mapped", "\u4008"], [[194880, 194880], "mapped", "\u76F4"], [[194881, 194881], "mapped", "\u{250F3}"], [[194882, 194882], "mapped", "\u{250F2}"], [[194883, 194883], "mapped", "\u{25119}"], [[194884, 194884], "mapped", "\u{25133}"], [[194885, 194885], "mapped", "\u771E"], [[194886, 194887], "mapped", "\u771F"], [[194888, 194888], "mapped", "\u774A"], [[194889, 194889], "mapped", "\u4039"], [[194890, 194890], "mapped", "\u778B"], [[194891, 194891], "mapped", "\u4046"], [[194892, 194892], "mapped", "\u4096"], [[194893, 194893], "mapped", "\u{2541D}"], [[194894, 194894], "mapped", "\u784E"], [[194895, 194895], "mapped", "\u788C"], [[194896, 194896], "mapped", "\u78CC"], [[194897, 194897], "mapped", "\u40E3"], [[194898, 194898], "mapped", "\u{25626}"], [[194899, 194899], "mapped", "\u7956"], [[194900, 194900], "mapped", "\u{2569A}"], [[194901, 194901], "mapped", "\u{256C5}"], [[194902, 194902], "mapped", "\u798F"], [[194903, 194903], "mapped", "\u79EB"], [[194904, 194904], "mapped", "\u412F"], [[194905, 194905], "mapped", "\u7A40"], [[194906, 194906], "mapped", "\u7A4A"], [[194907, 194907], "mapped", "\u7A4F"], [[194908, 194908], "mapped", "\u{2597C}"], [[194909, 194910], "mapped", "\u{25AA7}"], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", "\u4202"], [[194913, 194913], "mapped", "\u{25BAB}"], [[194914, 194914], "mapped", "\u7BC6"], [[194915, 194915], "mapped", "\u7BC9"], [[194916, 194916], "mapped", "\u4227"], [[194917, 194917], "mapped", "\u{25C80}"], [[194918, 194918], "mapped", "\u7CD2"], [[194919, 194919], "mapped", "\u42A0"], [[194920, 194920], "mapped", "\u7CE8"], [[194921, 194921], "mapped", "\u7CE3"], [[194922, 194922], "mapped", "\u7D00"], [[194923, 194923], "mapped", "\u{25F86}"], [[194924, 194924], "mapped", "\u7D63"], [[194925, 194925], "mapped", "\u4301"], [[194926, 194926], "mapped", "\u7DC7"], [[194927, 194927], "mapped", "\u7E02"], [[194928, 194928], "mapped", "\u7E45"], [[194929, 194929], "mapped", "\u4334"], [[194930, 194930], "mapped", "\u{26228}"], [[194931, 194931], "mapped", "\u{26247}"], [[194932, 194932], "mapped", "\u4359"], [[194933, 194933], "mapped", "\u{262D9}"], [[194934, 194934], "mapped", "\u7F7A"], [[194935, 194935], "mapped", "\u{2633E}"], [[194936, 194936], "mapped", "\u7F95"], [[194937, 194937], "mapped", "\u7FFA"], [[194938, 194938], "mapped", "\u8005"], [[194939, 194939], "mapped", "\u{264DA}"], [[194940, 194940], "mapped", "\u{26523}"], [[194941, 194941], "mapped", "\u8060"], [[194942, 194942], "mapped", "\u{265A8}"], [[194943, 194943], "mapped", "\u8070"], [[194944, 194944], "mapped", "\u{2335F}"], [[194945, 194945], "mapped", "\u43D5"], [[194946, 194946], "mapped", "\u80B2"], [[194947, 194947], "mapped", "\u8103"], [[194948, 194948], "mapped", "\u440B"], [[194949, 194949], "mapped", "\u813E"], [[194950, 194950], "mapped", "\u5AB5"], [[194951, 194951], "mapped", "\u{267A7}"], [[194952, 194952], "mapped", "\u{267B5}"], [[194953, 194953], "mapped", "\u{23393}"], [[194954, 194954], "mapped", "\u{2339C}"], [[194955, 194955], "mapped", "\u8201"], [[194956, 194956], "mapped", "\u8204"], [[194957, 194957], "mapped", "\u8F9E"], [[194958, 194958], "mapped", "\u446B"], [[194959, 194959], "mapped", "\u8291"], [[194960, 194960], "mapped", "\u828B"], [[194961, 194961], "mapped", "\u829D"], [[194962, 194962], "mapped", "\u52B3"], [[194963, 194963], "mapped", "\u82B1"], [[194964, 194964], "mapped", "\u82B3"], [[194965, 194965], "mapped", "\u82BD"], [[194966, 194966], "mapped", "\u82E6"], [[194967, 194967], "mapped", "\u{26B3C}"], [[194968, 194968], "mapped", "\u82E5"], [[194969, 194969], "mapped", "\u831D"], [[194970, 194970], "mapped", "\u8363"], [[194971, 194971], "mapped", "\u83AD"], [[194972, 194972], "mapped", "\u8323"], [[194973, 194973], "mapped", "\u83BD"], [[194974, 194974], "mapped", "\u83E7"], [[194975, 194975], "mapped", "\u8457"], [[194976, 194976], "mapped", "\u8353"], [[194977, 194977], "mapped", "\u83CA"], [[194978, 194978], "mapped", "\u83CC"], [[194979, 194979], "mapped", "\u83DC"], [[194980, 194980], "mapped", "\u{26C36}"], [[194981, 194981], "mapped", "\u{26D6B}"], [[194982, 194982], "mapped", "\u{26CD5}"], [[194983, 194983], "mapped", "\u452B"], [[194984, 194984], "mapped", "\u84F1"], [[194985, 194985], "mapped", "\u84F3"], [[194986, 194986], "mapped", "\u8516"], [[194987, 194987], "mapped", "\u{273CA}"], [[194988, 194988], "mapped", "\u8564"], [[194989, 194989], "mapped", "\u{26F2C}"], [[194990, 194990], "mapped", "\u455D"], [[194991, 194991], "mapped", "\u4561"], [[194992, 194992], "mapped", "\u{26FB1}"], [[194993, 194993], "mapped", "\u{270D2}"], [[194994, 194994], "mapped", "\u456B"], [[194995, 194995], "mapped", "\u8650"], [[194996, 194996], "mapped", "\u865C"], [[194997, 194997], "mapped", "\u8667"], [[194998, 194998], "mapped", "\u8669"], [[194999, 194999], "mapped", "\u86A9"], [[195e3, 195e3], "mapped", "\u8688"], [[195001, 195001], "mapped", "\u870E"], [[195002, 195002], "mapped", "\u86E2"], [[195003, 195003], "mapped", "\u8779"], [[195004, 195004], "mapped", "\u8728"], [[195005, 195005], "mapped", "\u876B"], [[195006, 195006], "mapped", "\u8786"], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", "\u87E1"], [[195009, 195009], "mapped", "\u8801"], [[195010, 195010], "mapped", "\u45F9"], [[195011, 195011], "mapped", "\u8860"], [[195012, 195012], "mapped", "\u8863"], [[195013, 195013], "mapped", "\u{27667}"], [[195014, 195014], "mapped", "\u88D7"], [[195015, 195015], "mapped", "\u88DE"], [[195016, 195016], "mapped", "\u4635"], [[195017, 195017], "mapped", "\u88FA"], [[195018, 195018], "mapped", "\u34BB"], [[195019, 195019], "mapped", "\u{278AE}"], [[195020, 195020], "mapped", "\u{27966}"], [[195021, 195021], "mapped", "\u46BE"], [[195022, 195022], "mapped", "\u46C7"], [[195023, 195023], "mapped", "\u8AA0"], [[195024, 195024], "mapped", "\u8AED"], [[195025, 195025], "mapped", "\u8B8A"], [[195026, 195026], "mapped", "\u8C55"], [[195027, 195027], "mapped", "\u{27CA8}"], [[195028, 195028], "mapped", "\u8CAB"], [[195029, 195029], "mapped", "\u8CC1"], [[195030, 195030], "mapped", "\u8D1B"], [[195031, 195031], "mapped", "\u8D77"], [[195032, 195032], "mapped", "\u{27F2F}"], [[195033, 195033], "mapped", "\u{20804}"], [[195034, 195034], "mapped", "\u8DCB"], [[195035, 195035], "mapped", "\u8DBC"], [[195036, 195036], "mapped", "\u8DF0"], [[195037, 195037], "mapped", "\u{208DE}"], [[195038, 195038], "mapped", "\u8ED4"], [[195039, 195039], "mapped", "\u8F38"], [[195040, 195040], "mapped", "\u{285D2}"], [[195041, 195041], "mapped", "\u{285ED}"], [[195042, 195042], "mapped", "\u9094"], [[195043, 195043], "mapped", "\u90F1"], [[195044, 195044], "mapped", "\u9111"], [[195045, 195045], "mapped", "\u{2872E}"], [[195046, 195046], "mapped", "\u911B"], [[195047, 195047], "mapped", "\u9238"], [[195048, 195048], "mapped", "\u92D7"], [[195049, 195049], "mapped", "\u92D8"], [[195050, 195050], "mapped", "\u927C"], [[195051, 195051], "mapped", "\u93F9"], [[195052, 195052], "mapped", "\u9415"], [[195053, 195053], "mapped", "\u{28BFA}"], [[195054, 195054], "mapped", "\u958B"], [[195055, 195055], "mapped", "\u4995"], [[195056, 195056], "mapped", "\u95B7"], [[195057, 195057], "mapped", "\u{28D77}"], [[195058, 195058], "mapped", "\u49E6"], [[195059, 195059], "mapped", "\u96C3"], [[195060, 195060], "mapped", "\u5DB2"], [[195061, 195061], "mapped", "\u9723"], [[195062, 195062], "mapped", "\u{29145}"], [[195063, 195063], "mapped", "\u{2921A}"], [[195064, 195064], "mapped", "\u4A6E"], [[195065, 195065], "mapped", "\u4A76"], [[195066, 195066], "mapped", "\u97E0"], [[195067, 195067], "mapped", "\u{2940A}"], [[195068, 195068], "mapped", "\u4AB2"], [[195069, 195069], "mapped", "\u{29496}"], [[195070, 195071], "mapped", "\u980B"], [[195072, 195072], "mapped", "\u9829"], [[195073, 195073], "mapped", "\u{295B6}"], [[195074, 195074], "mapped", "\u98E2"], [[195075, 195075], "mapped", "\u4B33"], [[195076, 195076], "mapped", "\u9929"], [[195077, 195077], "mapped", "\u99A7"], [[195078, 195078], "mapped", "\u99C2"], [[195079, 195079], "mapped", "\u99FE"], [[195080, 195080], "mapped", "\u4BCE"], [[195081, 195081], "mapped", "\u{29B30}"], [[195082, 195082], "mapped", "\u9B12"], [[195083, 195083], "mapped", "\u9C40"], [[195084, 195084], "mapped", "\u9CFD"], [[195085, 195085], "mapped", "\u4CCE"], [[195086, 195086], "mapped", "\u4CED"], [[195087, 195087], "mapped", "\u9D67"], [[195088, 195088], "mapped", "\u{2A0CE}"], [[195089, 195089], "mapped", "\u4CF8"], [[195090, 195090], "mapped", "\u{2A105}"], [[195091, 195091], "mapped", "\u{2A20E}"], [[195092, 195092], "mapped", "\u{2A291}"], [[195093, 195093], "mapped", "\u9EBB"], [[195094, 195094], "mapped", "\u4D56"], [[195095, 195095], "mapped", "\u9EF9"], [[195096, 195096], "mapped", "\u9EFE"], [[195097, 195097], "mapped", "\u9F05"], [[195098, 195098], "mapped", "\u9F0F"], [[195099, 195099], "mapped", "\u9F16"], [[195100, 195100], "mapped", "\u9F3B"], [[195101, 195101], "mapped", "\u{2A600}"], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
  }
});

// node_modules/tr46/index.js
var require_tr46 = __commonJS({
  "node_modules/tr46/index.js"(exports, module) {
    "use strict";
    var punycode = __require("punycode");
    var regexes = require_regexes();
    var mappingTable = require_mappingTable();
    function containsNonASCII(str) {
      return /[^\x00-\x7F]/.test(str);
    }
    function findStatus(val, { useSTD3ASCIIRules }) {
      let start = 0;
      let end = mappingTable.length - 1;
      while (start <= end) {
        const mid = Math.floor((start + end) / 2);
        const target = mappingTable[mid];
        if (target[0][0] <= val && target[0][1] >= val) {
          if (target[1].startsWith("disallowed_STD3_")) {
            const newStatus = useSTD3ASCIIRules ? "disallowed" : target[1].slice(16);
            return [newStatus, ...target.slice(2)];
          }
          return target.slice(1);
        } else if (target[0][0] > val) {
          end = mid - 1;
        } else {
          start = mid + 1;
        }
      }
      return null;
    }
    function mapChars(domainName, { useSTD3ASCIIRules, processingOption }) {
      let hasError = false;
      let processed = "";
      for (const ch of domainName) {
        const [status, mapping] = findStatus(ch.codePointAt(0), { useSTD3ASCIIRules });
        switch (status) {
          case "disallowed":
            hasError = true;
            processed += ch;
            break;
          case "ignored":
            break;
          case "mapped":
            processed += mapping;
            break;
          case "deviation":
            if (processingOption === "transitional") {
              processed += mapping;
            } else {
              processed += ch;
            }
            break;
          case "valid":
            processed += ch;
            break;
        }
      }
      return {
        string: processed,
        error: hasError
      };
    }
    function validateLabel(label, { checkHyphens, checkBidi, checkJoiners, processingOption, useSTD3ASCIIRules }) {
      if (label.normalize("NFC") !== label) {
        return false;
      }
      const codePoints = Array.from(label);
      if (checkHyphens) {
        if (codePoints[2] === "-" && codePoints[3] === "-" || (label.startsWith("-") || label.endsWith("-"))) {
          return false;
        }
      }
      if (label.includes(".") || codePoints.length > 0 && regexes.combiningMarks.test(codePoints[0])) {
        return false;
      }
      for (const ch of codePoints) {
        const [status] = findStatus(ch.codePointAt(0), { useSTD3ASCIIRules });
        if (processingOption === "transitional" && status !== "valid" || processingOption === "nontransitional" && status !== "valid" && status !== "deviation") {
          return false;
        }
      }
      if (checkJoiners) {
        let last = 0;
        for (const [i, ch] of codePoints.entries()) {
          if (ch === "\u200C" || ch === "\u200D") {
            if (i > 0) {
              if (regexes.combiningClassVirama.test(codePoints[i - 1])) {
                continue;
              }
              if (ch === "\u200C") {
                const next = codePoints.indexOf("\u200C", i + 1);
                const test = next < 0 ? codePoints.slice(last) : codePoints.slice(last, next);
                if (regexes.validZWNJ.test(test.join(""))) {
                  last = i + 1;
                  continue;
                }
              }
            }
            return false;
          }
        }
      }
      if (checkBidi) {
        let rtl;
        if (regexes.bidiS1LTR.test(codePoints[0])) {
          rtl = false;
        } else if (regexes.bidiS1RTL.test(codePoints[0])) {
          rtl = true;
        } else {
          return false;
        }
        if (rtl) {
          if (!regexes.bidiS2.test(label) || !regexes.bidiS3.test(label) || regexes.bidiS4EN.test(label) && regexes.bidiS4AN.test(label)) {
            return false;
          }
        } else if (!regexes.bidiS5.test(label) || !regexes.bidiS6.test(label)) {
          return false;
        }
      }
      return true;
    }
    function isBidiDomain(labels) {
      const domain = labels.map((label) => {
        if (label.startsWith("xn--")) {
          try {
            return punycode.decode(label.substring(4));
          } catch (err) {
            return "";
          }
        }
        return label;
      }).join(".");
      return regexes.bidiDomain.test(domain);
    }
    function processing(domainName, options) {
      const { processingOption } = options;
      let { string: string2, error } = mapChars(domainName, options);
      string2 = string2.normalize("NFC");
      const labels = string2.split(".");
      const isBidi = isBidiDomain(labels);
      for (const [i, origLabel] of labels.entries()) {
        let label = origLabel;
        let curProcessing = processingOption;
        if (label.startsWith("xn--")) {
          try {
            label = punycode.decode(label.substring(4));
            labels[i] = label;
          } catch (err) {
            error = true;
            continue;
          }
          curProcessing = "nontransitional";
        }
        if (error) {
          continue;
        }
        const validation = validateLabel(label, Object.assign({}, options, {
          processingOption: curProcessing,
          checkBidi: options.checkBidi && isBidi
        }));
        if (!validation) {
          error = true;
        }
      }
      return {
        string: labels.join("."),
        error
      };
    }
    function toASCII(domainName, {
      checkHyphens = false,
      checkBidi = false,
      checkJoiners = false,
      useSTD3ASCIIRules = false,
      processingOption = "nontransitional",
      verifyDNSLength = false
    } = {}) {
      if (processingOption !== "transitional" && processingOption !== "nontransitional") {
        throw new RangeError("processingOption must be either transitional or nontransitional");
      }
      const result = processing(domainName, {
        processingOption,
        checkHyphens,
        checkBidi,
        checkJoiners,
        useSTD3ASCIIRules
      });
      let labels = result.string.split(".");
      labels = labels.map((l) => {
        if (containsNonASCII(l)) {
          try {
            return "xn--" + punycode.encode(l);
          } catch (e) {
            result.error = true;
          }
        }
        return l;
      });
      if (verifyDNSLength) {
        const total = labels.join(".").length;
        if (total > 253 || total === 0) {
          result.error = true;
        }
        for (let i = 0; i < labels.length; ++i) {
          if (labels[i].length > 63 || labels[i].length === 0) {
            result.error = true;
            break;
          }
        }
      }
      if (result.error) {
        return null;
      }
      return labels.join(".");
    }
    function toUnicode(domainName, {
      checkHyphens = false,
      checkBidi = false,
      checkJoiners = false,
      useSTD3ASCIIRules = false
    } = {}) {
      const result = processing(domainName, {
        processingOption: "nontransitional",
        checkHyphens,
        checkBidi,
        checkJoiners,
        useSTD3ASCIIRules
      });
      return {
        domain: result.string,
        error: result.error
      };
    }
    module.exports = {
      toASCII,
      toUnicode
    };
  }
});

// node_modules/whatwg-url/lib/infra.js
var require_infra = __commonJS({
  "node_modules/whatwg-url/lib/infra.js"(exports, module) {
    "use strict";
    function isASCIIDigit(c) {
      return c >= 48 && c <= 57;
    }
    function isASCIIAlpha(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122;
    }
    function isASCIIAlphanumeric(c) {
      return isASCIIAlpha(c) || isASCIIDigit(c);
    }
    function isASCIIHex(c) {
      return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
    }
    module.exports = {
      isASCIIDigit,
      isASCIIAlpha,
      isASCIIAlphanumeric,
      isASCIIHex
    };
  }
});

// node_modules/whatwg-url/lib/urlencoded.js
var require_urlencoded = __commonJS({
  "node_modules/whatwg-url/lib/urlencoded.js"(exports, module) {
    "use strict";
    var { isASCIIHex } = require_infra();
    function strictlySplitByteSequence(buf, cp) {
      const list = [];
      let last = 0;
      let i = buf.indexOf(cp);
      while (i >= 0) {
        list.push(buf.slice(last, i));
        last = i + 1;
        i = buf.indexOf(cp, last);
      }
      if (last !== buf.length) {
        list.push(buf.slice(last));
      }
      return list;
    }
    function replaceByteInByteSequence(buf, from, to) {
      let i = buf.indexOf(from);
      while (i >= 0) {
        buf[i] = to;
        i = buf.indexOf(from, i + 1);
      }
      return buf;
    }
    function percentEncode(c) {
      let hex = c.toString(16).toUpperCase();
      if (hex.length === 1) {
        hex = "0" + hex;
      }
      return "%" + hex;
    }
    function percentDecode(input) {
      const output2 = Buffer.alloc(input.byteLength);
      let ptr = 0;
      for (let i = 0; i < input.length; ++i) {
        if (input[i] !== 37 || !isASCIIHex(input[i + 1]) || !isASCIIHex(input[i + 2])) {
          output2[ptr++] = input[i];
        } else {
          output2[ptr++] = parseInt(input.slice(i + 1, i + 3).toString(), 16);
          i += 2;
        }
      }
      return output2.slice(0, ptr);
    }
    function parseUrlencoded(input) {
      const sequences = strictlySplitByteSequence(input, 38);
      const output2 = [];
      for (const bytes2 of sequences) {
        if (bytes2.length === 0) {
          continue;
        }
        let name;
        let value;
        const indexOfEqual = bytes2.indexOf(61);
        if (indexOfEqual >= 0) {
          name = bytes2.slice(0, indexOfEqual);
          value = bytes2.slice(indexOfEqual + 1);
        } else {
          name = bytes2;
          value = Buffer.alloc(0);
        }
        name = replaceByteInByteSequence(Buffer.from(name), 43, 32);
        value = replaceByteInByteSequence(Buffer.from(value), 43, 32);
        output2.push([percentDecode(name).toString(), percentDecode(value).toString()]);
      }
      return output2;
    }
    function serializeUrlencodedByte(input) {
      let output2 = "";
      for (const byte of input) {
        if (byte === 32) {
          output2 += "+";
        } else if (byte === 42 || byte === 45 || byte === 46 || byte >= 48 && byte <= 57 || byte >= 65 && byte <= 90 || byte === 95 || byte >= 97 && byte <= 122) {
          output2 += String.fromCodePoint(byte);
        } else {
          output2 += percentEncode(byte);
        }
      }
      return output2;
    }
    function serializeUrlencoded(tuples, encodingOverride = void 0) {
      let encoding = "utf-8";
      if (encodingOverride !== void 0) {
        encoding = encodingOverride;
      }
      let output2 = "";
      for (const [i, tuple2] of tuples.entries()) {
        const name = serializeUrlencodedByte(Buffer.from(tuple2[0]));
        let value = tuple2[1];
        if (tuple2.length > 2 && tuple2[2] !== void 0) {
          if (tuple2[2] === "hidden" && name === "_charset_") {
            value = encoding;
          } else if (tuple2[2] === "file") {
            value = value.name;
          }
        }
        value = serializeUrlencodedByte(Buffer.from(value));
        if (i !== 0) {
          output2 += "&";
        }
        output2 += `${name}=${value}`;
      }
      return output2;
    }
    module.exports = {
      percentEncode,
      percentDecode,
      // application/x-www-form-urlencoded string parser
      parseUrlencoded(input) {
        return parseUrlencoded(Buffer.from(input));
      },
      // application/x-www-form-urlencoded serializer
      serializeUrlencoded
    };
  }
});

// node_modules/whatwg-url/lib/url-state-machine.js
var require_url_state_machine = __commonJS({
  "node_modules/whatwg-url/lib/url-state-machine.js"(exports, module) {
    "use strict";
    var punycode = __require("punycode");
    var tr46 = require_tr46();
    var infra = require_infra();
    var { percentEncode, percentDecode } = require_urlencoded();
    var specialSchemes = {
      ftp: 21,
      file: null,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var failure = Symbol("failure");
    function countSymbols(str) {
      return punycode.ucs2.decode(str).length;
    }
    function at(input, idx) {
      const c = input[idx];
      return isNaN(c) ? void 0 : String.fromCodePoint(c);
    }
    function isSingleDot(buffer) {
      return buffer === "." || buffer.toLowerCase() === "%2e";
    }
    function isDoubleDot(buffer) {
      buffer = buffer.toLowerCase();
      return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
    }
    function isWindowsDriveLetterCodePoints(cp1, cp2) {
      return infra.isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
    }
    function isWindowsDriveLetterString(string2) {
      return string2.length === 2 && infra.isASCIIAlpha(string2.codePointAt(0)) && (string2[1] === ":" || string2[1] === "|");
    }
    function isNormalizedWindowsDriveLetterString(string2) {
      return string2.length === 2 && infra.isASCIIAlpha(string2.codePointAt(0)) && string2[1] === ":";
    }
    function containsForbiddenHostCodePoint(string2) {
      return string2.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function containsForbiddenHostCodePointExcludingPercent(string2) {
      return string2.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
    }
    function isSpecialScheme(scheme) {
      return specialSchemes[scheme] !== void 0;
    }
    function isSpecial(url) {
      return isSpecialScheme(url.scheme);
    }
    function isNotSpecial(url) {
      return !isSpecialScheme(url.scheme);
    }
    function defaultPort(scheme) {
      return specialSchemes[scheme];
    }
    function utf8PercentEncode(c) {
      const buf = Buffer.from(c);
      let str = "";
      for (let i = 0; i < buf.length; ++i) {
        str += percentEncode(buf[i]);
      }
      return str;
    }
    function isC0ControlPercentEncode(c) {
      return c <= 31 || c > 126;
    }
    var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
    function isUserinfoPercentEncode(c) {
      return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
    }
    var extraFragmentPercentEncodeSet = /* @__PURE__ */ new Set([32, 34, 60, 62, 96]);
    function isFragmentPercentEncode(c) {
      return isC0ControlPercentEncode(c) || extraFragmentPercentEncodeSet.has(c);
    }
    var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([35, 63, 123, 125]);
    function isPathPercentEncode(c) {
      return isFragmentPercentEncode(c) || extraPathPercentEncodeSet.has(c);
    }
    function percentEncodeChar(c, encodeSetPredicate) {
      const cStr = String.fromCodePoint(c);
      if (encodeSetPredicate(c)) {
        return utf8PercentEncode(cStr);
      }
      return cStr;
    }
    function parseIPv4Number(input) {
      let R = 10;
      if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
        input = input.substring(2);
        R = 16;
      } else if (input.length >= 2 && input.charAt(0) === "0") {
        input = input.substring(1);
        R = 8;
      }
      if (input === "") {
        return 0;
      }
      let regex = /[^0-7]/;
      if (R === 10) {
        regex = /[^0-9]/;
      }
      if (R === 16) {
        regex = /[^0-9A-Fa-f]/;
      }
      if (regex.test(input)) {
        return failure;
      }
      return parseInt(input, R);
    }
    function parseIPv4(input) {
      const parts = input.split(".");
      if (parts[parts.length - 1] === "") {
        if (parts.length > 1) {
          parts.pop();
        }
      }
      if (parts.length > 4) {
        return input;
      }
      const numbers = [];
      for (const part of parts) {
        if (part === "") {
          return input;
        }
        const n = parseIPv4Number(part);
        if (n === failure) {
          return input;
        }
        numbers.push(n);
      }
      for (let i = 0; i < numbers.length - 1; ++i) {
        if (numbers[i] > 255) {
          return failure;
        }
      }
      if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
        return failure;
      }
      let ipv4 = numbers.pop();
      let counter = 0;
      for (const n of numbers) {
        ipv4 += n * Math.pow(256, 3 - counter);
        ++counter;
      }
      return ipv4;
    }
    function serializeIPv4(address) {
      let output2 = "";
      let n = address;
      for (let i = 1; i <= 4; ++i) {
        output2 = String(n % 256) + output2;
        if (i !== 4) {
          output2 = "." + output2;
        }
        n = Math.floor(n / 256);
      }
      return output2;
    }
    function parseIPv6(input) {
      const address = [0, 0, 0, 0, 0, 0, 0, 0];
      let pieceIndex = 0;
      let compress = null;
      let pointer = 0;
      input = punycode.ucs2.decode(input);
      if (input[pointer] === 58) {
        if (input[pointer + 1] !== 58) {
          return failure;
        }
        pointer += 2;
        ++pieceIndex;
        compress = pieceIndex;
      }
      while (pointer < input.length) {
        if (pieceIndex === 8) {
          return failure;
        }
        if (input[pointer] === 58) {
          if (compress !== null) {
            return failure;
          }
          ++pointer;
          ++pieceIndex;
          compress = pieceIndex;
          continue;
        }
        let value = 0;
        let length = 0;
        while (length < 4 && infra.isASCIIHex(input[pointer])) {
          value = value * 16 + parseInt(at(input, pointer), 16);
          ++pointer;
          ++length;
        }
        if (input[pointer] === 46) {
          if (length === 0) {
            return failure;
          }
          pointer -= length;
          if (pieceIndex > 6) {
            return failure;
          }
          let numbersSeen = 0;
          while (input[pointer] !== void 0) {
            let ipv4Piece = null;
            if (numbersSeen > 0) {
              if (input[pointer] === 46 && numbersSeen < 4) {
                ++pointer;
              } else {
                return failure;
              }
            }
            if (!infra.isASCIIDigit(input[pointer])) {
              return failure;
            }
            while (infra.isASCIIDigit(input[pointer])) {
              const number3 = parseInt(at(input, pointer));
              if (ipv4Piece === null) {
                ipv4Piece = number3;
              } else if (ipv4Piece === 0) {
                return failure;
              } else {
                ipv4Piece = ipv4Piece * 10 + number3;
              }
              if (ipv4Piece > 255) {
                return failure;
              }
              ++pointer;
            }
            address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
            ++numbersSeen;
            if (numbersSeen === 2 || numbersSeen === 4) {
              ++pieceIndex;
            }
          }
          if (numbersSeen !== 4) {
            return failure;
          }
          break;
        } else if (input[pointer] === 58) {
          ++pointer;
          if (input[pointer] === void 0) {
            return failure;
          }
        } else if (input[pointer] !== void 0) {
          return failure;
        }
        address[pieceIndex] = value;
        ++pieceIndex;
      }
      if (compress !== null) {
        let swaps = pieceIndex - compress;
        pieceIndex = 7;
        while (pieceIndex !== 0 && swaps > 0) {
          const temp = address[compress + swaps - 1];
          address[compress + swaps - 1] = address[pieceIndex];
          address[pieceIndex] = temp;
          --pieceIndex;
          --swaps;
        }
      } else if (compress === null && pieceIndex !== 8) {
        return failure;
      }
      return address;
    }
    function serializeIPv6(address) {
      let output2 = "";
      const seqResult = findLongestZeroSequence(address);
      const compress = seqResult.idx;
      let ignore0 = false;
      for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
        if (ignore0 && address[pieceIndex] === 0) {
          continue;
        } else if (ignore0) {
          ignore0 = false;
        }
        if (compress === pieceIndex) {
          const separator = pieceIndex === 0 ? "::" : ":";
          output2 += separator;
          ignore0 = true;
          continue;
        }
        output2 += address[pieceIndex].toString(16);
        if (pieceIndex !== 7) {
          output2 += ":";
        }
      }
      return output2;
    }
    function parseHost(input, isNotSpecialArg = false) {
      if (input[0] === "[") {
        if (input[input.length - 1] !== "]") {
          return failure;
        }
        return parseIPv6(input.substring(1, input.length - 1));
      }
      if (isNotSpecialArg) {
        return parseOpaqueHost(input);
      }
      const domain = percentDecode(Buffer.from(input)).toString();
      const asciiDomain = domainToASCII(domain);
      if (asciiDomain === failure) {
        return failure;
      }
      if (containsForbiddenHostCodePoint(asciiDomain)) {
        return failure;
      }
      const ipv4Host = parseIPv4(asciiDomain);
      if (typeof ipv4Host === "number" || ipv4Host === failure) {
        return ipv4Host;
      }
      return asciiDomain;
    }
    function parseOpaqueHost(input) {
      if (containsForbiddenHostCodePointExcludingPercent(input)) {
        return failure;
      }
      let output2 = "";
      const decoded = punycode.ucs2.decode(input);
      for (let i = 0; i < decoded.length; ++i) {
        output2 += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
      }
      return output2;
    }
    function findLongestZeroSequence(arr) {
      let maxIdx = null;
      let maxLen = 1;
      let currStart = null;
      let currLen = 0;
      for (let i = 0; i < arr.length; ++i) {
        if (arr[i] !== 0) {
          if (currLen > maxLen) {
            maxIdx = currStart;
            maxLen = currLen;
          }
          currStart = null;
          currLen = 0;
        } else {
          if (currStart === null) {
            currStart = i;
          }
          ++currLen;
        }
      }
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }
      return {
        idx: maxIdx,
        len: maxLen
      };
    }
    function serializeHost(host) {
      if (typeof host === "number") {
        return serializeIPv4(host);
      }
      if (host instanceof Array) {
        return "[" + serializeIPv6(host) + "]";
      }
      return host;
    }
    function domainToASCII(domain, beStrict = false) {
      const result = tr46.toASCII(domain, {
        checkBidi: true,
        checkHyphens: false,
        checkJoiners: true,
        useSTD3ASCIIRules: beStrict,
        verifyDNSLength: beStrict
      });
      if (result === null) {
        return failure;
      }
      return result;
    }
    function trimControlChars(url) {
      return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
    }
    function trimTabAndNewline(url) {
      return url.replace(/\u0009|\u000A|\u000D/g, "");
    }
    function shortenPath(url) {
      const { path } = url;
      if (path.length === 0) {
        return;
      }
      if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
        return;
      }
      path.pop();
    }
    function includesCredentials(url) {
      return url.username !== "" || url.password !== "";
    }
    function cannotHaveAUsernamePasswordPort(url) {
      return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
    }
    function isNormalizedWindowsDriveLetter(string2) {
      return /^[A-Za-z]:$/.test(string2);
    }
    function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
      this.pointer = 0;
      this.input = input;
      this.base = base || null;
      this.encodingOverride = encodingOverride || "utf-8";
      this.stateOverride = stateOverride;
      this.url = url;
      this.failure = false;
      this.parseError = false;
      if (!this.url) {
        this.url = {
          scheme: "",
          username: "",
          password: "",
          host: null,
          port: null,
          path: [],
          query: null,
          fragment: null,
          cannotBeABaseURL: false
        };
        const res2 = trimControlChars(this.input);
        if (res2 !== this.input) {
          this.parseError = true;
        }
        this.input = res2;
      }
      const res = trimTabAndNewline(this.input);
      if (res !== this.input) {
        this.parseError = true;
      }
      this.input = res;
      this.state = stateOverride || "scheme start";
      this.buffer = "";
      this.atFlag = false;
      this.arrFlag = false;
      this.passwordTokenSeenFlag = false;
      this.input = punycode.ucs2.decode(this.input);
      for (; this.pointer <= this.input.length; ++this.pointer) {
        const c = this.input[this.pointer];
        const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
        const ret = this["parse " + this.state](c, cStr);
        if (!ret) {
          break;
        } else if (ret === failure) {
          this.failure = true;
          break;
        }
      }
    }
    URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
      if (infra.isASCIIAlpha(c)) {
        this.buffer += cStr.toLowerCase();
        this.state = "scheme";
      } else if (!this.stateOverride) {
        this.state = "no scheme";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
      if (infra.isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
        this.buffer += cStr.toLowerCase();
      } else if (c === 58) {
        if (this.stateOverride) {
          if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
            return false;
          }
          if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
            return false;
          }
          if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
            return false;
          }
          if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
            return false;
          }
        }
        this.url.scheme = this.buffer;
        if (this.stateOverride) {
          if (this.url.port === defaultPort(this.url.scheme)) {
            this.url.port = null;
          }
          return false;
        }
        this.buffer = "";
        if (this.url.scheme === "file") {
          if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
            this.parseError = true;
          }
          this.state = "file";
        } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
          this.state = "special relative or authority";
        } else if (isSpecial(this.url)) {
          this.state = "special authority slashes";
        } else if (this.input[this.pointer + 1] === 47) {
          this.state = "path or authority";
          ++this.pointer;
        } else {
          this.url.cannotBeABaseURL = true;
          this.url.path.push("");
          this.state = "cannot-be-a-base-URL path";
        }
      } else if (!this.stateOverride) {
        this.buffer = "";
        this.state = "no scheme";
        this.pointer = -1;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
      if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
        return failure;
      } else if (this.base.cannotBeABaseURL && c === 35) {
        this.url.scheme = this.base.scheme;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.url.cannotBeABaseURL = true;
        this.state = "fragment";
      } else if (this.base.scheme === "file") {
        this.state = "file";
        --this.pointer;
      } else {
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "relative";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
      if (c === 47) {
        this.state = "authority";
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
      this.url.scheme = this.base.scheme;
      if (isNaN(c)) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
      } else if (c === 47) {
        this.state = "relative slash";
      } else if (c === 63) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice();
        this.url.query = this.base.query;
        this.url.fragment = "";
        this.state = "fragment";
      } else if (isSpecial(this.url) && c === 92) {
        this.parseError = true;
        this.state = "relative slash";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.url.path = this.base.path.slice(0, this.base.path.length - 1);
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
      if (isSpecial(this.url) && (c === 47 || c === 92)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "special authority ignore slashes";
      } else if (c === 47) {
        this.state = "authority";
      } else {
        this.url.username = this.base.username;
        this.url.password = this.base.password;
        this.url.host = this.base.host;
        this.url.port = this.base.port;
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
      if (c === 47 && this.input[this.pointer + 1] === 47) {
        this.state = "special authority ignore slashes";
        ++this.pointer;
      } else {
        this.parseError = true;
        this.state = "special authority ignore slashes";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
      if (c !== 47 && c !== 92) {
        this.state = "authority";
        --this.pointer;
      } else {
        this.parseError = true;
      }
      return true;
    };
    URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
      if (c === 64) {
        this.parseError = true;
        if (this.atFlag) {
          this.buffer = "%40" + this.buffer;
        }
        this.atFlag = true;
        const len = countSymbols(this.buffer);
        for (let pointer = 0; pointer < len; ++pointer) {
          const codePoint = this.buffer.codePointAt(pointer);
          if (codePoint === 58 && !this.passwordTokenSeenFlag) {
            this.passwordTokenSeenFlag = true;
            continue;
          }
          const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
          if (this.passwordTokenSeenFlag) {
            this.url.password += encodedCodePoints;
          } else {
            this.url.username += encodedCodePoints;
          }
        }
        this.buffer = "";
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        if (this.atFlag && this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        this.pointer -= countSymbols(this.buffer) + 1;
        this.buffer = "";
        this.state = "host";
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
      if (this.stateOverride && this.url.scheme === "file") {
        --this.pointer;
        this.state = "file host";
      } else if (c === 58 && !this.arrFlag) {
        if (this.buffer === "") {
          this.parseError = true;
          return failure;
        }
        const host = parseHost(this.buffer, isNotSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "port";
        if (this.stateOverride === "hostname") {
          return false;
        }
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
        --this.pointer;
        if (isSpecial(this.url) && this.buffer === "") {
          this.parseError = true;
          return failure;
        } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
          this.parseError = true;
          return false;
        }
        const host = parseHost(this.buffer, isNotSpecial(this.url));
        if (host === failure) {
          return failure;
        }
        this.url.host = host;
        this.buffer = "";
        this.state = "path start";
        if (this.stateOverride) {
          return false;
        }
      } else {
        if (c === 91) {
          this.arrFlag = true;
        } else if (c === 93) {
          this.arrFlag = false;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
      if (infra.isASCIIDigit(c)) {
        this.buffer += cStr;
      } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
        if (this.buffer !== "") {
          const port = parseInt(this.buffer);
          if (port > Math.pow(2, 16) - 1) {
            this.parseError = true;
            return failure;
          }
          this.url.port = port === defaultPort(this.url.scheme) ? null : port;
          this.buffer = "";
        }
        if (this.stateOverride) {
          return false;
        }
        this.state = "path start";
        --this.pointer;
      } else {
        this.parseError = true;
        return failure;
      }
      return true;
    };
    var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([47, 92, 63, 35]);
    function startsWithWindowsDriveLetter(input, pointer) {
      const length = input.length - pointer;
      return length >= 2 && isWindowsDriveLetterCodePoints(input[pointer], input[pointer + 1]) && (length === 2 || fileOtherwiseCodePoints.has(input[pointer + 2]));
    }
    URLStateMachine.prototype["parse file"] = function parseFile(c) {
      this.url.scheme = "file";
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file slash";
      } else if (this.base !== null && this.base.scheme === "file") {
        if (isNaN(c)) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
        } else if (c === 63) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = "";
          this.state = "query";
        } else if (c === 35) {
          this.url.host = this.base.host;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (!startsWithWindowsDriveLetter(this.input, this.pointer)) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            shortenPath(this.url);
          } else {
            this.parseError = true;
          }
          this.state = "path";
          --this.pointer;
        }
      } else {
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
      if (c === 47 || c === 92) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "file host";
      } else {
        if (this.base !== null && this.base.scheme === "file" && !startsWithWindowsDriveLetter(this.input, this.pointer)) {
          if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
            this.url.path.push(this.base.path[0]);
          } else {
            this.url.host = this.base.host;
          }
        }
        this.state = "path";
        --this.pointer;
      }
      return true;
    };
    URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
      if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
        --this.pointer;
        if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
          this.parseError = true;
          this.state = "path";
        } else if (this.buffer === "") {
          this.url.host = "";
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
        } else {
          let host = parseHost(this.buffer, isNotSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          if (host === "localhost") {
            host = "";
          }
          this.url.host = host;
          if (this.stateOverride) {
            return false;
          }
          this.buffer = "";
          this.state = "path start";
        }
      } else {
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
      if (isSpecial(this.url)) {
        if (c === 92) {
          this.parseError = true;
        }
        this.state = "path";
        if (c !== 47 && c !== 92) {
          --this.pointer;
        }
      } else if (!this.stateOverride && c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (!this.stateOverride && c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else if (c !== void 0) {
        this.state = "path";
        if (c !== 47) {
          --this.pointer;
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse path"] = function parsePath(c) {
      if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
        if (isSpecial(this.url) && c === 92) {
          this.parseError = true;
        }
        if (isDoubleDot(this.buffer)) {
          shortenPath(this.url);
          if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
            this.url.path.push("");
          }
        } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
          this.url.path.push("");
        } else if (!isSingleDot(this.buffer)) {
          if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
            if (this.url.host !== "" && this.url.host !== null) {
              this.parseError = true;
              this.url.host = "";
            }
            this.buffer = this.buffer[0] + ":";
          }
          this.url.path.push(this.buffer);
        }
        this.buffer = "";
        if (this.url.scheme === "file" && (c === void 0 || c === 63 || c === 35)) {
          while (this.url.path.length > 1 && this.url.path[0] === "") {
            this.parseError = true;
            this.url.path.shift();
          }
        }
        if (c === 63) {
          this.url.query = "";
          this.state = "query";
        }
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += percentEncodeChar(c, isPathPercentEncode);
      }
      return true;
    };
    URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
      if (c === 63) {
        this.url.query = "";
        this.state = "query";
      } else if (c === 35) {
        this.url.fragment = "";
        this.state = "fragment";
      } else {
        if (!isNaN(c) && c !== 37) {
          this.parseError = true;
        }
        if (c === 37 && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        if (!isNaN(c)) {
          this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
        }
      }
      return true;
    };
    URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
      if (isNaN(c) || !this.stateOverride && c === 35) {
        if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
          this.encodingOverride = "utf-8";
        }
        const buffer = Buffer.from(this.buffer);
        for (let i = 0; i < buffer.length; ++i) {
          if (buffer[i] < 33 || buffer[i] > 126 || buffer[i] === 34 || buffer[i] === 35 || buffer[i] === 60 || buffer[i] === 62 || buffer[i] === 39 && isSpecial(this.url)) {
            this.url.query += percentEncode(buffer[i]);
          } else {
            this.url.query += String.fromCodePoint(buffer[i]);
          }
        }
        this.buffer = "";
        if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        }
      } else {
        if (c === 37 && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.buffer += cStr;
      }
      return true;
    };
    URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
      if (isNaN(c)) {
      } else if (c === 0) {
        this.parseError = true;
      } else {
        if (c === 37 && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {
          this.parseError = true;
        }
        this.url.fragment += percentEncodeChar(c, isFragmentPercentEncode);
      }
      return true;
    };
    function serializeURL(url, excludeFragment) {
      let output2 = url.scheme + ":";
      if (url.host !== null) {
        output2 += "//";
        if (url.username !== "" || url.password !== "") {
          output2 += url.username;
          if (url.password !== "") {
            output2 += ":" + url.password;
          }
          output2 += "@";
        }
        output2 += serializeHost(url.host);
        if (url.port !== null) {
          output2 += ":" + url.port;
        }
      } else if (url.host === null && url.scheme === "file") {
        output2 += "//";
      }
      if (url.cannotBeABaseURL) {
        output2 += url.path[0];
      } else {
        for (const string2 of url.path) {
          output2 += "/" + string2;
        }
      }
      if (url.query !== null) {
        output2 += "?" + url.query;
      }
      if (!excludeFragment && url.fragment !== null) {
        output2 += "#" + url.fragment;
      }
      return output2;
    }
    function serializeOrigin(tuple2) {
      let result = tuple2.scheme + "://";
      result += serializeHost(tuple2.host);
      if (tuple2.port !== null) {
        result += ":" + tuple2.port;
      }
      return result;
    }
    module.exports.serializeURL = serializeURL;
    module.exports.serializeURLOrigin = function(url) {
      switch (url.scheme) {
        case "blob":
          try {
            return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));
          } catch (e) {
            return "null";
          }
        case "ftp":
        case "http":
        case "https":
        case "ws":
        case "wss":
          return serializeOrigin({
            scheme: url.scheme,
            host: url.host,
            port: url.port
          });
        case "file":
          return "null";
        default:
          return "null";
      }
    };
    module.exports.basicURLParse = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
      if (usm.failure) {
        return null;
      }
      return usm.url;
    };
    module.exports.setTheUsername = function(url, username) {
      url.username = "";
      const decoded = punycode.ucs2.decode(username);
      for (let i = 0; i < decoded.length; ++i) {
        url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
      }
    };
    module.exports.setThePassword = function(url, password) {
      url.password = "";
      const decoded = punycode.ucs2.decode(password);
      for (let i = 0; i < decoded.length; ++i) {
        url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
      }
    };
    module.exports.serializeHost = serializeHost;
    module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
    module.exports.serializeInteger = function(integer) {
      return String(integer);
    };
    module.exports.parseURL = function(input, options) {
      if (options === void 0) {
        options = {};
      }
      return module.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
    };
  }
});

// ../../node_modules/lodash.sortby/index.js
var require_lodash = __commonJS({
  "../../node_modules/lodash.sortby/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var UNORDERED_COMPARE_FLAG = 1;
    var PARTIAL_COMPARE_FLAG = 2;
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER2 = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args2) {
      switch (args2.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args2[0]);
        case 2:
          return func.call(thisArg, args2[0], args2[1]);
        case 3:
          return func.call(thisArg, args2[0], args2[1], args2[2]);
      }
      return func.apply(thisArg, args2);
    }
    function arrayMap(array2, iteratee) {
      var index = -1, length = array2 ? array2.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array2[index], index, array2);
      }
      return result;
    }
    function arrayPush(array2, values) {
      var index = -1, length = values.length, offset2 = array2.length;
      while (++index < length) {
        array2[offset2 + index] = values[index];
      }
      return array2;
    }
    function arraySome(array2, predicate) {
      var index = -1, length = array2 ? array2.length : 0;
      while (++index < length) {
        if (predicate(array2[index], index, array2)) {
          return true;
        }
      }
      return false;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    function baseSortBy(array2, comparer) {
      var length = array2.length;
      array2.sort(comparer);
      while (length--) {
        array2[length] = array2[length].value;
      }
      return array2;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeMax = Math.max;
    var DataView2 = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash2(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash2.prototype.clear = hashClear;
    Hash2.prototype["delete"] = hashDelete;
    Hash2.prototype.get = hashGet;
    Hash2.prototype.has = hashHas;
    Hash2.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash2(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash2()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array2, key) {
      var length = array2.length;
      while (length--) {
        if (eq(array2[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var baseEach = createBaseEach(baseForOwn);
    function baseFlatten(array2, depth, predicate, isStrict, result) {
      var index = -1, length = array2.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array2[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    function baseIsEqual(value, other, customizer, bitmask, stack2) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObject2(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack2);
    }
    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack2) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
      if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
      }
      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }
      var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
      if (isSameTag && !objIsObj) {
        stack2 || (stack2 = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack2) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack2);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack2 || (stack2 = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack2);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack2 || (stack2 = new Stack());
      return equalObjects(object, other, equalFunc, customizer, bitmask, stack2);
    }
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack2 = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack2);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack2) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function baseMap(collection, iteratee) {
      var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function(value, key, collection2) {
        result[++index] = iteratee(value, key, collection2);
      });
      return result;
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
      };
    }
    function baseOrderBy(collection, iteratees, orders) {
      var index = -1;
      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));
      var result = baseMap(collection, function(value, key, collection2) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { "criteria": criteria, "index": ++index, "value": value };
      });
      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    function baseRest(func, start) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args2 = arguments, index = -1, length = nativeMax(args2.length - start, 0), array2 = Array(length);
        while (++index < length) {
          array2[index] = args2[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args2[index];
        }
        otherArgs[start] = array2;
        return apply(func, this, otherArgs);
      };
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
        var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
          return 1;
        }
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }
    function compareMultiple(object, other, orders) {
      var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == "desc" ? -1 : 1);
        }
      }
      return object.index - other.index;
    }
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function equalArrays(array2, other, equalFunc, customizer, bitmask, stack2) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array2.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack2.get(array2);
      if (stacked && stack2.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
      stack2.set(array2, other);
      stack2.set(other, array2);
      while (++index < arrLength) {
        var arrValue = array2[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack2) : customizer(arrValue, othValue, index, array2, other, stack2);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack2))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack2))) {
          result = false;
          break;
        }
      }
      stack2["delete"](array2);
      stack2["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack2) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert2 = mapToArray;
        case setTag:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert2 || (convert2 = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack2.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= UNORDERED_COMPARE_FLAG;
          stack2.set(object, other);
          var result = equalArrays(convert2(object), convert2(other), equalFunc, customizer, bitmask, stack2);
          stack2["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, equalFunc, customizer, bitmask, stack2) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack2.get(object);
      if (stacked && stack2.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack2.set(object, other);
      stack2.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack2) : customizer(objValue, othValue, key, object, other, stack2);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack2) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack2["delete"](object);
      stack2["delete"](other);
      return result;
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function hasPath(object, path, hasFunc) {
      path = isKey(path, object) ? [path] : castPath(path);
      var result, index = -1, length = path.length;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result) {
        return result;
      }
      var length = object ? object.length : 0;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER2 : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject2(object)) {
        return false;
      }
      var type2 = typeof index;
      if (type2 == "number" ? isArrayLike(object) && isIndex(index, object.length) : type2 == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type2 = typeof value;
      if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type2 = typeof value;
      return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function isStrictComparable(value) {
      return value === value && !isObject2(value);
    }
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    var stringToPath = memoize(function(string2) {
      string2 = toString(string2);
      var result = [];
      if (reLeadingDot.test(string2)) {
        result.push("");
      }
      string2.replace(rePropName, function(match, number3, quote, string3) {
        result.push(quote ? string3.replace(reEscapeChar, "$1") : number3 || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args2 = arguments, key = resolver ? resolver.apply(this, args2) : args2[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args2);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject2(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
    }
    function isObject2(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function get(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function identity(value) {
      return value;
    }
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module.exports = sortBy;
  }
});

// node_modules/whatwg-url/lib/URLSearchParams-impl.js
var require_URLSearchParams_impl = __commonJS({
  "node_modules/whatwg-url/lib/URLSearchParams-impl.js"(exports) {
    "use strict";
    var stableSortBy = require_lodash();
    var urlencoded = require_urlencoded();
    exports.implementation = class URLSearchParamsImpl {
      constructor(constructorArgs, { doNotStripQMark = false }) {
        let init = constructorArgs[0];
        this._list = [];
        this._url = null;
        if (!doNotStripQMark && typeof init === "string" && init[0] === "?") {
          init = init.slice(1);
        }
        if (Array.isArray(init)) {
          for (const pair of init) {
            if (pair.length !== 2) {
              throw new TypeError("Failed to construct 'URLSearchParams': parameter 1 sequence's element does not contain exactly two elements.");
            }
            this._list.push([pair[0], pair[1]]);
          }
        } else if (typeof init === "object" && Object.getPrototypeOf(init) === null) {
          for (const name of Object.keys(init)) {
            const value = init[name];
            this._list.push([name, value]);
          }
        } else {
          this._list = urlencoded.parseUrlencoded(init);
        }
      }
      _updateSteps() {
        if (this._url !== null) {
          let query = urlencoded.serializeUrlencoded(this._list);
          if (query === "") {
            query = null;
          }
          this._url._url.query = query;
        }
      }
      append(name, value) {
        this._list.push([name, value]);
        this._updateSteps();
      }
      delete(name) {
        let i = 0;
        while (i < this._list.length) {
          if (this._list[i][0] === name) {
            this._list.splice(i, 1);
          } else {
            i++;
          }
        }
        this._updateSteps();
      }
      get(name) {
        for (const tuple2 of this._list) {
          if (tuple2[0] === name) {
            return tuple2[1];
          }
        }
        return null;
      }
      getAll(name) {
        const output2 = [];
        for (const tuple2 of this._list) {
          if (tuple2[0] === name) {
            output2.push(tuple2[1]);
          }
        }
        return output2;
      }
      has(name) {
        for (const tuple2 of this._list) {
          if (tuple2[0] === name) {
            return true;
          }
        }
        return false;
      }
      set(name, value) {
        let found = false;
        let i = 0;
        while (i < this._list.length) {
          if (this._list[i][0] === name) {
            if (found) {
              this._list.splice(i, 1);
            } else {
              found = true;
              this._list[i][1] = value;
              i++;
            }
          } else {
            i++;
          }
        }
        if (!found) {
          this._list.push([name, value]);
        }
        this._updateSteps();
      }
      sort() {
        this._list = stableSortBy(this._list, [0]);
        this._updateSteps();
      }
      [Symbol.iterator]() {
        return this._list[Symbol.iterator]();
      }
      toString() {
        return urlencoded.serializeUrlencoded(this._list);
      }
    };
  }
});

// node_modules/whatwg-url/lib/URLSearchParams.js
var require_URLSearchParams = __commonJS({
  "node_modules/whatwg-url/lib/URLSearchParams.js"(exports, module) {
    "use strict";
    var conversions = require_lib2();
    var utils3 = require_utils();
    var impl = utils3.implSymbol;
    var IteratorPrototype = Object.create(utils3.IteratorPrototype, {
      next: {
        value: function next() {
          const internal = this[utils3.iterInternalSymbol];
          const { target, kind, index } = internal;
          const values = Array.from(target[impl]);
          const len = values.length;
          if (index >= len) {
            return { value: void 0, done: true };
          }
          const pair = values[index];
          internal.index = index + 1;
          const [key, value] = pair.map(utils3.tryWrapperForImpl);
          let result;
          switch (kind) {
            case "key":
              result = key;
              break;
            case "value":
              result = value;
              break;
            case "key+value":
              result = [key, value];
              break;
          }
          return { value: result, done: false };
        },
        writable: true,
        enumerable: true,
        configurable: true
      },
      [Symbol.toStringTag]: {
        value: "URLSearchParams Iterator",
        configurable: true
      }
    });
    var URLSearchParams2 = class {
      constructor() {
        const args2 = [];
        {
          let curArg = arguments[0];
          if (curArg !== void 0) {
            if (utils3.isObject(curArg)) {
              if (curArg[Symbol.iterator] !== void 0) {
                if (!utils3.isObject(curArg)) {
                  throw new TypeError(
                    "Failed to construct 'URLSearchParams': parameter 1 sequence is not an iterable object."
                  );
                } else {
                  const V = [];
                  const tmp = curArg;
                  for (let nextItem of tmp) {
                    if (!utils3.isObject(nextItem)) {
                      throw new TypeError(
                        "Failed to construct 'URLSearchParams': parameter 1 sequence's element is not an iterable object."
                      );
                    } else {
                      const V2 = [];
                      const tmp2 = nextItem;
                      for (let nextItem2 of tmp2) {
                        nextItem2 = conversions["USVString"](nextItem2, {
                          context: "Failed to construct 'URLSearchParams': parameter 1 sequence's element's element"
                        });
                        V2.push(nextItem2);
                      }
                      nextItem = V2;
                    }
                    V.push(nextItem);
                  }
                  curArg = V;
                }
              } else {
                if (!utils3.isObject(curArg)) {
                  throw new TypeError(
                    "Failed to construct 'URLSearchParams': parameter 1 record is not an object."
                  );
                } else {
                  const result = /* @__PURE__ */ Object.create(null);
                  for (const key of Reflect.ownKeys(curArg)) {
                    const desc = Object.getOwnPropertyDescriptor(curArg, key);
                    if (desc && desc.enumerable) {
                      let typedKey = key;
                      let typedValue = curArg[key];
                      typedKey = conversions["USVString"](typedKey, {
                        context: "Failed to construct 'URLSearchParams': parameter 1 record's key"
                      });
                      typedValue = conversions["USVString"](typedValue, {
                        context: "Failed to construct 'URLSearchParams': parameter 1 record's value"
                      });
                      result[typedKey] = typedValue;
                    }
                  }
                  curArg = result;
                }
              }
            } else {
              curArg = conversions["USVString"](curArg, { context: "Failed to construct 'URLSearchParams': parameter 1" });
            }
          } else {
            curArg = "";
          }
          args2.push(curArg);
        }
        return iface.setup(Object.create(new.target.prototype), args2);
      }
      append(name, value) {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        if (arguments.length < 2) {
          throw new TypeError(
            "Failed to execute 'append' on 'URLSearchParams': 2 arguments required, but only " + arguments.length + " present."
          );
        }
        const args2 = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'append' on 'URLSearchParams': parameter 1"
          });
          args2.push(curArg);
        }
        {
          let curArg = arguments[1];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'append' on 'URLSearchParams': parameter 2"
          });
          args2.push(curArg);
        }
        return this[impl].append(...args2);
      }
      delete(name) {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        if (arguments.length < 1) {
          throw new TypeError(
            "Failed to execute 'delete' on 'URLSearchParams': 1 argument required, but only " + arguments.length + " present."
          );
        }
        const args2 = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'delete' on 'URLSearchParams': parameter 1"
          });
          args2.push(curArg);
        }
        return this[impl].delete(...args2);
      }
      get(name) {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        if (arguments.length < 1) {
          throw new TypeError(
            "Failed to execute 'get' on 'URLSearchParams': 1 argument required, but only " + arguments.length + " present."
          );
        }
        const args2 = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'get' on 'URLSearchParams': parameter 1"
          });
          args2.push(curArg);
        }
        return this[impl].get(...args2);
      }
      getAll(name) {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        if (arguments.length < 1) {
          throw new TypeError(
            "Failed to execute 'getAll' on 'URLSearchParams': 1 argument required, but only " + arguments.length + " present."
          );
        }
        const args2 = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'getAll' on 'URLSearchParams': parameter 1"
          });
          args2.push(curArg);
        }
        return utils3.tryWrapperForImpl(this[impl].getAll(...args2));
      }
      has(name) {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        if (arguments.length < 1) {
          throw new TypeError(
            "Failed to execute 'has' on 'URLSearchParams': 1 argument required, but only " + arguments.length + " present."
          );
        }
        const args2 = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'has' on 'URLSearchParams': parameter 1"
          });
          args2.push(curArg);
        }
        return this[impl].has(...args2);
      }
      set(name, value) {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        if (arguments.length < 2) {
          throw new TypeError(
            "Failed to execute 'set' on 'URLSearchParams': 2 arguments required, but only " + arguments.length + " present."
          );
        }
        const args2 = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'set' on 'URLSearchParams': parameter 1"
          });
          args2.push(curArg);
        }
        {
          let curArg = arguments[1];
          curArg = conversions["USVString"](curArg, {
            context: "Failed to execute 'set' on 'URLSearchParams': parameter 2"
          });
          args2.push(curArg);
        }
        return this[impl].set(...args2);
      }
      sort() {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        return this[impl].sort();
      }
      toString() {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        return this[impl].toString();
      }
      keys() {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        return module.exports.createDefaultIterator(this, "key");
      }
      values() {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        return module.exports.createDefaultIterator(this, "value");
      }
      entries() {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        return module.exports.createDefaultIterator(this, "key+value");
      }
      forEach(callback) {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        if (arguments.length < 1) {
          throw new TypeError("Failed to execute 'forEach' on 'iterable': 1 argument required, but only 0 present.");
        }
        if (typeof callback !== "function") {
          throw new TypeError(
            "Failed to execute 'forEach' on 'iterable': The callback provided as parameter 1 is not a function."
          );
        }
        const thisArg = arguments[1];
        let pairs = Array.from(this[impl]);
        let i = 0;
        while (i < pairs.length) {
          const [key, value] = pairs[i].map(utils3.tryWrapperForImpl);
          callback.call(thisArg, value, key, this);
          pairs = Array.from(this[impl]);
          i++;
        }
      }
    };
    Object.defineProperties(URLSearchParams2.prototype, {
      append: { enumerable: true },
      delete: { enumerable: true },
      get: { enumerable: true },
      getAll: { enumerable: true },
      has: { enumerable: true },
      set: { enumerable: true },
      sort: { enumerable: true },
      toString: { enumerable: true },
      keys: { enumerable: true },
      values: { enumerable: true },
      entries: { enumerable: true },
      forEach: { enumerable: true },
      [Symbol.toStringTag]: { value: "URLSearchParams", configurable: true },
      [Symbol.iterator]: { value: URLSearchParams2.prototype.entries, configurable: true, writable: true }
    });
    var iface = {
      // When an interface-module that implements this interface as a mixin is loaded, it will append its own `.is()`
      // method into this array. It allows objects that directly implements *those* interfaces to be recognized as
      // implementing this mixin interface.
      _mixedIntoPredicates: [],
      is(obj) {
        if (obj) {
          if (utils3.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation) {
            return true;
          }
          for (const isMixedInto of module.exports._mixedIntoPredicates) {
            if (isMixedInto(obj)) {
              return true;
            }
          }
        }
        return false;
      },
      isImpl(obj) {
        if (obj) {
          if (obj instanceof Impl.implementation) {
            return true;
          }
          const wrapper = utils3.wrapperForImpl(obj);
          for (const isMixedInto of module.exports._mixedIntoPredicates) {
            if (isMixedInto(wrapper)) {
              return true;
            }
          }
        }
        return false;
      },
      convert(obj, { context = "The provided value" } = {}) {
        if (module.exports.is(obj)) {
          return utils3.implForWrapper(obj);
        }
        throw new TypeError(`${context} is not of type 'URLSearchParams'.`);
      },
      createDefaultIterator(target, kind) {
        const iterator = Object.create(IteratorPrototype);
        Object.defineProperty(iterator, utils3.iterInternalSymbol, {
          value: { target, kind, index: 0 },
          configurable: true
        });
        return iterator;
      },
      create(constructorArgs, privateData) {
        let obj = Object.create(URLSearchParams2.prototype);
        obj = this.setup(obj, constructorArgs, privateData);
        return obj;
      },
      createImpl(constructorArgs, privateData) {
        let obj = Object.create(URLSearchParams2.prototype);
        obj = this.setup(obj, constructorArgs, privateData);
        return utils3.implForWrapper(obj);
      },
      _internalSetup(obj) {
      },
      setup(obj, constructorArgs, privateData) {
        if (!privateData)
          privateData = {};
        privateData.wrapper = obj;
        this._internalSetup(obj);
        Object.defineProperty(obj, impl, {
          value: new Impl.implementation(constructorArgs, privateData),
          configurable: true
        });
        obj[impl][utils3.wrapperSymbol] = obj;
        if (Impl.init) {
          Impl.init(obj[impl], privateData);
        }
        return obj;
      },
      interface: URLSearchParams2,
      expose: {
        Window: { URLSearchParams: URLSearchParams2 },
        Worker: { URLSearchParams: URLSearchParams2 }
      }
    };
    module.exports = iface;
    var Impl = require_URLSearchParams_impl();
  }
});

// node_modules/whatwg-url/lib/URL-impl.js
var require_URL_impl = __commonJS({
  "node_modules/whatwg-url/lib/URL-impl.js"(exports) {
    "use strict";
    var usm = require_url_state_machine();
    var urlencoded = require_urlencoded();
    var URLSearchParams2 = require_URLSearchParams();
    exports.implementation = class URLImpl {
      constructor(constructorArgs) {
        const url = constructorArgs[0];
        const base = constructorArgs[1];
        let parsedBase = null;
        if (base !== void 0) {
          parsedBase = usm.basicURLParse(base);
          if (parsedBase === null) {
            throw new TypeError(`Invalid base URL: ${base}`);
          }
        }
        const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
        if (parsedURL === null) {
          throw new TypeError(`Invalid URL: ${url}`);
        }
        const query = parsedURL.query !== null ? parsedURL.query : "";
        this._url = parsedURL;
        this._query = URLSearchParams2.createImpl([query], { doNotStripQMark: true });
        this._query._url = this;
      }
      get href() {
        return usm.serializeURL(this._url);
      }
      set href(v) {
        const parsedURL = usm.basicURLParse(v);
        if (parsedURL === null) {
          throw new TypeError(`Invalid URL: ${v}`);
        }
        this._url = parsedURL;
        this._query._list.splice(0);
        const { query } = parsedURL;
        if (query !== null) {
          this._query._list = urlencoded.parseUrlencoded(query);
        }
      }
      get origin() {
        return usm.serializeURLOrigin(this._url);
      }
      get protocol() {
        return this._url.scheme + ":";
      }
      set protocol(v) {
        usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
      }
      get username() {
        return this._url.username;
      }
      set username(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setTheUsername(this._url, v);
      }
      get password() {
        return this._url.password;
      }
      set password(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        usm.setThePassword(this._url, v);
      }
      get host() {
        const url = this._url;
        if (url.host === null) {
          return "";
        }
        if (url.port === null) {
          return usm.serializeHost(url.host);
        }
        return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
      }
      set host(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
      }
      get hostname() {
        if (this._url.host === null) {
          return "";
        }
        return usm.serializeHost(this._url.host);
      }
      set hostname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
      }
      get port() {
        if (this._url.port === null) {
          return "";
        }
        return usm.serializeInteger(this._url.port);
      }
      set port(v) {
        if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
          return;
        }
        if (v === "") {
          this._url.port = null;
        } else {
          usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
        }
      }
      get pathname() {
        if (this._url.cannotBeABaseURL) {
          return this._url.path[0];
        }
        if (this._url.path.length === 0) {
          return "";
        }
        return "/" + this._url.path.join("/");
      }
      set pathname(v) {
        if (this._url.cannotBeABaseURL) {
          return;
        }
        this._url.path = [];
        usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
      }
      get search() {
        if (this._url.query === null || this._url.query === "") {
          return "";
        }
        return "?" + this._url.query;
      }
      set search(v) {
        const url = this._url;
        if (v === "") {
          url.query = null;
          this._query._list = [];
          return;
        }
        const input = v[0] === "?" ? v.substring(1) : v;
        url.query = "";
        usm.basicURLParse(input, { url, stateOverride: "query" });
        this._query._list = urlencoded.parseUrlencoded(input);
      }
      get searchParams() {
        return this._query;
      }
      get hash() {
        if (this._url.fragment === null || this._url.fragment === "") {
          return "";
        }
        return "#" + this._url.fragment;
      }
      set hash(v) {
        if (v === "") {
          this._url.fragment = null;
          return;
        }
        const input = v[0] === "#" ? v.substring(1) : v;
        this._url.fragment = "";
        usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
      }
      toJSON() {
        return this.href;
      }
    };
  }
});

// node_modules/whatwg-url/lib/URL.js
var require_URL = __commonJS({
  "node_modules/whatwg-url/lib/URL.js"(exports, module) {
    "use strict";
    var conversions = require_lib2();
    var utils3 = require_utils();
    var impl = utils3.implSymbol;
    var URL3 = class {
      constructor(url) {
        if (arguments.length < 1) {
          throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
        }
        const args2 = [];
        {
          let curArg = arguments[0];
          curArg = conversions["USVString"](curArg, { context: "Failed to construct 'URL': parameter 1" });
          args2.push(curArg);
        }
        {
          let curArg = arguments[1];
          if (curArg !== void 0) {
            curArg = conversions["USVString"](curArg, { context: "Failed to construct 'URL': parameter 2" });
          }
          args2.push(curArg);
        }
        return iface.setup(Object.create(new.target.prototype), args2);
      }
      toJSON() {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        return this[impl].toJSON();
      }
      get href() {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        return this[impl]["href"];
      }
      set href(V) {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        V = conversions["USVString"](V, { context: "Failed to set the 'href' property on 'URL': The provided value" });
        this[impl]["href"] = V;
      }
      toString() {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        return this[impl]["href"];
      }
      get origin() {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        return this[impl]["origin"];
      }
      get protocol() {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        return this[impl]["protocol"];
      }
      set protocol(V) {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        V = conversions["USVString"](V, { context: "Failed to set the 'protocol' property on 'URL': The provided value" });
        this[impl]["protocol"] = V;
      }
      get username() {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        return this[impl]["username"];
      }
      set username(V) {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        V = conversions["USVString"](V, { context: "Failed to set the 'username' property on 'URL': The provided value" });
        this[impl]["username"] = V;
      }
      get password() {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        return this[impl]["password"];
      }
      set password(V) {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        V = conversions["USVString"](V, { context: "Failed to set the 'password' property on 'URL': The provided value" });
        this[impl]["password"] = V;
      }
      get host() {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        return this[impl]["host"];
      }
      set host(V) {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        V = conversions["USVString"](V, { context: "Failed to set the 'host' property on 'URL': The provided value" });
        this[impl]["host"] = V;
      }
      get hostname() {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        return this[impl]["hostname"];
      }
      set hostname(V) {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        V = conversions["USVString"](V, { context: "Failed to set the 'hostname' property on 'URL': The provided value" });
        this[impl]["hostname"] = V;
      }
      get port() {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        return this[impl]["port"];
      }
      set port(V) {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        V = conversions["USVString"](V, { context: "Failed to set the 'port' property on 'URL': The provided value" });
        this[impl]["port"] = V;
      }
      get pathname() {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        return this[impl]["pathname"];
      }
      set pathname(V) {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        V = conversions["USVString"](V, { context: "Failed to set the 'pathname' property on 'URL': The provided value" });
        this[impl]["pathname"] = V;
      }
      get search() {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        return this[impl]["search"];
      }
      set search(V) {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        V = conversions["USVString"](V, { context: "Failed to set the 'search' property on 'URL': The provided value" });
        this[impl]["search"] = V;
      }
      get searchParams() {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        return utils3.getSameObject(this, "searchParams", () => {
          return utils3.tryWrapperForImpl(this[impl]["searchParams"]);
        });
      }
      get hash() {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        return this[impl]["hash"];
      }
      set hash(V) {
        if (!this || !module.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        V = conversions["USVString"](V, { context: "Failed to set the 'hash' property on 'URL': The provided value" });
        this[impl]["hash"] = V;
      }
    };
    Object.defineProperties(URL3.prototype, {
      toJSON: { enumerable: true },
      href: { enumerable: true },
      toString: { enumerable: true },
      origin: { enumerable: true },
      protocol: { enumerable: true },
      username: { enumerable: true },
      password: { enumerable: true },
      host: { enumerable: true },
      hostname: { enumerable: true },
      port: { enumerable: true },
      pathname: { enumerable: true },
      search: { enumerable: true },
      searchParams: { enumerable: true },
      hash: { enumerable: true },
      [Symbol.toStringTag]: { value: "URL", configurable: true }
    });
    var iface = {
      // When an interface-module that implements this interface as a mixin is loaded, it will append its own `.is()`
      // method into this array. It allows objects that directly implements *those* interfaces to be recognized as
      // implementing this mixin interface.
      _mixedIntoPredicates: [],
      is(obj) {
        if (obj) {
          if (utils3.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation) {
            return true;
          }
          for (const isMixedInto of module.exports._mixedIntoPredicates) {
            if (isMixedInto(obj)) {
              return true;
            }
          }
        }
        return false;
      },
      isImpl(obj) {
        if (obj) {
          if (obj instanceof Impl.implementation) {
            return true;
          }
          const wrapper = utils3.wrapperForImpl(obj);
          for (const isMixedInto of module.exports._mixedIntoPredicates) {
            if (isMixedInto(wrapper)) {
              return true;
            }
          }
        }
        return false;
      },
      convert(obj, { context = "The provided value" } = {}) {
        if (module.exports.is(obj)) {
          return utils3.implForWrapper(obj);
        }
        throw new TypeError(`${context} is not of type 'URL'.`);
      },
      create(constructorArgs, privateData) {
        let obj = Object.create(URL3.prototype);
        obj = this.setup(obj, constructorArgs, privateData);
        return obj;
      },
      createImpl(constructorArgs, privateData) {
        let obj = Object.create(URL3.prototype);
        obj = this.setup(obj, constructorArgs, privateData);
        return utils3.implForWrapper(obj);
      },
      _internalSetup(obj) {
      },
      setup(obj, constructorArgs, privateData) {
        if (!privateData)
          privateData = {};
        privateData.wrapper = obj;
        this._internalSetup(obj);
        Object.defineProperty(obj, impl, {
          value: new Impl.implementation(constructorArgs, privateData),
          configurable: true
        });
        obj[impl][utils3.wrapperSymbol] = obj;
        if (Impl.init) {
          Impl.init(obj[impl], privateData);
        }
        return obj;
      },
      interface: URL3,
      expose: {
        Window: { URL: URL3 },
        Worker: { URL: URL3 }
      }
    };
    module.exports = iface;
    var Impl = require_URL_impl();
  }
});

// node_modules/whatwg-url/lib/public-api.js
var require_public_api = __commonJS({
  "node_modules/whatwg-url/lib/public-api.js"(exports) {
    "use strict";
    exports.URL = require_URL().interface;
    exports.URLSearchParams = require_URLSearchParams().interface;
    exports.parseURL = require_url_state_machine().parseURL;
    exports.basicURLParse = require_url_state_machine().basicURLParse;
    exports.serializeURL = require_url_state_machine().serializeURL;
    exports.serializeHost = require_url_state_machine().serializeHost;
    exports.serializeInteger = require_url_state_machine().serializeInteger;
    exports.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
    exports.setTheUsername = require_url_state_machine().setTheUsername;
    exports.setThePassword = require_url_state_machine().setThePassword;
    exports.cannotHaveAUsernamePasswordPort = require_url_state_machine().cannotHaveAUsernamePasswordPort;
    exports.percentDecode = require_urlencoded().percentDecode;
  }
});

// ../../node_modules/@babel/runtime/helpers/interopRequireDefault.js
var require_interopRequireDefault = __commonJS({
  "../../node_modules/@babel/runtime/helpers/interopRequireDefault.js"(exports, module) {
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }
    module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "../../node_modules/@babel/runtime/helpers/typeof.js"(exports, module) {
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(obj);
    }
    module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/regeneratorRuntime.js
var require_regeneratorRuntime = __commonJS({
  "../../node_modules/@babel/runtime/helpers/regeneratorRuntime.js"(exports, module) {
    var _typeof = require_typeof()["default"];
    function _regeneratorRuntime() {
      "use strict";
      module.exports = _regeneratorRuntime = function _regeneratorRuntime2() {
        return exports2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      var exports2 = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
        obj[key] = desc.value;
      }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define2(obj, key, value) {
        return Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        }), obj[key];
      }
      try {
        define2({}, "");
      } catch (err) {
        define2 = function define3(obj, key, value) {
          return obj[key] = value;
        };
      }
      function wrap(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
        return defineProperty(generator, "_invoke", {
          value: makeInvokeMethod(innerFn, self2, context)
        }), generator;
      }
      function tryCatch(fn2, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn2.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }
      exports2.wrap = wrap;
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      define2(IteratorPrototype, iteratorSymbol, function() {
        return this;
      });
      var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          define2(prototype, method, function(arg) {
            return this._invoke(method, arg);
          });
        });
      }
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record2 = tryCatch(generator[method], generator, arg);
          if ("throw" !== record2.type) {
            var result = record2.arg, value = result.value;
            return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
              invoke("next", value2, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            }) : PromiseImpl.resolve(value).then(function(unwrapped) {
              result.value = unwrapped, resolve(result);
            }, function(error) {
              return invoke("throw", error, resolve, reject);
            });
          }
          reject(record2.arg);
        }
        var previousPromise;
        defineProperty(this, "_invoke", {
          value: function value(method, arg) {
            function callInvokeWithMethodAndArg() {
              return new PromiseImpl(function(resolve, reject) {
                invoke(method, arg, resolve, reject);
              });
            }
            return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
        });
      }
      function makeInvokeMethod(innerFn, self2, context) {
        var state = "suspendedStart";
        return function(method, arg) {
          if ("executing" === state)
            throw new Error("Generator is already running");
          if ("completed" === state) {
            if ("throw" === method)
              throw arg;
            return doneResult();
          }
          for (context.method = method, context.arg = arg; ; ) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel)
                  continue;
                return delegateResult;
              }
            }
            if ("next" === context.method)
              context.sent = context._sent = context.arg;
            else if ("throw" === context.method) {
              if ("suspendedStart" === state)
                throw state = "completed", context.arg;
              context.dispatchException(context.arg);
            } else
              "return" === context.method && context.abrupt("return", context.arg);
            state = "executing";
            var record2 = tryCatch(innerFn, self2, context);
            if ("normal" === record2.type) {
              if (state = context.done ? "completed" : "suspendedYield", record2.arg === ContinueSentinel)
                continue;
              return {
                value: record2.arg,
                done: context.done
              };
            }
            "throw" === record2.type && (state = "completed", context.method = "throw", context.arg = record2.arg);
          }
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var methodName = context.method, method = delegate.iterator[methodName];
        if (void 0 === method)
          return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
        var record2 = tryCatch(method, delegate.iterator, context.arg);
        if ("throw" === record2.type)
          return context.method = "throw", context.arg = record2.arg, context.delegate = null, ContinueSentinel;
        var info = record2.arg;
        return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
      }
      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record2 = entry.completion || {};
        record2.type = "normal", delete record2.arg, entry.completion = record2;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{
          tryLoc: "root"
        }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod)
            return iteratorMethod.call(iterable);
          if ("function" == typeof iterable.next)
            return iterable;
          if (!isNaN(iterable.length)) {
            var i = -1, next = function next2() {
              for (; ++i < iterable.length; )
                if (hasOwn.call(iterable, i))
                  return next2.value = iterable[i], next2.done = false, next2;
              return next2.value = void 0, next2.done = true, next2;
            };
            return next.next = next;
          }
        }
        return {
          next: doneResult
        };
      }
      function doneResult() {
        return {
          value: void 0,
          done: true
        };
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: true
      }), defineProperty(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: true
      }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports2.isGeneratorFunction = function(genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
      }, exports2.mark = function(genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define2(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
      }, exports2.awrap = function(arg) {
        return {
          __await: arg
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
      }), exports2.AsyncIterator = AsyncIterator, exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
        return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      }, defineIteratorMethods(Gp), define2(Gp, toStringTagSymbol, "Generator"), define2(Gp, iteratorSymbol, function() {
        return this;
      }), define2(Gp, "toString", function() {
        return "[object Generator]";
      }), exports2.keys = function(val) {
        var object = Object(val), keys = [];
        for (var key in object)
          keys.push(key);
        return keys.reverse(), function next() {
          for (; keys.length; ) {
            var key2 = keys.pop();
            if (key2 in object)
              return next.value = key2, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, exports2.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
            for (var name in this)
              "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
        },
        stop: function stop() {
          this.done = true;
          var rootRecord = this.tryEntries[0].completion;
          if ("throw" === rootRecord.type)
            throw rootRecord.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done)
            throw exception;
          var context = this;
          function handle(loc, caught) {
            return record2.type = "throw", record2.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
          }
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i], record2 = entry.completion;
            if ("root" === entry.tryLoc)
              return handle("end");
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc)
                  return handle(entry.catchLoc, true);
                if (this.prev < entry.finallyLoc)
                  return handle(entry.finallyLoc);
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc)
                  return handle(entry.catchLoc, true);
              } else {
                if (!hasFinally)
                  throw new Error("try statement without catch or finally");
                if (this.prev < entry.finallyLoc)
                  return handle(entry.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(type2, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          finallyEntry && ("break" === type2 || "continue" === type2) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
          var record2 = finallyEntry ? finallyEntry.completion : {};
          return record2.type = type2, record2.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record2);
        },
        complete: function complete(record2, afterLoc) {
          if ("throw" === record2.type)
            throw record2.arg;
          return "break" === record2.type || "continue" === record2.type ? this.next = record2.arg : "return" === record2.type ? (this.rval = this.arg = record2.arg, this.method = "return", this.next = "end") : "normal" === record2.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc)
              return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record2 = entry.completion;
              if ("throw" === record2.type) {
                var thrown = record2.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          return this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc
          }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
        }
      }, exports2;
    }
    module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../../node_modules/@babel/runtime/regenerator/index.js
var require_regenerator = __commonJS({
  "../../node_modules/@babel/runtime/regenerator/index.js"(exports, module) {
    var runtime = require_regeneratorRuntime()();
    module.exports = runtime;
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// ../../node_modules/@babel/runtime/helpers/asyncToGenerator.js
var require_asyncToGenerator = __commonJS({
  "../../node_modules/@babel/runtime/helpers/asyncToGenerator.js"(exports, module) {
    function asyncGeneratorStep(gen2, resolve, reject, _next, _throw, key, arg) {
      try {
        var info = gen2[key](arg);
        var value = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn2) {
      return function() {
        var self2 = this, args2 = arguments;
        return new Promise(function(resolve, reject) {
          var gen2 = fn2.apply(self2, args2);
          function _next(value) {
            asyncGeneratorStep(gen2, resolve, reject, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen2, resolve, reject, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/classCallCheck.js
var require_classCallCheck = __commonJS({
  "../../node_modules/@babel/runtime/helpers/classCallCheck.js"(exports, module) {
    function _classCallCheck(instance2, Constructor) {
      if (!(instance2 instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/toPrimitive.js
var require_toPrimitive = __commonJS({
  "../../node_modules/@babel/runtime/helpers/toPrimitive.js"(exports, module) {
    var _typeof = require_typeof()["default"];
    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    module.exports = _toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/toPropertyKey.js
var require_toPropertyKey = __commonJS({
  "../../node_modules/@babel/runtime/helpers/toPropertyKey.js"(exports, module) {
    var _typeof = require_typeof()["default"];
    var toPrimitive = require_toPrimitive();
    function _toPropertyKey(arg) {
      var key = toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }
    module.exports = _toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/createClass.js
var require_createClass = __commonJS({
  "../../node_modules/@babel/runtime/helpers/createClass.js"(exports, module) {
    var toPropertyKey = require_toPropertyKey();
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/setPrototypeOf.js
var require_setPrototypeOf = __commonJS({
  "../../node_modules/@babel/runtime/helpers/setPrototypeOf.js"(exports, module) {
    function _setPrototypeOf(o, p) {
      module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      return _setPrototypeOf(o, p);
    }
    module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/inherits.js
var require_inherits = __commonJS({
  "../../node_modules/@babel/runtime/helpers/inherits.js"(exports, module) {
    var setPrototypeOf = require_setPrototypeOf();
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperty(subClass, "prototype", {
        writable: false
      });
      if (superClass)
        setPrototypeOf(subClass, superClass);
    }
    module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/assertThisInitialized.js
var require_assertThisInitialized = __commonJS({
  "../../node_modules/@babel/runtime/helpers/assertThisInitialized.js"(exports, module) {
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
var require_possibleConstructorReturn = __commonJS({
  "../../node_modules/@babel/runtime/helpers/possibleConstructorReturn.js"(exports, module) {
    var _typeof = require_typeof()["default"];
    var assertThisInitialized = require_assertThisInitialized();
    function _possibleConstructorReturn(self2, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return assertThisInitialized(self2);
    }
    module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../../node_modules/@babel/runtime/helpers/getPrototypeOf.js
var require_getPrototypeOf = __commonJS({
  "../../node_modules/@babel/runtime/helpers/getPrototypeOf.js"(exports, module) {
    function _getPrototypeOf(o) {
      module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      return _getPrototypeOf(o);
    }
    module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// ../../node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "../../node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn2, context, once) {
      this.fn = fn2;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn2, context, once) {
      if (typeof fn2 !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn2, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args2, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args2 = new Array(len - 1); i < len; i++) {
          args2[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args2);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args2)
                for (j = 1, args2 = new Array(len - 1); j < len; j++) {
                  args2[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args2);
          }
        }
      }
      return true;
    };
    EventEmitter.prototype.on = function on(event, fn2, context) {
      return addListener(this, event, fn2, context, false);
    };
    EventEmitter.prototype.once = function once(event, fn2, context) {
      return addListener(this, event, fn2, context, true);
    };
    EventEmitter.prototype.removeListener = function removeListener(event, fn2, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn2) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn2 && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn2 || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prefixed = prefix;
    EventEmitter.EventEmitter = EventEmitter;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter;
    }
  }
});

// ../../node_modules/rpc-websockets/dist/lib/client.js
var require_client = __commonJS({
  "../../node_modules/rpc-websockets/dist/lib/client.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _eventemitter = require_eventemitter3();
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2["default"])(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2["default"])(this, result);
      };
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    var __rest = function(s2, e) {
      var t = {};
      for (var p in s2) {
        if (Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0)
          t[p] = s2[p];
      }
      if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s2); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]))
            t[p[i]] = s2[p[i]];
        }
      return t;
    };
    var CommonClient = /* @__PURE__ */ function(_EventEmitter) {
      (0, _inherits2["default"])(CommonClient2, _EventEmitter);
      var _super = _createSuper(CommonClient2);
      function CommonClient2(webSocketFactory) {
        var _this;
        var address = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "ws://localhost:8080";
        var _a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var generate_request_id = arguments.length > 3 ? arguments[3] : void 0;
        (0, _classCallCheck2["default"])(this, CommonClient2);
        var _a$autoconnect = _a.autoconnect, autoconnect = _a$autoconnect === void 0 ? true : _a$autoconnect, _a$reconnect = _a.reconnect, reconnect = _a$reconnect === void 0 ? true : _a$reconnect, _a$reconnect_interval = _a.reconnect_interval, reconnect_interval = _a$reconnect_interval === void 0 ? 1e3 : _a$reconnect_interval, _a$max_reconnects = _a.max_reconnects, max_reconnects = _a$max_reconnects === void 0 ? 5 : _a$max_reconnects, rest_options = __rest(_a, ["autoconnect", "reconnect", "reconnect_interval", "max_reconnects"]);
        _this = _super.call(this);
        _this.webSocketFactory = webSocketFactory;
        _this.queue = {};
        _this.rpc_id = 0;
        _this.address = address;
        _this.autoconnect = autoconnect;
        _this.ready = false;
        _this.reconnect = reconnect;
        _this.reconnect_timer_id = void 0;
        _this.reconnect_interval = reconnect_interval;
        _this.max_reconnects = max_reconnects;
        _this.rest_options = rest_options;
        _this.current_reconnects = 0;
        _this.generate_request_id = generate_request_id || function() {
          return ++_this.rpc_id;
        };
        if (_this.autoconnect)
          _this._connect(_this.address, Object.assign({
            autoconnect: _this.autoconnect,
            reconnect: _this.reconnect,
            reconnect_interval: _this.reconnect_interval,
            max_reconnects: _this.max_reconnects
          }, _this.rest_options));
        return _this;
      }
      (0, _createClass2["default"])(CommonClient2, [{
        key: "connect",
        value: function connect() {
          if (this.socket)
            return;
          this._connect(this.address, Object.assign({
            autoconnect: this.autoconnect,
            reconnect: this.reconnect,
            reconnect_interval: this.reconnect_interval,
            max_reconnects: this.max_reconnects
          }, this.rest_options));
        }
        /**
         * Calls a registered RPC method on server.
         * @method
         * @param {String} method - RPC method name
         * @param {Object|Array} params - optional method parameters
         * @param {Number} timeout - RPC reply timeout value
         * @param {Object} ws_opts - options passed to ws
         * @return {Promise}
         */
      }, {
        key: "call",
        value: function call(method, params, timeout, ws_opts) {
          var _this2 = this;
          if (!ws_opts && "object" === (0, _typeof2["default"])(timeout)) {
            ws_opts = timeout;
            timeout = null;
          }
          return new Promise(function(resolve, reject) {
            if (!_this2.ready)
              return reject(new Error("socket not ready"));
            var rpc_id = _this2.generate_request_id(method, params);
            var message2 = {
              jsonrpc: "2.0",
              method,
              params: params || null,
              id: rpc_id
            };
            _this2.socket.send(JSON.stringify(message2), ws_opts, function(error) {
              if (error)
                return reject(error);
              _this2.queue[rpc_id] = {
                promise: [resolve, reject]
              };
              if (timeout) {
                _this2.queue[rpc_id].timeout = setTimeout(function() {
                  delete _this2.queue[rpc_id];
                  reject(new Error("reply timeout"));
                }, timeout);
              }
            });
          });
        }
        /**
         * Logins with the other side of the connection.
         * @method
         * @param {Object} params - Login credentials object
         * @return {Promise}
         */
      }, {
        key: "login",
        value: function() {
          var _login = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee(params) {
            var resp;
            return _regenerator["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return this.call("rpc.login", params);
                  case 2:
                    resp = _context.sent;
                    if (resp) {
                      _context.next = 5;
                      break;
                    }
                    throw new Error("authentication failed");
                  case 5:
                    return _context.abrupt("return", resp);
                  case 6:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
          function login(_x) {
            return _login.apply(this, arguments);
          }
          return login;
        }()
        /**
         * Fetches a list of client's methods registered on server.
         * @method
         * @return {Array}
         */
      }, {
        key: "listMethods",
        value: function() {
          var _listMethods = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee2() {
            return _regenerator["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return this.call("__listMethods");
                  case 2:
                    return _context2.abrupt("return", _context2.sent);
                  case 3:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));
          function listMethods() {
            return _listMethods.apply(this, arguments);
          }
          return listMethods;
        }()
        /**
         * Sends a JSON-RPC 2.0 notification to server.
         * @method
         * @param {String} method - RPC method name
         * @param {Object} params - optional method parameters
         * @return {Promise}
         */
      }, {
        key: "notify",
        value: function notify(method, params) {
          var _this3 = this;
          return new Promise(function(resolve, reject) {
            if (!_this3.ready)
              return reject(new Error("socket not ready"));
            var message2 = {
              jsonrpc: "2.0",
              method,
              params: params || null
            };
            _this3.socket.send(JSON.stringify(message2), function(error) {
              if (error)
                return reject(error);
              resolve();
            });
          });
        }
        /**
         * Subscribes for a defined event.
         * @method
         * @param {String|Array} event - event name
         * @return {Undefined}
         * @throws {Error}
         */
      }, {
        key: "subscribe",
        value: function() {
          var _subscribe = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee3(event) {
            var result;
            return _regenerator["default"].wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    if (typeof event === "string")
                      event = [event];
                    _context3.next = 3;
                    return this.call("rpc.on", event);
                  case 3:
                    result = _context3.sent;
                    if (!(typeof event === "string" && result[event] !== "ok")) {
                      _context3.next = 6;
                      break;
                    }
                    throw new Error("Failed subscribing to an event '" + event + "' with: " + result[event]);
                  case 6:
                    return _context3.abrupt("return", result);
                  case 7:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));
          function subscribe(_x2) {
            return _subscribe.apply(this, arguments);
          }
          return subscribe;
        }()
        /**
         * Unsubscribes from a defined event.
         * @method
         * @param {String|Array} event - event name
         * @return {Undefined}
         * @throws {Error}
         */
      }, {
        key: "unsubscribe",
        value: function() {
          var _unsubscribe = (0, _asyncToGenerator2["default"])(/* @__PURE__ */ _regenerator["default"].mark(function _callee4(event) {
            var result;
            return _regenerator["default"].wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (typeof event === "string")
                      event = [event];
                    _context4.next = 3;
                    return this.call("rpc.off", event);
                  case 3:
                    result = _context4.sent;
                    if (!(typeof event === "string" && result[event] !== "ok")) {
                      _context4.next = 6;
                      break;
                    }
                    throw new Error("Failed unsubscribing from an event with: " + result);
                  case 6:
                    return _context4.abrupt("return", result);
                  case 7:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));
          function unsubscribe(_x3) {
            return _unsubscribe.apply(this, arguments);
          }
          return unsubscribe;
        }()
        /**
         * Closes a WebSocket connection gracefully.
         * @method
         * @param {Number} code - socket close code
         * @param {String} data - optional data to be sent before closing
         * @return {Undefined}
         */
      }, {
        key: "close",
        value: function close(code, data) {
          this.socket.close(code || 1e3, data);
        }
        /**
         * Connection/Message handler.
         * @method
         * @private
         * @param {String} address - WebSocket API address
         * @param {Object} options - ws options object
         * @return {Undefined}
         */
      }, {
        key: "_connect",
        value: function _connect(address, options) {
          var _this4 = this;
          clearTimeout(this.reconnect_timer_id);
          this.socket = this.webSocketFactory(address, options);
          this.socket.addEventListener("open", function() {
            _this4.ready = true;
            _this4.emit("open");
            _this4.current_reconnects = 0;
          });
          this.socket.addEventListener("message", function(_ref) {
            var message2 = _ref.data;
            if (message2 instanceof ArrayBuffer)
              message2 = Buffer.from(message2).toString();
            try {
              message2 = JSON.parse(message2);
            } catch (error) {
              return;
            }
            if (message2.notification && _this4.listeners(message2.notification).length) {
              if (!Object.keys(message2.params).length)
                return _this4.emit(message2.notification);
              var args2 = [message2.notification];
              if (message2.params.constructor === Object)
                args2.push(message2.params);
              else
                for (var i = 0; i < message2.params.length; i++) {
                  args2.push(message2.params[i]);
                }
              return Promise.resolve().then(function() {
                _this4.emit.apply(_this4, args2);
              });
            }
            if (!_this4.queue[message2.id]) {
              if (message2.method && message2.params) {
                return Promise.resolve().then(function() {
                  _this4.emit(message2.method, message2.params);
                });
              }
              return;
            }
            if ("error" in message2 === "result" in message2)
              _this4.queue[message2.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.'));
            if (_this4.queue[message2.id].timeout)
              clearTimeout(_this4.queue[message2.id].timeout);
            if (message2.error)
              _this4.queue[message2.id].promise[1](message2.error);
            else
              _this4.queue[message2.id].promise[0](message2.result);
            delete _this4.queue[message2.id];
          });
          this.socket.addEventListener("error", function(error) {
            return _this4.emit("error", error);
          });
          this.socket.addEventListener("close", function(_ref2) {
            var code = _ref2.code, reason = _ref2.reason;
            if (_this4.ready)
              setTimeout(function() {
                return _this4.emit("close", code, reason);
              }, 0);
            _this4.ready = false;
            _this4.socket = void 0;
            if (code === 1e3)
              return;
            _this4.current_reconnects++;
            if (_this4.reconnect && (_this4.max_reconnects > _this4.current_reconnects || _this4.max_reconnects === 0))
              _this4.reconnect_timer_id = setTimeout(function() {
                return _this4._connect(address, options);
              }, _this4.reconnect_interval);
          });
        }
      }]);
      return CommonClient2;
    }(_eventemitter.EventEmitter);
    exports["default"] = CommonClient;
  }
});

// ../../node_modules/rpc-websockets/node_modules/ws/lib/constants.js
var require_constants = __commonJS({
  "../../node_modules/rpc-websockets/node_modules/ws/lib/constants.js"(exports, module) {
    "use strict";
    module.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
  }
});

// ../../node_modules/node-gyp-build/node-gyp-build.js
var require_node_gyp_build = __commonJS({
  "../../node_modules/node-gyp-build/node-gyp-build.js"(exports, module) {
    var fs = __require("fs");
    var path = __require("path");
    var os = __require("os");
    var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : __require;
    var vars = process.config && process.config.variables || {};
    var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
    var abi = process.versions.modules;
    var runtime = isElectron() ? "electron" : isNwjs() ? "node-webkit" : "node";
    var arch = process.env.npm_config_arch || os.arch();
    var platform = process.env.npm_config_platform || os.platform();
    var libc = process.env.LIBC || (isAlpine(platform) ? "musl" : "glibc");
    var armv = process.env.ARM_VERSION || (arch === "arm64" ? "8" : vars.arm_version) || "";
    var uv = (process.versions.uv || "").split(".")[0];
    module.exports = load;
    function load(dir) {
      return runtimeRequire(load.resolve(dir));
    }
    load.resolve = load.path = function(dir) {
      dir = path.resolve(dir || ".");
      try {
        var name = runtimeRequire(path.join(dir, "package.json")).name.toUpperCase().replace(/-/g, "_");
        if (process.env[name + "_PREBUILD"])
          dir = process.env[name + "_PREBUILD"];
      } catch (err) {
      }
      if (!prebuildsOnly) {
        var release = getFirst(path.join(dir, "build/Release"), matchBuild);
        if (release)
          return release;
        var debug2 = getFirst(path.join(dir, "build/Debug"), matchBuild);
        if (debug2)
          return debug2;
      }
      var prebuild = resolve(dir);
      if (prebuild)
        return prebuild;
      var nearby = resolve(path.dirname(process.execPath));
      if (nearby)
        return nearby;
      var target = [
        "platform=" + platform,
        "arch=" + arch,
        "runtime=" + runtime,
        "abi=" + abi,
        "uv=" + uv,
        armv ? "armv=" + armv : "",
        "libc=" + libc,
        "node=" + process.versions.node,
        process.versions.electron ? "electron=" + process.versions.electron : "",
        typeof __webpack_require__ === "function" ? "webpack=true" : ""
        // eslint-disable-line
      ].filter(Boolean).join(" ");
      throw new Error("No native build was found for " + target + "\n    loaded from: " + dir + "\n");
      function resolve(dir2) {
        var tuples = readdirSync(path.join(dir2, "prebuilds")).map(parseTuple);
        var tuple2 = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
        if (!tuple2)
          return;
        var prebuilds = path.join(dir2, "prebuilds", tuple2.name);
        var parsed = readdirSync(prebuilds).map(parseTags);
        var candidates = parsed.filter(matchTags(runtime, abi));
        var winner = candidates.sort(compareTags(runtime))[0];
        if (winner)
          return path.join(prebuilds, winner.file);
      }
    };
    function readdirSync(dir) {
      try {
        return fs.readdirSync(dir);
      } catch (err) {
        return [];
      }
    }
    function getFirst(dir, filter) {
      var files = readdirSync(dir).filter(filter);
      return files[0] && path.join(dir, files[0]);
    }
    function matchBuild(name) {
      return /\.node$/.test(name);
    }
    function parseTuple(name) {
      var arr = name.split("-");
      if (arr.length !== 2)
        return;
      var platform2 = arr[0];
      var architectures = arr[1].split("+");
      if (!platform2)
        return;
      if (!architectures.length)
        return;
      if (!architectures.every(Boolean))
        return;
      return { name, platform: platform2, architectures };
    }
    function matchTuple(platform2, arch2) {
      return function(tuple2) {
        if (tuple2 == null)
          return false;
        if (tuple2.platform !== platform2)
          return false;
        return tuple2.architectures.includes(arch2);
      };
    }
    function compareTuples(a, b) {
      return a.architectures.length - b.architectures.length;
    }
    function parseTags(file) {
      var arr = file.split(".");
      var extension = arr.pop();
      var tags = { file, specificity: 0 };
      if (extension !== "node")
        return;
      for (var i = 0; i < arr.length; i++) {
        var tag = arr[i];
        if (tag === "node" || tag === "electron" || tag === "node-webkit") {
          tags.runtime = tag;
        } else if (tag === "napi") {
          tags.napi = true;
        } else if (tag.slice(0, 3) === "abi") {
          tags.abi = tag.slice(3);
        } else if (tag.slice(0, 2) === "uv") {
          tags.uv = tag.slice(2);
        } else if (tag.slice(0, 4) === "armv") {
          tags.armv = tag.slice(4);
        } else if (tag === "glibc" || tag === "musl") {
          tags.libc = tag;
        } else {
          continue;
        }
        tags.specificity++;
      }
      return tags;
    }
    function matchTags(runtime2, abi2) {
      return function(tags) {
        if (tags == null)
          return false;
        if (tags.runtime !== runtime2 && !runtimeAgnostic(tags))
          return false;
        if (tags.abi !== abi2 && !tags.napi)
          return false;
        if (tags.uv && tags.uv !== uv)
          return false;
        if (tags.armv && tags.armv !== armv)
          return false;
        if (tags.libc && tags.libc !== libc)
          return false;
        return true;
      };
    }
    function runtimeAgnostic(tags) {
      return tags.runtime === "node" && tags.napi;
    }
    function compareTags(runtime2) {
      return function(a, b) {
        if (a.runtime !== b.runtime) {
          return a.runtime === runtime2 ? -1 : 1;
        } else if (a.abi !== b.abi) {
          return a.abi ? -1 : 1;
        } else if (a.specificity !== b.specificity) {
          return a.specificity > b.specificity ? -1 : 1;
        } else {
          return 0;
        }
      };
    }
    function isNwjs() {
      return !!(process.versions && process.versions.nw);
    }
    function isElectron() {
      if (process.versions && process.versions.electron)
        return true;
      if (process.env.ELECTRON_RUN_AS_NODE)
        return true;
      return typeof window !== "undefined" && window.process && window.process.type === "renderer";
    }
    function isAlpine(platform2) {
      return platform2 === "linux" && fs.existsSync("/etc/alpine-release");
    }
    load.parseTags = parseTags;
    load.matchTags = matchTags;
    load.compareTags = compareTags;
    load.parseTuple = parseTuple;
    load.matchTuple = matchTuple;
    load.compareTuples = compareTuples;
  }
});

// ../../node_modules/node-gyp-build/index.js
var require_node_gyp_build2 = __commonJS({
  "../../node_modules/node-gyp-build/index.js"(exports, module) {
    if (typeof process.addon === "function") {
      module.exports = process.addon.bind(process);
    } else {
      module.exports = require_node_gyp_build();
    }
  }
});

// ../../node_modules/bufferutil/fallback.js
var require_fallback = __commonJS({
  "../../node_modules/bufferutil/fallback.js"(exports, module) {
    "use strict";
    var mask2 = (source, mask3, output2, offset2, length) => {
      for (var i = 0; i < length; i++) {
        output2[offset2 + i] = source[i] ^ mask3[i & 3];
      }
    };
    var unmask = (buffer, mask3) => {
      const length = buffer.length;
      for (var i = 0; i < length; i++) {
        buffer[i] ^= mask3[i & 3];
      }
    };
    module.exports = { mask: mask2, unmask };
  }
});

// ../../node_modules/bufferutil/index.js
var require_bufferutil = __commonJS({
  "../../node_modules/bufferutil/index.js"(exports, module) {
    "use strict";
    try {
      module.exports = require_node_gyp_build2()(__dirname);
    } catch (e) {
      module.exports = require_fallback();
    }
  }
});

// ../../node_modules/rpc-websockets/node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "../../node_modules/rpc-websockets/node_modules/ws/lib/buffer-util.js"(exports, module) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    function concat(list, totalLength) {
      if (list.length === 0)
        return EMPTY_BUFFER;
      if (list.length === 1)
        return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset2 = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset2);
        offset2 += buf.length;
      }
      if (offset2 < totalLength) {
        return new FastBuffer(target.buffer, target.byteOffset, offset2);
      }
      return target;
    }
    function _mask(source, mask2, output2, offset2, length) {
      for (let i = 0; i < length; i++) {
        output2[offset2 + i] = source[i] ^ mask2[i & 3];
      }
    }
    function _unmask(buffer, mask2) {
      for (let i = 0; i < buffer.length; i++) {
        buffer[i] ^= mask2[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.length === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
    }
    function toBuffer2(data) {
      toBuffer2.readOnly = true;
      if (Buffer.isBuffer(data))
        return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = new FastBuffer(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer2.readOnly = false;
      }
      return buf;
    }
    module.exports = {
      concat,
      mask: _mask,
      toArrayBuffer,
      toBuffer: toBuffer2,
      unmask: _unmask
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil = require_bufferutil();
        module.exports.mask = function(source, mask2, output2, offset2, length) {
          if (length < 48)
            _mask(source, mask2, output2, offset2, length);
          else
            bufferUtil.mask(source, mask2, output2, offset2, length);
        };
        module.exports.unmask = function(buffer, mask2) {
          if (buffer.length < 32)
            _unmask(buffer, mask2);
          else
            bufferUtil.unmask(buffer, mask2);
        };
      } catch (e) {
      }
    }
  }
});

// ../../node_modules/rpc-websockets/node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "../../node_modules/rpc-websockets/node_modules/ws/lib/limiter.js"(exports, module) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module.exports = Limiter;
  }
});

// ../../node_modules/rpc-websockets/node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "../../node_modules/rpc-websockets/node_modules/ws/lib/permessage-deflate.js"(exports, module) {
    "use strict";
    var zlib2 = __require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed if context takeover is disabled
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data, fin, callback) {
        const endpoint2 = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint2}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib2.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib2.createInflateRaw(__spreadProps(__spreadValues({}, this._options.zlibInflateOptions), {
            windowBits
          }));
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint2}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data, fin, callback) {
        const endpoint2 = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint2}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib2.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib2.createDeflateRaw(__spreadProps(__spreadValues({}, this._options.zlibDeflateOptions), {
            windowBits
          }));
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib2.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin) {
            data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
          }
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint2}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// ../../node_modules/utf-8-validate/fallback.js
var require_fallback2 = __commonJS({
  "../../node_modules/utf-8-validate/fallback.js"(exports, module) {
    "use strict";
    function isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // overlong
          buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // overlong
          buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    module.exports = isValidUTF8;
  }
});

// ../../node_modules/utf-8-validate/index.js
var require_utf_8_validate = __commonJS({
  "../../node_modules/utf-8-validate/index.js"(exports, module) {
    "use strict";
    try {
      module.exports = require_node_gyp_build2()(__dirname);
    } catch (e) {
      module.exports = require_fallback2();
    }
  }
});

// ../../node_modules/rpc-websockets/node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "../../node_modules/rpc-websockets/node_modules/ws/lib/validation.js"(exports, module) {
    "use strict";
    var { isUtf8 } = __require("buffer");
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong
          buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong
          buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    module.exports = {
      isValidStatusCode,
      isValidUTF8: _isValidUTF8,
      tokenChars
    };
    if (isUtf8) {
      module.exports.isValidUTF8 = function(buf) {
        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
      };
    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF8 = require_utf_8_validate();
        module.exports.isValidUTF8 = function(buf) {
          return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
        };
      } catch (e) {
      }
    }
  }
});

// ../../node_modules/rpc-websockets/node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "../../node_modules/rpc-websockets/node_modules/ws/lib/receiver.js"(exports, module) {
    "use strict";
    var { Writable } = __require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var FastBuffer = Buffer[Symbol.species];
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver = class extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {Object} [options] Options object
       * @param {String} [options.binaryType=nodebuffer] The type for binary data
       * @param {Object} [options.extensions] An object containing the negotiated
       *     extensions
       * @param {Boolean} [options.isServer=false] Specifies whether to operate in
       *     client or server mode
       * @param {Number} [options.maxPayload=0] The maximum allowed message length
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       */
      constructor(options = {}) {
        super();
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length)
          return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = new FastBuffer(
            buf.buffer,
            buf.byteOffset + n,
            buf.length - n
          );
          return new FastBuffer(buf.buffer, buf.byteOffset, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset2 = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset2);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset2);
            this._buffers[0] = new FastBuffer(
              buf.buffer,
              buf.byteOffset + n,
              buf.length - n
            );
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (!this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
          }
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
            this._loop = false;
            return error(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
          }
        } else {
          this._loop = false;
          return error(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
          }
        } else if (this._masked) {
          this._loop = false;
          return error(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          return this.haveLength();
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      /**
       * Payload length has been read.
       *
       * @return {(RangeError|undefined)} A possible error
       * @private
       */
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7)
          return this.controlMessage(data);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        return this.dataMessage();
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(
                error(
                  RangeError,
                  "Max payload size exceeded",
                  false,
                  1009,
                  "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
                )
              );
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er)
            return cb(er);
          this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @return {(Error|undefined)} A possible error
       * @private
       */
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data;
            if (this._binaryType === "nodebuffer") {
              data = concat(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data = toArrayBuffer(concat(fragments, messageLength));
            } else {
              data = fragments;
            }
            this.emit("message", data, true);
          } else {
            const buf = concat(fragments, messageLength);
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              this._loop = false;
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("message", buf, false);
          }
        }
        this._state = GET_INFO;
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data.length === 0) {
            this.emit("conclude", 1005, EMPTY_BUFFER);
            this.end();
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              return error(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
            }
            const buf = new FastBuffer(
              data.buffer,
              data.byteOffset + 2,
              data.length - 2
            );
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("conclude", code, buf);
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data);
        } else {
          this.emit("pong", data);
        }
        this._state = GET_INFO;
      }
    };
    module.exports = Receiver;
    function error(ErrorCtor, message2, prefix, statusCode, errorCode) {
      const err = new ErrorCtor(
        prefix ? `Invalid WebSocket frame: ${message2}` : message2
      );
      Error.captureStackTrace(err, error);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
});

// ../../node_modules/rpc-websockets/node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "../../node_modules/rpc-websockets/node_modules/ws/lib/sender.js"(exports, module) {
    "use strict";
    var net = __require("net");
    var tls = __require("tls");
    var { randomFillSync } = __require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER } = require_constants();
    var { isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer: toBuffer2 } = require_buffer_util();
    var kByteLength = Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var Sender = class {
      /**
       * Creates a Sender instance.
       *
       * @param {(net.Socket|tls.Socket)} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Function} [generateMask] The function used to generate the masking
       *     key
       */
      constructor(socket, extensions, generateMask) {
        this._extensions = extensions || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {(Buffer|String)} data The data to frame
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {(Buffer|String)[]} The framed data
       * @public
       */
      static frame(data, options) {
        let mask2;
        let merge = false;
        let offset2 = 2;
        let skipMasking = false;
        if (options.mask) {
          mask2 = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask2);
          } else {
            randomFillSync(mask2, 0, 4);
          }
          skipMasking = (mask2[0] | mask2[1] | mask2[2] | mask2[3]) === 0;
          offset2 = 6;
        }
        let dataLength;
        if (typeof data === "string") {
          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
            dataLength = options[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset2 += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset2 += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? dataLength + offset2 : offset2);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options.mask)
          return [target, data];
        target[1] |= 128;
        target[offset2 - 4] = mask2[0];
        target[offset2 - 3] = mask2[1];
        target[offset2 - 2] = mask2[2];
        target[offset2 - 1] = mask2[3];
        if (skipMasking)
          return [target, data];
        if (merge) {
          applyMask(data, mask2, target, offset2, dataLength);
          return [target];
        }
        applyMask(data, mask2, data, 0, dataLength);
        return [target, data];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data, mask2, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data === "string") {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }
        const options = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask: mask2,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, buf, false, options, cb]);
        } else {
          this.sendFrame(Sender.frame(buf, options), cb);
        }
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data, mask2, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer2(data);
          byteLength = data.length;
          readOnly = toBuffer2.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask: mask2,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data, mask2, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer2(data);
          byteLength = data.length;
          readOnly = toBuffer2.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask: mask2,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer2(data);
          byteLength = data.length;
          readOnly = toBuffer2.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin)
          this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            [kByteLength]: byteLength,
            fin: options.fin,
            generateMask: this._generateMask,
            mask: options.mask,
            maskBuffer: this._maskBuffer,
            opcode,
            readOnly,
            rsv1
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, data, this._compress, opts, cb]);
          } else {
            this.dispatch(data, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(
            Sender.frame(data, {
              [kByteLength]: byteLength,
              fin: options.fin,
              generateMask: this._generateMask,
              mask: options.mask,
              maskBuffer: this._maskBuffer,
              opcode,
              readOnly,
              rsv1: false
            }),
            cb
          );
        }
      }
      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._deflating = true;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            if (typeof cb === "function")
              cb(err);
            for (let i = 0; i < this._queue.length; i++) {
              const params = this._queue[i];
              const callback = params[params.length - 1];
              if (typeof callback === "function")
                callback(err);
            }
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          this._deflating = false;
          options.readOnly = false;
          this.sendFrame(Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {Buffer[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module.exports = Sender;
  }
});

// ../../node_modules/rpc-websockets/node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "../../node_modules/rpc-websockets/node_modules/ws/lib/event-target.js"(exports, module) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants();
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError = Symbol("kError");
    var kMessage = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @throws {TypeError} If the `type` argument is not specified
       */
      constructor(type2) {
        this[kTarget] = null;
        this[kType] = type2;
      }
      /**
       * @type {*}
       */
      get target() {
        return this[kTarget];
      }
      /**
       * @type {String}
       */
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event.prototype, "target", { enumerable: true });
    Object.defineProperty(Event.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {Number} [options.code=0] The status code explaining why the
       *     connection was closed
       * @param {String} [options.reason=''] A human-readable string explaining why
       *     the connection was closed
       * @param {Boolean} [options.wasClean=false] Indicates whether or not the
       *     connection was cleanly closed
       */
      constructor(type2, options = {}) {
        super(type2);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? "" : options.reason;
        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
      }
      /**
       * @type {Number}
       */
      get code() {
        return this[kCode];
      }
      /**
       * @type {String}
       */
      get reason() {
        return this[kReason];
      }
      /**
       * @type {Boolean}
       */
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    var ErrorEvent = class extends Event {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.error=null] The error that generated this event
       * @param {String} [options.message=''] The error message
       */
      constructor(type2, options = {}) {
        super(type2);
        this[kError] = options.error === void 0 ? null : options.error;
        this[kMessage] = options.message === void 0 ? "" : options.message;
      }
      /**
       * @type {*}
       */
      get error() {
        return this[kError];
      }
      /**
       * @type {String}
       */
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.data=null] The message content
       */
      constructor(type2, options = {}) {
        super(type2);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      /**
       * @type {*}
       */
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {(Function|Object)} handler The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type2, handler, options = {}) {
        for (const listener of this.listeners(type2)) {
          if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            return;
          }
        }
        let wrapper;
        if (type2 === "message") {
          wrapper = function onMessage(data, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data : data.toString()
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type2 === "close") {
          wrapper = function onClose(code, message2) {
            const event = new CloseEvent("close", {
              code,
              reason: message2.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type2 === "error") {
          wrapper = function onError(error) {
            const event = new ErrorEvent("error", {
              error,
              message: error.message
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type2 === "open") {
          wrapper = function onOpen() {
            const event = new Event("open");
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = handler;
        if (options.once) {
          this.once(type2, wrapper);
        } else {
          this.on(type2, wrapper);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {(Function|Object)} handler The listener to remove
       * @public
       */
      removeEventListener(type2, handler) {
        for (const listener of this.listeners(type2)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type2, listener);
            break;
          }
        }
      }
    };
    module.exports = {
      CloseEvent,
      ErrorEvent,
      Event,
      EventTarget,
      MessageEvent
    };
    function callListener(listener, thisArg, event) {
      if (typeof listener === "object" && listener.handleEvent) {
        listener.handleEvent.call(listener, event);
      } else {
        listener.call(thisArg, event);
      }
    }
  }
});

// ../../node_modules/rpc-websockets/node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "../../node_modules/rpc-websockets/node_modules/ws/lib/extension.js"(exports, module) {
    "use strict";
    var { tokenChars } = require_validation();
    function push(dest, name, elem) {
      if (dest[name] === void 0)
        dest[name] = [elem];
      else
        dest[name].push(elem);
    }
    function parse3(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (i !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1)
              start = i;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k) => {
              let values = params[k];
              if (!Array.isArray(values))
                values = [values];
              return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module.exports = { format, parse: parse3 };
  }
});

// ../../node_modules/rpc-websockets/node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "../../node_modules/rpc-websockets/node_modules/ws/lib/websocket.js"(exports, module) {
    "use strict";
    var EventEmitter = __require("events");
    var https2 = __require("https");
    var http2 = __require("http");
    var net = __require("net");
    var tls = __require("tls");
    var { randomBytes, createHash } = __require("crypto");
    var { Readable: Readable2 } = __require("stream");
    var { URL: URL3 } = __require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver = require_receiver();
    var Sender = require_sender();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants();
    var {
      EventTarget: { addEventListener, removeEventListener }
    } = require_event_target();
    var { format, parse: parse3 } = require_extension();
    var { toBuffer: toBuffer2 } = require_buffer_util();
    var closeTimeout = 30 * 1e3;
    var kAborted = Symbol("kAborted");
    var protocolVersions = [8, 13];
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var WebSocket = class extends EventEmitter {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._isServer = true;
        }
      }
      /**
       * This deviates from the WHATWG interface since ws doesn't support the
       * required default "blob" type (instead we define a custom "nodebuffer"
       * type).
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type2) {
        if (!BINARY_TYPES.includes(type2))
          return;
        this._binaryType = type2;
        if (this._receiver)
          this._receiver._binaryType = type2;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Boolean}
       */
      get isPaused() {
        return this._paused;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
      setSocket(socket, head, options) {
        const receiver = new Receiver({
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation
        });
        this._sender = new Sender(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = WebSocket.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
      close(code, data) {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this.readyState === WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(
          this._socket.destroy.bind(this._socket),
          closeTimeout
        );
      }
      /**
       * Pause the socket.
       *
       * @public
       */
      pause() {
        if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data, mask2, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask2 = void 0;
        } else if (typeof mask2 === "function") {
          cb = mask2;
          mask2 = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask2 === void 0)
          mask2 = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask2, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data, mask2, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask2 = void 0;
        } else if (typeof mask2 === "function") {
          cb = mask2;
          mask2 = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask2 === void 0)
          mask2 = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask2, cb);
      }
      /**
       * Resume the socket.
       *
       * @public
       */
      resume() {
        if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain)
          this._socket.resume();
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data, options, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = __spreadValues({
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true
        }, options);
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this._socket) {
          this._readyState = WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute])
              return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== "function")
            return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket.prototype.addEventListener = addEventListener;
    WebSocket.prototype.removeEventListener = removeEventListener;
    module.exports = WebSocket;
    function initAsClient(websocket, address, protocols, options) {
      const opts = __spreadProps(__spreadValues({
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10
      }, options), {
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: "GET",
        host: void 0,
        path: void 0,
        port: void 0
      });
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL3) {
        parsedUrl = address;
        websocket._url = address.href;
      } else {
        try {
          parsedUrl = new URL3(address);
        } catch (e) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
        websocket._url = address;
      }
      const isSecure = parsedUrl.protocol === "wss:";
      const isIpcUrl = parsedUrl.protocol === "ws+unix:";
      let invalidUrlMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
        invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", or "ws+unix:"`;
      } else if (isIpcUrl && !parsedUrl.pathname) {
        invalidUrlMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidUrlMessage = "The URL contains a fragment identifier";
      }
      if (invalidUrlMessage) {
        const err = new SyntaxError(invalidUrlMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const request = isSecure ? https2.request : http2.request;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = __spreadProps(__spreadValues({}, opts.headers), {
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket"
      });
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError(
              "An invalid or duplicated subprotocol was specified"
            );
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isIpcUrl) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req;
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalIpc = isIpcUrl;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = __spreadProps(__spreadValues({}, options), { headers: {} });
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else if (websocket.listenerCount("redirect") === 0) {
          const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost)
              delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
        req = websocket._req = request(opts);
        if (websocket._redirects) {
          websocket.emit("redirect", websocket.url, req);
        }
      } else {
        req = websocket._req = request(opts);
      }
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req[kAborted])
          return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL3(location, address);
          } catch (e) {
            const err = new SyntaxError(`Invalid URL: ${location}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket.CONNECTING)
          return;
        req = websocket._req = null;
        if (res.headers.upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt)
          websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message2 = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message2);
            return;
          }
          let extensions;
          try {
            extensions = parse3(secWebSocketExtensions);
          } catch (err) {
            const message2 = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message2);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message2 = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message2);
            return;
          }
          try {
            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message2 = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message2);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
      req.end();
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket.CLOSING;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message2) {
      websocket._readyState = WebSocket.CLOSING;
      const err = new Error(message2);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream[kAborted] = true;
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        process.nextTick(emitErrorAndClose, websocket, err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = toBuffer2(data).length;
        if (websocket._socket)
          websocket._sender._bufferedBytes += length;
        else
          websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        process.nextTick(cb, err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0)
        return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005)
        websocket.close();
      else
        websocket.close(code, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused)
        websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      websocket.emit("error", err);
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data, isBinary) {
      this[kWebSocket].emit("message", data, isBinary);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      websocket.pong(data, !websocket._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
      stream.resume();
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket.CLOSING;
        this.destroy();
      }
    }
  }
});

// ../../node_modules/rpc-websockets/node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "../../node_modules/rpc-websockets/node_modules/ws/lib/stream.js"(exports, module) {
    "use strict";
    var { Duplex } = __require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex(__spreadProps(__spreadValues({}, options), {
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      }));
      ws.on("message", function message2(msg, isBinary) {
        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data))
          ws.pause();
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed)
          return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed)
          return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called)
            callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy)
          ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null)
          return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted)
            duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused)
          ws.resume();
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module.exports = createWebSocketStream;
  }
});

// ../../node_modules/rpc-websockets/node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
  "../../node_modules/rpc-websockets/node_modules/ws/lib/subprotocol.js"(exports, module) {
    "use strict";
    var { tokenChars } = require_validation();
    function parse3(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start = -1;
      let end = -1;
      let i = 0;
      for (i; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const protocol2 = header.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start, i);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    module.exports = { parse: parse3 };
  }
});

// ../../node_modules/rpc-websockets/node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "../../node_modules/rpc-websockets/node_modules/ws/lib/websocket-server.js"(exports, module) {
    "use strict";
    var EventEmitter = __require("events");
    var http2 = __require("http");
    var https2 = __require("https");
    var net = __require("net");
    var tls = __require("tls");
    var { createHash } = __require("crypto");
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket = require_websocket();
    var { GUID, kWebSocket } = require_constants();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer = class extends EventEmitter {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
       *     class to use. It must be the `WebSocket` class or class that extends it
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options, callback) {
        super();
        options = __spreadValues({
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket
        }, options);
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http2.createServer((req, res) => {
            const body = http2.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true)
          options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      /**
       * Stop the server from accepting new connections and emit the `'close'` event
       * when all existing connections are closed.
       *
       * @param {Function} [cb] A one-time listener for the `'close'` event
       * @public
       */
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb)
          this.once("close", cb);
        if (this._state === CLOSING)
          return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path)
            return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"];
        const version2 = +req.headers["sec-websocket-version"];
        if (req.method !== "GET") {
          const message2 = "Invalid HTTP method";
          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message2);
          return;
        }
        if (req.headers.upgrade.toLowerCase() !== "websocket") {
          const message2 = "Invalid Upgrade header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message2);
          return;
        }
        if (!key || !keyRegex.test(key)) {
          const message2 = "Missing or invalid Sec-WebSocket-Key header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message2);
          return;
        }
        if (version2 !== 8 && version2 !== 13) {
          const message2 = "Missing or invalid Sec-WebSocket-Version header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message2);
          return;
        }
        if (!this.shouldHandle(req)) {
          abortHandshake(socket, 400);
          return;
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message2 = "Invalid Sec-WebSocket-Protocol header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message2);
            return;
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message2 = "Invalid or unacceptable Sec-WebSocket-Extensions header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message2);
            return;
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version2 === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message2, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message2, headers);
              }
              this.completeUpgrade(
                extensions,
                key,
                protocols,
                req,
                socket,
                head,
                cb
              );
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {Object} extensions The accepted extensions
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Set} protocols The subprotocols
       * @param {http.IncomingMessage} req The request object
       * @param {(net.Socket|tls.Socket)} socket The network socket between the
       *     server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING)
          return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module.exports = WebSocketServer;
    function addListeners(server, map) {
      for (const event of Object.keys(map))
        server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message2, headers) {
      message2 = message2 || http2.STATUS_CODES[code];
      headers = __spreadValues({
        Connection: "close",
        "Content-Type": "text/html",
        "Content-Length": Buffer.byteLength(message2)
      }, headers);
      socket.once("finish", socket.destroy);
      socket.end(
        `HTTP/1.1 ${code} ${http2.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h2) => `${h2}: ${headers[h2]}`).join("\r\n") + "\r\n\r\n" + message2
      );
    }
    function abortHandshakeOrEmitwsClientError(server, req, socket, code, message2) {
      if (server.listenerCount("wsClientError")) {
        const err = new Error(message2);
        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
        server.emit("wsClientError", err, socket, req);
      } else {
        abortHandshake(socket, code, message2);
      }
    }
  }
});

// ../../node_modules/rpc-websockets/node_modules/ws/index.js
var require_ws = __commonJS({
  "../../node_modules/rpc-websockets/node_modules/ws/index.js"(exports, module) {
    "use strict";
    var WebSocket = require_websocket();
    WebSocket.createWebSocketStream = require_stream();
    WebSocket.Server = require_websocket_server();
    WebSocket.Receiver = require_receiver();
    WebSocket.Sender = require_sender();
    WebSocket.WebSocket = WebSocket;
    WebSocket.WebSocketServer = WebSocket.Server;
    module.exports = WebSocket;
  }
});

// ../../node_modules/rpc-websockets/dist/lib/client/websocket.js
var require_websocket2 = __commonJS({
  "../../node_modules/rpc-websockets/dist/lib/client/websocket.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = _default;
    var _ws = _interopRequireDefault(require_ws());
    function _default(address, options) {
      return new _ws["default"](address, options);
    }
  }
});

// node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "node_modules/axios/lib/helpers/bind.js"(exports, module) {
    "use strict";
    module.exports = function bind(fn2, thisArg) {
      return function wrap() {
        var args2 = new Array(arguments.length);
        for (var i = 0; i < args2.length; i++) {
          args2[i] = arguments[i];
        }
        return fn2.apply(thisArg, args2);
      };
    };
  }
});

// node_modules/axios/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/axios/lib/utils.js"(exports, module) {
    "use strict";
    var bind = require_bind();
    var toString = Object.prototype.toString;
    function isArray(val) {
      return toString.call(val) === "[object Array]";
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer(val) {
      return toString.call(val) === "[object ArrayBuffer]";
    }
    function isFormData(val) {
      return typeof FormData !== "undefined" && val instanceof FormData;
    }
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && val.buffer instanceof ArrayBuffer;
      }
      return result;
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject2(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (toString.call(val) !== "[object Object]") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isDate(val) {
      return toString.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString.call(val) === "[object File]";
    }
    function isBlob2(val) {
      return toString.call(val) === "[object Blob]";
    }
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject2(val) && isFunction(val.pipe);
    }
    function isURLSearchParams2(val) {
      return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
    }
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn2) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn2.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn2.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    module.exports = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isObject: isObject2,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob: isBlob2,
      isFunction,
      isStream,
      isURLSearchParams: isURLSearchParams2,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim,
      stripBOM
    };
  }
});

// node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/axios/lib/helpers/buildURL.js"(exports, module) {
    "use strict";
    var utils3 = require_utils2();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils3.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils3.forEach(params, function serialize2(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils3.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils3.forEach(val, function parseValue(v) {
            if (utils3.isDate(v)) {
              v = v.toISOString();
            } else if (utils3.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/axios/lib/core/InterceptorManager.js"(exports, module) {
    "use strict";
    var utils3 = require_utils2();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn2) {
      utils3.forEach(this.handlers, function forEachHandler(h2) {
        if (h2 !== null) {
          fn2(h2);
        }
      });
    };
    module.exports = InterceptorManager;
  }
});

// node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module) {
    "use strict";
    var utils3 = require_utils2();
    module.exports = function normalizeHeaderName(headers, normalizedName) {
      utils3.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS({
  "node_modules/axios/lib/core/enhanceError.js"(exports, module) {
    "use strict";
    module.exports = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
      error.toJSON = function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      };
      return error;
    };
  }
});

// node_modules/axios/lib/core/createError.js
var require_createError = __commonJS({
  "node_modules/axios/lib/core/createError.js"(exports, module) {
    "use strict";
    var enhanceError = require_enhanceError();
    module.exports = function createError(message2, config, code, request, response) {
      var error = new Error(message2);
      return enhanceError(error, config, code, request, response);
    };
  }
});

// node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "node_modules/axios/lib/core/settle.js"(exports, module) {
    "use strict";
    var createError = require_createError();
    module.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError(
          "Request failed with status code " + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };
  }
});

// node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/axios/lib/helpers/cookies.js"(exports, module) {
    "use strict";
    var utils3 = require_utils2();
    module.exports = utils3.isStandardBrowserEnv() ? (
      // Standard browser envs support document.cookie
      function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils3.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils3.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils3.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }()
    ) : (
      // Non standard browser env (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove() {
          }
        };
      }()
    );
  }
});

// node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module) {
    "use strict";
    module.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/axios/lib/helpers/combineURLs.js"(exports, module) {
    "use strict";
    module.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "node_modules/axios/lib/core/buildFullPath.js"(exports, module) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/axios/lib/helpers/parseHeaders.js"(exports, module) {
    "use strict";
    var utils3 = require_utils2();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils3.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils3.trim(line.substr(0, i)).toLowerCase();
        val = utils3.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module) {
    "use strict";
    var utils3 = require_utils2();
    module.exports = utils3.isStandardBrowserEnv() ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils3.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      }()
    );
  }
});

// node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS({
  "node_modules/axios/lib/cancel/Cancel.js"(exports, module) {
    "use strict";
    function Cancel(message2) {
      this.message = message2;
    }
    Cancel.prototype.toString = function toString() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel.prototype.__CANCEL__ = true;
    module.exports = Cancel;
  }
});

// node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/axios/lib/adapters/xhr.js"(exports, module) {
    "use strict";
    var utils3 = require_utils2();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var createError = require_createError();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    module.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils3.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(createError("Request aborted", config, "ECONNABORTED", request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(createError("Network Error", config, null, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          var transitional = config.transitional || defaults.transitional;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(
            timeoutErrorMessage,
            config,
            transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
            request
          ));
          request = null;
        };
        if (utils3.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils3.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils3.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (!request) {
              return;
            }
            reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (!requestData) {
          requestData = null;
        }
        request.send(requestData);
      });
    };
  }
});

// ../../node_modules/ms/index.js
var require_ms = __commonJS({
  "../../node_modules/ms/index.js"(exports, module) {
    var s2 = 1e3;
    var m2 = s2 * 60;
    var h2 = m2 * 60;
    var d2 = h2 * 24;
    var w2 = d2 * 7;
    var y2 = d2 * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type2 = typeof val;
      if (type2 === "string" && val.length > 0) {
        return parse3(val);
      } else if (type2 === "number" && isFinite(val)) {
        return options.long ? fmtLong2(val) : fmtShort2(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse3(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type2 = (match[2] || "ms").toLowerCase();
      switch (type2) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y2;
        case "weeks":
        case "week":
        case "w":
          return n * w2;
        case "days":
        case "day":
        case "d":
          return n * d2;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h2;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m2;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort2(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d2) {
        return Math.round(ms2 / d2) + "d";
      }
      if (msAbs >= h2) {
        return Math.round(ms2 / h2) + "h";
      }
      if (msAbs >= m2) {
        return Math.round(ms2 / m2) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms2 / s2) + "s";
      }
      return ms2 + "ms";
    }
    function fmtLong2(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d2) {
        return plural2(ms2, msAbs, d2, "day");
      }
      if (msAbs >= h2) {
        return plural2(ms2, msAbs, h2, "hour");
      }
      if (msAbs >= m2) {
        return plural2(ms2, msAbs, m2, "minute");
      }
      if (msAbs >= s2) {
        return plural2(ms2, msAbs, s2, "second");
      }
      return ms2 + " ms";
    }
    function plural2(ms2, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../../node_modules/debug/src/common.js
var require_common = __commonJS({
  "../../node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce2;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash2 = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args2) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms2 = curr - (prevTime || curr);
          self2.diff = ms2;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args2[0] = createDebug.coerce(args2[0]);
          if (typeof args2[0] !== "string") {
            args2.unshift("%O");
          }
          let index = 0;
          args2[0] = args2[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args2[index];
              match = formatter.call(self2, val);
              args2.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args2);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args2);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split2.length;
        for (i = 0; i < len; i++) {
          if (!split2[i]) {
            continue;
          }
          namespaces = split2[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce2(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// ../../node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "../../node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args2) {
      args2[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args2[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args2.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args2[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args2.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// ../../node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "../../node_modules/has-flag/index.js"(exports, module) {
    "use strict";
    module.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// ../../node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "../../node_modules/supports-color/index.js"(exports, module) {
    "use strict";
    var os = __require("os");
    var tty = __require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign2) => sign2 in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// ../../node_modules/debug/src/node.js
var require_node2 = __commonJS({
  "../../node_modules/debug/src/node.js"(exports, module) {
    var tty = __require("tty");
    var util2 = __require("util");
    exports.init = init;
    exports.log = log2;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args2) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args2[0] = prefix + args2[0].split("\n").join("\n" + prefix);
        args2.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args2[0] = getDate() + name + " " + args2[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log2(...args2) {
      return process.stderr.write(util2.format(...args2) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug2.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  }
});

// ../../node_modules/debug/src/index.js
var require_src2 = __commonJS({
  "../../node_modules/debug/src/index.js"(exports, module) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module.exports = require_browser2();
    } else {
      module.exports = require_node2();
    }
  }
});

// ../../node_modules/follow-redirects/debug.js
var require_debug = __commonJS({
  "../../node_modules/follow-redirects/debug.js"(exports, module) {
    var debug2;
    module.exports = function() {
      if (!debug2) {
        try {
          debug2 = require_src2()("follow-redirects");
        } catch (error) {
        }
        if (typeof debug2 !== "function") {
          debug2 = function() {
          };
        }
      }
      debug2.apply(null, arguments);
    };
  }
});

// ../../node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "../../node_modules/follow-redirects/index.js"(exports, module) {
    var url = __require("url");
    var URL3 = url.URL;
    var http2 = __require("http");
    var https2 = __require("https");
    var Writable = __require("stream").Writable;
    var assert4 = __require("assert");
    var debug2 = require_debug();
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    );
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded"
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        self2._processResponse(response);
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      abortRequest(this._currentRequest);
      this.emit("abort");
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString(data) && !isBuffer(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (isFunction(data)) {
        callback = data;
        data = encoding = null;
      } else if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        this.emit("error", new TypeError("Unsupported protocol " + protocol));
        return;
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request._redirectable = this;
      for (var event of events) {
        request.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : (
        // When making a request to a proxy, […]
        // a client MUST send the target URI in absolute-form […].
        this._options.path
      );
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request === self2._currentRequest) {
            if (error) {
              self2.emit("error", error);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      abortRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        this.emit("error", new TooManyRedirectsError());
        return;
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          // The Host header was set by nativeProtocol.request
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC7231§6.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource […]
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) […]
      statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = url.parse(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl;
      try {
        redirectUrl = url.resolve(currentUrl, location);
      } catch (cause) {
        this.emit("error", new RedirectionError({ cause }));
        return;
      }
      debug2("redirecting to", redirectUrl);
      this._isRedirect = true;
      var redirectUrlParts = url.parse(redirectUrl);
      Object.assign(this._options, redirectUrlParts);
      if (redirectUrlParts.protocol !== currentUrlParts.protocol && redirectUrlParts.protocol !== "https:" || redirectUrlParts.host !== currentHost && !isSubdomain(redirectUrlParts.host, currentHost)) {
        removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        try {
          beforeRedirect(this._options, responseDetails, requestDetails);
        } catch (err) {
          this.emit("error", err);
          return;
        }
        this._sanitizeOptions(this._options);
      }
      try {
        this._performRequest();
      } catch (cause) {
        this.emit("error", new RedirectionError({ cause }));
      }
    };
    function wrap(protocols) {
      var exports2 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports2[scheme] = Object.create(nativeProtocol);
        function request(input, options, callback) {
          if (isString(input)) {
            var parsed;
            try {
              parsed = urlToOptions(new URL3(input));
            } catch (err) {
              parsed = url.parse(input);
            }
            if (!isString(parsed.protocol)) {
              throw new InvalidUrlError({ input });
            }
            input = parsed;
          } else if (URL3 && input instanceof URL3) {
            input = urlToOptions(input);
          } else {
            callback = options;
            options = input;
            input = { protocol };
          }
          if (isFunction(options)) {
            callback = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports2.maxRedirects,
            maxBodyLength: exports2.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          if (!isString(options.host) && !isString(options.hostname)) {
            options.hostname = "::1";
          }
          assert4.equal(options.protocol, protocol, "protocol mismatch");
          debug2("options", options);
          return new RedirectableRequest(options, callback);
        }
        function get(input, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports2;
    }
    function noop() {
    }
    function urlToOptions(urlObject) {
      var options = {
        protocol: urlObject.protocol,
        hostname: urlObject.hostname.startsWith("[") ? (
          /* istanbul ignore next */
          urlObject.hostname.slice(1, -1)
        ) : urlObject.hostname,
        hash: urlObject.hash,
        search: urlObject.search,
        pathname: urlObject.pathname,
        path: urlObject.pathname + urlObject.search,
        href: urlObject.href
      };
      if (urlObject.port !== "") {
        options.port = Number(urlObject.port);
      }
      return options;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, message2, baseClass) {
      function CustomError(properties) {
        Error.captureStackTrace(this, this.constructor);
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message2 + ": " + this.cause.message : message2;
      }
      CustomError.prototype = new (baseClass || Error)();
      CustomError.prototype.constructor = CustomError;
      CustomError.prototype.name = "Error [" + code + "]";
      return CustomError;
    }
    function abortRequest(request) {
      for (var event of events) {
        request.removeListener(event, eventHandlers[event]);
      }
      request.on("error", noop);
      request.abort();
    }
    function isSubdomain(subdomain, domain) {
      assert4(isString(subdomain) && isString(domain));
      var dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    function isString(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isBuffer(value) {
      return typeof value === "object" && "length" in value;
    }
    module.exports = wrap({ http: http2, https: https2 });
    module.exports.wrap = wrap;
  }
});

// node_modules/axios/lib/env/data.js
var require_data = __commonJS({
  "node_modules/axios/lib/env/data.js"(exports, module) {
    module.exports = {
      "version": "0.24.0"
    };
  }
});

// node_modules/axios/lib/adapters/http.js
var require_http = __commonJS({
  "node_modules/axios/lib/adapters/http.js"(exports, module) {
    "use strict";
    var utils3 = require_utils2();
    var settle = require_settle();
    var buildFullPath = require_buildFullPath();
    var buildURL = require_buildURL();
    var http2 = __require("http");
    var https2 = __require("https");
    var httpFollow = require_follow_redirects().http;
    var httpsFollow = require_follow_redirects().https;
    var url = __require("url");
    var zlib2 = __require("zlib");
    var VERSION = require_data().version;
    var createError = require_createError();
    var enhanceError = require_enhanceError();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    var isHttps = /https:?/;
    function setProxy(options, proxy, location) {
      options.hostname = proxy.host;
      options.host = proxy.host;
      options.port = proxy.port;
      options.path = location;
      if (proxy.auth) {
        var base64 = Buffer.from(proxy.auth.username + ":" + proxy.auth.password, "utf8").toString("base64");
        options.headers["Proxy-Authorization"] = "Basic " + base64;
      }
      options.beforeRedirect = function beforeRedirect(redirection) {
        redirection.headers.host = redirection.host;
        setProxy(redirection, proxy, redirection.href);
      };
    }
    module.exports = function httpAdapter(config) {
      return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        var resolve = function resolve2(value) {
          done();
          resolvePromise(value);
        };
        var reject = function reject2(value) {
          done();
          rejectPromise(value);
        };
        var data = config.data;
        var headers = config.headers;
        var headerNames = {};
        Object.keys(headers).forEach(function storeLowerName(name) {
          headerNames[name.toLowerCase()] = name;
        });
        if ("user-agent" in headerNames) {
          if (!headers[headerNames["user-agent"]]) {
            delete headers[headerNames["user-agent"]];
          }
        } else {
          headers["User-Agent"] = "axios/" + VERSION;
        }
        if (data && !utils3.isStream(data)) {
          if (Buffer.isBuffer(data)) {
          } else if (utils3.isArrayBuffer(data)) {
            data = Buffer.from(new Uint8Array(data));
          } else if (utils3.isString(data)) {
            data = Buffer.from(data, "utf-8");
          } else {
            return reject(createError(
              "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
              config
            ));
          }
          if (!headerNames["content-length"]) {
            headers["Content-Length"] = data.length;
          }
        }
        var auth = void 0;
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password || "";
          auth = username + ":" + password;
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        var parsed = url.parse(fullPath);
        var protocol = parsed.protocol || "http:";
        if (!auth && parsed.auth) {
          var urlAuth = parsed.auth.split(":");
          var urlUsername = urlAuth[0] || "";
          var urlPassword = urlAuth[1] || "";
          auth = urlUsername + ":" + urlPassword;
        }
        if (auth && headerNames.authorization) {
          delete headers[headerNames.authorization];
        }
        var isHttpsRequest = isHttps.test(protocol);
        var agent2 = isHttpsRequest ? config.httpsAgent : config.httpAgent;
        var options = {
          path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ""),
          method: config.method.toUpperCase(),
          headers,
          agent: agent2,
          agents: { http: config.httpAgent, https: config.httpsAgent },
          auth
        };
        if (config.socketPath) {
          options.socketPath = config.socketPath;
        } else {
          options.hostname = parsed.hostname;
          options.port = parsed.port;
        }
        var proxy = config.proxy;
        if (!proxy && proxy !== false) {
          var proxyEnv = protocol.slice(0, -1) + "_proxy";
          var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
          if (proxyUrl) {
            var parsedProxyUrl = url.parse(proxyUrl);
            var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
            var shouldProxy = true;
            if (noProxyEnv) {
              var noProxy = noProxyEnv.split(",").map(function trim(s2) {
                return s2.trim();
              });
              shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
                if (!proxyElement) {
                  return false;
                }
                if (proxyElement === "*") {
                  return true;
                }
                if (proxyElement[0] === "." && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
                  return true;
                }
                return parsed.hostname === proxyElement;
              });
            }
            if (shouldProxy) {
              proxy = {
                host: parsedProxyUrl.hostname,
                port: parsedProxyUrl.port,
                protocol: parsedProxyUrl.protocol
              };
              if (parsedProxyUrl.auth) {
                var proxyUrlAuth = parsedProxyUrl.auth.split(":");
                proxy.auth = {
                  username: proxyUrlAuth[0],
                  password: proxyUrlAuth[1]
                };
              }
            }
          }
        }
        if (proxy) {
          options.headers.host = parsed.hostname + (parsed.port ? ":" + parsed.port : "");
          setProxy(options, proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
        }
        var transport;
        var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
        if (config.transport) {
          transport = config.transport;
        } else if (config.maxRedirects === 0) {
          transport = isHttpsProxy ? https2 : http2;
        } else {
          if (config.maxRedirects) {
            options.maxRedirects = config.maxRedirects;
          }
          transport = isHttpsProxy ? httpsFollow : httpFollow;
        }
        if (config.maxBodyLength > -1) {
          options.maxBodyLength = config.maxBodyLength;
        }
        if (config.insecureHTTPParser) {
          options.insecureHTTPParser = config.insecureHTTPParser;
        }
        var req = transport.request(options, function handleResponse(res) {
          if (req.aborted)
            return;
          var stream = res;
          var lastRequest = res.req || req;
          if (res.statusCode !== 204 && lastRequest.method !== "HEAD" && config.decompress !== false) {
            switch (res.headers["content-encoding"]) {
              case "gzip":
              case "compress":
              case "deflate":
                stream = stream.pipe(zlib2.createUnzip());
                delete res.headers["content-encoding"];
                break;
            }
          }
          var response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: res.headers,
            config,
            request: lastRequest
          };
          if (config.responseType === "stream") {
            response.data = stream;
            settle(resolve, reject, response);
          } else {
            var responseBuffer = [];
            var totalResponseBytes = 0;
            stream.on("data", function handleStreamData(chunk) {
              responseBuffer.push(chunk);
              totalResponseBytes += chunk.length;
              if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
                stream.destroy();
                reject(createError(
                  "maxContentLength size of " + config.maxContentLength + " exceeded",
                  config,
                  null,
                  lastRequest
                ));
              }
            });
            stream.on("error", function handleStreamError(err) {
              if (req.aborted)
                return;
              reject(enhanceError(err, config, null, lastRequest));
            });
            stream.on("end", function handleStreamEnd() {
              var responseData = Buffer.concat(responseBuffer);
              if (config.responseType !== "arraybuffer") {
                responseData = responseData.toString(config.responseEncoding);
                if (!config.responseEncoding || config.responseEncoding === "utf8") {
                  responseData = utils3.stripBOM(responseData);
                }
              }
              response.data = responseData;
              settle(resolve, reject, response);
            });
          }
        });
        req.on("error", function handleRequestError(err) {
          if (req.aborted && err.code !== "ERR_FR_TOO_MANY_REDIRECTS")
            return;
          reject(enhanceError(err, config, null, req));
        });
        if (config.timeout) {
          var timeout = parseInt(config.timeout, 10);
          if (isNaN(timeout)) {
            reject(createError(
              "error trying to parse `config.timeout` to int",
              config,
              "ERR_PARSE_TIMEOUT",
              req
            ));
            return;
          }
          req.setTimeout(timeout, function handleRequestTimeout() {
            req.abort();
            var transitional = config.transitional || defaults.transitional;
            reject(createError(
              "timeout of " + timeout + "ms exceeded",
              config,
              transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
              req
            ));
          });
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (req.aborted)
              return;
            req.abort();
            reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (utils3.isStream(data)) {
          data.on("error", function handleStreamError(err) {
            reject(enhanceError(err, config, null, req));
          }).pipe(req);
        } else {
          req.end(data);
        }
      });
    };
  }
});

// node_modules/axios/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/axios/lib/defaults.js"(exports, module) {
    "use strict";
    var utils3 = require_utils2();
    var normalizeHeaderName = require_normalizeHeaderName();
    var enhanceError = require_enhanceError();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils3.isUndefined(headers) && utils3.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_http();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils3.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils3.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      },
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils3.isFormData(data) || utils3.isArrayBuffer(data) || utils3.isBuffer(data) || utils3.isStream(data) || utils3.isFile(data) || utils3.isBlob(data)) {
          return data;
        }
        if (utils3.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils3.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils3.isObject(data) || headers && headers["Content-Type"] === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils3.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw enhanceError(e, this, "E_JSON_PARSE");
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils3.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils3.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils3.merge(DEFAULT_CONTENT_TYPE);
    });
    module.exports = defaults;
  }
});

// node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/axios/lib/core/transformData.js"(exports, module) {
    "use strict";
    var utils3 = require_utils2();
    var defaults = require_defaults();
    module.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      utils3.forEach(fns, function transform(fn2) {
        data = fn2.call(context, data, headers);
      });
      return data;
    };
  }
});

// node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/axios/lib/cancel/isCancel.js"(exports, module) {
    "use strict";
    module.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/axios/lib/core/dispatchRequest.js"(exports, module) {
    "use strict";
    var utils3 = require_utils2();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new Cancel("canceled");
      }
    }
    module.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(
        config,
        config.data,
        config.headers,
        config.transformRequest
      );
      config.headers = utils3.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );
      utils3.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          response.data,
          response.headers,
          config.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "node_modules/axios/lib/core/mergeConfig.js"(exports, module) {
    "use strict";
    var utils3 = require_utils2();
    module.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      function getMergedValue(target, source) {
        if (utils3.isPlainObject(target) && utils3.isPlainObject(source)) {
          return utils3.merge(target, source);
        } else if (utils3.isPlainObject(source)) {
          return utils3.merge({}, source);
        } else if (utils3.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils3.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils3.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils3.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils3.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        } else if (!utils3.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils3.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(prop);
        utils3.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    };
  }
});

// node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "node_modules/axios/lib/helpers/validator.js"(exports, module) {
    "use strict";
    var VERSION = require_data().version;
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type2, i) {
      validators[type2] = function validator(thing) {
        return typeof thing === type2 || "a" + (i < 1 ? "n " : " ") + type2;
      };
    });
    var deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version2, message2) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message2 ? ". " + message2 : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")));
        }
        if (version2 && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version2 + " and will be removed in the near future"
            )
          );
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new TypeError("options must be an object");
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new TypeError("option " + opt + " must be " + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error("Unknown option " + opt);
        }
      }
    }
    module.exports = {
      assertOptions,
      validators
    };
  }
});

// node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/axios/lib/core/Axios.js"(exports, module) {
    "use strict";
    var utils3 = require_utils2();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(config) {
      if (typeof config === "string") {
        config = arguments[1] || {};
        config.url = arguments[0];
      } else {
        config = config || {};
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
    };
    utils3.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils3.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data
        }));
      };
    });
    module.exports = Axios;
  }
});

// node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/axios/lib/cancel/CancelToken.js"(exports, module) {
    "use strict";
    var Cancel = require_Cancel();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;
      this.promise.then(function(cancel) {
        if (!token._listeners)
          return;
        var i;
        var l = token._listeners.length;
        for (i = 0; i < l; i++) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = function(onfulfilled) {
        var _resolve;
        var promise = new Promise(function(resolve) {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message2) {
        if (token.reason) {
          return;
        }
        token.reason = new Cancel(message2);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module.exports = CancelToken;
  }
});

// node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/axios/lib/helpers/spread.js"(exports, module) {
    "use strict";
    module.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "node_modules/axios/lib/helpers/isAxiosError.js"(exports, module) {
    "use strict";
    module.exports = function isAxiosError(payload) {
      return typeof payload === "object" && payload.isAxiosError === true;
    };
  }
});

// node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "node_modules/axios/lib/axios.js"(exports, module) {
    "use strict";
    var utils3 = require_utils2();
    var bind = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance2 = bind(Axios.prototype.request, context);
      utils3.extend(instance2, Axios.prototype, context);
      utils3.extend(instance2, context);
      instance2.create = function create2(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance2;
    }
    var axios2 = createInstance(defaults);
    axios2.Axios = Axios;
    axios2.Cancel = require_Cancel();
    axios2.CancelToken = require_CancelToken();
    axios2.isCancel = require_isCancel();
    axios2.VERSION = require_data().version;
    axios2.all = function all(promises) {
      return Promise.all(promises);
    };
    axios2.spread = require_spread();
    axios2.isAxiosError = require_isAxiosError();
    module.exports = axios2;
    module.exports.default = axios2;
  }
});

// node_modules/axios/index.js
var require_axios2 = __commonJS({
  "node_modules/axios/index.js"(exports, module) {
    module.exports = require_axios();
  }
});

// src/index.ts
import { web3 as web37 } from "@project-serum/anchor";

// src/configs/pubkeys.config.ts
import * as anchor from "@project-serum/anchor";
var USDC_PUBKEY = new anchor.web3.PublicKey(
  "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v"
);
var WSOL_PUBKEY = new anchor.web3.PublicKey(
  "So11111111111111111111111111111111111111112"
);
var BONK_PUBKEY = new anchor.web3.PublicKey(
  "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263"
);
var SAMO_PUBKEY = new anchor.web3.PublicKey(
  "7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU"
);
var SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new anchor.web3.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");

// src/configs/token-list.config.ts
import * as anchor2 from "@project-serum/anchor";

// ../../node_modules/@solana/web3.js/lib/index.esm.js
import { Buffer as Buffer2 } from "buffer";

// ../../node_modules/@noble/hashes/esm/_assert.js
function number(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function bool(b) {
  if (typeof b !== "boolean")
    throw new Error(`Expected boolean, not ${b}`);
}
function bytes(b, ...lengths) {
  if (!(b instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash2.outputLen);
  number(hash2.blockLen);
}
function exists(instance2, checkFinished = true) {
  if (instance2.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance2.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance2) {
  bytes(out);
  const min = instance2.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
var assert = {
  number,
  bool,
  bytes,
  hash,
  exists,
  output
};
var assert_default = assert;

// ../../node_modules/@noble/hashes/esm/utils.js
var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
var hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
function utf8ToBytes(str) {
  if (typeof str !== "string") {
    throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
  }
  return new TextEncoder().encode(str);
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  if (!(data instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
  return data;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor(hashConstructor) {
  const hashC = (message2) => hashConstructor().update(toBytes(message2)).digest();
  const tmp = hashConstructor();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashConstructor();
  return hashC;
}
function wrapConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}

// ../../node_modules/@noble/hashes/esm/_sha2.js
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h2 = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h2, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
}
var SHA2 = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    assert_default.exists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    assert_default.exists(this);
    assert_default.output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos; i < blockLen; i++)
      buffer[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0; i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};

// ../../node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h: h2, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h2, l];
  }
  return [Ah, Al];
}
var toBig = (h2, l) => BigInt(h2 >>> 0) << _32n | BigInt(l >>> 0);
var shrSH = (h2, l, s2) => h2 >>> s2;
var shrSL = (h2, l, s2) => h2 << 32 - s2 | l >>> s2;
var rotrSH = (h2, l, s2) => h2 >>> s2 | l << 32 - s2;
var rotrSL = (h2, l, s2) => h2 << 32 - s2 | l >>> s2;
var rotrBH = (h2, l, s2) => h2 << 64 - s2 | l >>> s2 - 32;
var rotrBL = (h2, l, s2) => h2 >>> s2 - 32 | l << 64 - s2;
var rotr32H = (h2, l) => l;
var rotr32L = (h2, l) => h2;
var rotlSH = (h2, l, s2) => h2 << s2 | l >>> 32 - s2;
var rotlSL = (h2, l, s2) => l << s2 | h2 >>> 32 - s2;
var rotlBH = (h2, l, s2) => l << s2 - 32 | h2 >>> 64 - s2;
var rotlBL = (h2, l, s2) => h2 << s2 - 32 | l >>> 64 - s2;
function add(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
var u64_default = u64;

// ../../node_modules/@noble/hashes/esm/sha512.js
var [SHA512_Kh, SHA512_Kl] = u64_default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n) => BigInt(n)));
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);
var SHA512 = class extends SHA2 {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset2) {
    for (let i = 0; i < 16; i++, offset2 += 4) {
      SHA512_W_H[i] = view.getUint32(offset2);
      SHA512_W_L[i] = view.getUint32(offset2 += 4);
    }
    for (let i = 16; i < 80; i++) {
      const W15h = SHA512_W_H[i - 15] | 0;
      const W15l = SHA512_W_L[i - 15] | 0;
      const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
      const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i - 2] | 0;
      const W2l = SHA512_W_L[i - 2] | 0;
      const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
      const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
      const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
      const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
      SHA512_W_H[i] = SUMh | 0;
      SHA512_W_L[i] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i = 0; i < 80; i++) {
      const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);
      const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
      const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
      const T1l = T1ll | 0;
      const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);
      const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = u64_default.add3L(T1l, sigma0l, MAJl);
      Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var SHA512_224 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 2352822216 | 0;
    this.Al = 424955298 | 0;
    this.Bh = 1944164710 | 0;
    this.Bl = 2312950998 | 0;
    this.Ch = 502970286 | 0;
    this.Cl = 855612546 | 0;
    this.Dh = 1738396948 | 0;
    this.Dl = 1479516111 | 0;
    this.Eh = 258812777 | 0;
    this.El = 2077511080 | 0;
    this.Fh = 2011393907 | 0;
    this.Fl = 79989058 | 0;
    this.Gh = 1067287976 | 0;
    this.Gl = 1780299464 | 0;
    this.Hh = 286451373 | 0;
    this.Hl = 2446758561 | 0;
    this.outputLen = 28;
  }
};
var SHA512_256 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 573645204 | 0;
    this.Al = 4230739756 | 0;
    this.Bh = 2673172387 | 0;
    this.Bl = 3360449730 | 0;
    this.Ch = 596883563 | 0;
    this.Cl = 1867755857 | 0;
    this.Dh = 2520282905 | 0;
    this.Dl = 1497426621 | 0;
    this.Eh = 2519219938 | 0;
    this.El = 2827943907 | 0;
    this.Fh = 3193839141 | 0;
    this.Fl = 1401305490 | 0;
    this.Gh = 721525244 | 0;
    this.Gl = 746961066 | 0;
    this.Hh = 246885852 | 0;
    this.Hl = 2177182882 | 0;
    this.outputLen = 32;
  }
};
var SHA384 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 3418070365 | 0;
    this.Al = 3238371032 | 0;
    this.Bh = 1654270250 | 0;
    this.Bl = 914150663 | 0;
    this.Ch = 2438529370 | 0;
    this.Cl = 812702999 | 0;
    this.Dh = 355462360 | 0;
    this.Dl = 4144912697 | 0;
    this.Eh = 1731405415 | 0;
    this.El = 4290775857 | 0;
    this.Fh = 2394180231 | 0;
    this.Fl = 1750603025 | 0;
    this.Gh = 3675008525 | 0;
    this.Gl = 1694076839 | 0;
    this.Hh = 1203062813 | 0;
    this.Hl = 3204075428 | 0;
    this.outputLen = 48;
  }
};
var sha512 = wrapConstructor(() => new SHA512());
var sha512_224 = wrapConstructor(() => new SHA512_224());
var sha512_256 = wrapConstructor(() => new SHA512_256());
var sha384 = wrapConstructor(() => new SHA384());

// ../../node_modules/@noble/ed25519/lib/esm/index.js
import * as nodeCrypto from "crypto";
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _8n = BigInt(8);
var CU_O = BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989");
var CURVE = Object.freeze({
  a: BigInt(-1),
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  P: BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),
  l: CU_O,
  n: CU_O,
  h: BigInt(8),
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")
});
var POW_2_256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
var SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
var SQRT_D = BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742");
var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
var ExtendedPoint = class {
  constructor(x, y2, z2, t) {
    this.x = x;
    this.y = y2;
    this.z = z2;
    this.t = t;
  }
  static fromAffine(p) {
    if (!(p instanceof Point)) {
      throw new TypeError("ExtendedPoint#fromAffine: expected Point");
    }
    if (p.equals(Point.ZERO))
      return ExtendedPoint.ZERO;
    return new ExtendedPoint(p.x, p.y, _1n, mod(p.x * p.y));
  }
  static toAffineBatch(points) {
    const toInv = invertBatch(points.map((p) => p.z));
    return points.map((p, i) => p.toAffine(toInv[i]));
  }
  static normalizeZ(points) {
    return this.toAffineBatch(points).map(this.fromAffine);
  }
  equals(other) {
    assertExtPoint(other);
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X2, y: Y2, z: Z2 } = other;
    const X1Z2 = mod(X1 * Z2);
    const X2Z1 = mod(X2 * Z1);
    const Y1Z2 = mod(Y1 * Z2);
    const Y2Z1 = mod(Y2 * Z1);
    return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
  }
  negate() {
    return new ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t));
  }
  double() {
    const { x: X1, y: Y1, z: Z1 } = this;
    const { a } = CURVE;
    const A = mod(X1 * X1);
    const B = mod(Y1 * Y1);
    const C = mod(_2n * mod(Z1 * Z1));
    const D = mod(a * A);
    const x1y1 = X1 + Y1;
    const E = mod(mod(x1y1 * x1y1) - A - B);
    const G = D + B;
    const F = G - C;
    const H = D - B;
    const X3 = mod(E * F);
    const Y3 = mod(G * H);
    const T3 = mod(E * H);
    const Z3 = mod(F * G);
    return new ExtendedPoint(X3, Y3, Z3, T3);
  }
  add(other) {
    assertExtPoint(other);
    const { x: X1, y: Y1, z: Z1, t: T1 } = this;
    const { x: X2, y: Y2, z: Z2, t: T2 } = other;
    const A = mod((Y1 - X1) * (Y2 + X2));
    const B = mod((Y1 + X1) * (Y2 - X2));
    const F = mod(B - A);
    if (F === _0n)
      return this.double();
    const C = mod(Z1 * _2n * T2);
    const D = mod(T1 * _2n * Z2);
    const E = D + C;
    const G = B + A;
    const H = D - C;
    const X3 = mod(E * F);
    const Y3 = mod(G * H);
    const T3 = mod(E * H);
    const Z3 = mod(F * G);
    return new ExtendedPoint(X3, Y3, Z3, T3);
  }
  subtract(other) {
    return this.add(other.negate());
  }
  precomputeWindow(W) {
    const windows = 1 + 256 / W;
    const points = [];
    let p = this;
    let base = p;
    for (let window2 = 0; window2 < windows; window2++) {
      base = p;
      points.push(base);
      for (let i = 1; i < 2 ** (W - 1); i++) {
        base = base.add(p);
        points.push(base);
      }
      p = base.double();
    }
    return points;
  }
  wNAF(n, affinePoint) {
    if (!affinePoint && this.equals(ExtendedPoint.BASE))
      affinePoint = Point.BASE;
    const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
    if (256 % W) {
      throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
    }
    let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
    if (!precomputes) {
      precomputes = this.precomputeWindow(W);
      if (affinePoint && W !== 1) {
        precomputes = ExtendedPoint.normalizeZ(precomputes);
        pointPrecomputes.set(affinePoint, precomputes);
      }
    }
    let p = ExtendedPoint.ZERO;
    let f = ExtendedPoint.BASE;
    const windows = 1 + 256 / W;
    const windowSize = 2 ** (W - 1);
    const mask2 = BigInt(2 ** W - 1);
    const maxNumber = 2 ** W;
    const shiftBy = BigInt(W);
    for (let window2 = 0; window2 < windows; window2++) {
      const offset2 = window2 * windowSize;
      let wbits = Number(n & mask2);
      n >>= shiftBy;
      if (wbits > windowSize) {
        wbits -= maxNumber;
        n += _1n;
      }
      const offset1 = offset2;
      const offset22 = offset2 + Math.abs(wbits) - 1;
      const cond1 = window2 % 2 !== 0;
      const cond2 = wbits < 0;
      if (wbits === 0) {
        f = f.add(constTimeNegate(cond1, precomputes[offset1]));
      } else {
        p = p.add(constTimeNegate(cond2, precomputes[offset22]));
      }
    }
    return ExtendedPoint.normalizeZ([p, f])[0];
  }
  multiply(scalar, affinePoint) {
    return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);
  }
  multiplyUnsafe(scalar) {
    let n = normalizeScalar(scalar, CURVE.l, false);
    const G = ExtendedPoint.BASE;
    const P0 = ExtendedPoint.ZERO;
    if (n === _0n)
      return P0;
    if (this.equals(P0) || n === _1n)
      return this;
    if (this.equals(G))
      return this.wNAF(n);
    let p = P0;
    let d2 = this;
    while (n > _0n) {
      if (n & _1n)
        p = p.add(d2);
      d2 = d2.double();
      n >>= _1n;
    }
    return p;
  }
  isSmallOrder() {
    return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);
  }
  isTorsionFree() {
    let p = this.multiplyUnsafe(CURVE.l / _2n).double();
    if (CURVE.l % _2n)
      p = p.add(this);
    return p.equals(ExtendedPoint.ZERO);
  }
  toAffine(invZ) {
    const { x, y: y2, z: z2 } = this;
    const is0 = this.equals(ExtendedPoint.ZERO);
    if (invZ == null)
      invZ = is0 ? _8n : invert(z2);
    const ax = mod(x * invZ);
    const ay = mod(y2 * invZ);
    const zz = mod(z2 * invZ);
    if (is0)
      return Point.ZERO;
    if (zz !== _1n)
      throw new Error("invZ was invalid");
    return new Point(ax, ay);
  }
  fromRistrettoBytes() {
    legacyRist();
  }
  toRistrettoBytes() {
    legacyRist();
  }
  fromRistrettoHash() {
    legacyRist();
  }
};
ExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod(CURVE.Gx * CURVE.Gy));
ExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);
function constTimeNegate(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
function assertExtPoint(other) {
  if (!(other instanceof ExtendedPoint))
    throw new TypeError("ExtendedPoint expected");
}
function assertRstPoint(other) {
  if (!(other instanceof RistrettoPoint))
    throw new TypeError("RistrettoPoint expected");
}
function legacyRist() {
  throw new Error("Legacy method: switch to RistrettoPoint");
}
var RistrettoPoint = class {
  constructor(ep) {
    this.ep = ep;
  }
  static calcElligatorRistrettoMap(r0) {
    const { d: d2 } = CURVE;
    const r = mod(SQRT_M1 * r0 * r0);
    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);
    let c = BigInt(-1);
    const D = mod((c - d2 * r) * mod(r + d2));
    let { isValid: Ns_D_is_sq, value: s2 } = uvRatio(Ns, D);
    let s_ = mod(s2 * r0);
    if (!edIsNegative(s_))
      s_ = mod(-s_);
    if (!Ns_D_is_sq)
      s2 = s_;
    if (!Ns_D_is_sq)
      c = r;
    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);
    const s22 = s2 * s2;
    const W0 = mod((s2 + s2) * D);
    const W1 = mod(Nt * SQRT_AD_MINUS_ONE);
    const W2 = mod(_1n - s22);
    const W3 = mod(_1n + s22);
    return new ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
  }
  static hashToCurve(hex) {
    hex = ensureBytes(hex, 64);
    const r1 = bytes255ToNumberLE(hex.slice(0, 32));
    const R1 = this.calcElligatorRistrettoMap(r1);
    const r2 = bytes255ToNumberLE(hex.slice(32, 64));
    const R2 = this.calcElligatorRistrettoMap(r2);
    return new RistrettoPoint(R1.add(R2));
  }
  static fromHex(hex) {
    hex = ensureBytes(hex, 32);
    const { a, d: d2 } = CURVE;
    const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
    const s2 = bytes255ToNumberLE(hex);
    if (!equalBytes(numberTo32BytesLE(s2), hex) || edIsNegative(s2))
      throw new Error(emsg);
    const s22 = mod(s2 * s2);
    const u1 = mod(_1n + a * s22);
    const u2 = mod(_1n - a * s22);
    const u1_2 = mod(u1 * u1);
    const u2_2 = mod(u2 * u2);
    const v = mod(a * d2 * u1_2 - u2_2);
    const { isValid, value: I } = invertSqrt(mod(v * u2_2));
    const Dx = mod(I * u2);
    const Dy = mod(I * Dx * v);
    let x = mod((s2 + s2) * Dx);
    if (edIsNegative(x))
      x = mod(-x);
    const y2 = mod(u1 * Dy);
    const t = mod(x * y2);
    if (!isValid || edIsNegative(t) || y2 === _0n)
      throw new Error(emsg);
    return new RistrettoPoint(new ExtendedPoint(x, y2, _1n, t));
  }
  toRawBytes() {
    let { x, y: y2, z: z2, t } = this.ep;
    const u1 = mod(mod(z2 + y2) * mod(z2 - y2));
    const u2 = mod(x * y2);
    const u2sq = mod(u2 * u2);
    const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));
    const D1 = mod(invsqrt * u1);
    const D2 = mod(invsqrt * u2);
    const zInv = mod(D1 * D2 * t);
    let D;
    if (edIsNegative(t * zInv)) {
      let _x = mod(y2 * SQRT_M1);
      let _y = mod(x * SQRT_M1);
      x = _x;
      y2 = _y;
      D = mod(D1 * INVSQRT_A_MINUS_D);
    } else {
      D = D2;
    }
    if (edIsNegative(x * zInv))
      y2 = mod(-y2);
    let s2 = mod((z2 - y2) * D);
    if (edIsNegative(s2))
      s2 = mod(-s2);
    return numberTo32BytesLE(s2);
  }
  toHex() {
    return bytesToHex(this.toRawBytes());
  }
  toString() {
    return this.toHex();
  }
  equals(other) {
    assertRstPoint(other);
    const a = this.ep;
    const b = other.ep;
    const one = mod(a.x * b.y) === mod(a.y * b.x);
    const two = mod(a.y * b.y) === mod(a.x * b.x);
    return one || two;
  }
  add(other) {
    assertRstPoint(other);
    return new RistrettoPoint(this.ep.add(other.ep));
  }
  subtract(other) {
    assertRstPoint(other);
    return new RistrettoPoint(this.ep.subtract(other.ep));
  }
  multiply(scalar) {
    return new RistrettoPoint(this.ep.multiply(scalar));
  }
  multiplyUnsafe(scalar) {
    return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));
  }
};
RistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);
RistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);
var pointPrecomputes = /* @__PURE__ */ new WeakMap();
var Point = class {
  constructor(x, y2) {
    this.x = x;
    this.y = y2;
  }
  _setWindowSize(windowSize) {
    this._WINDOW_SIZE = windowSize;
    pointPrecomputes.delete(this);
  }
  static fromHex(hex, strict = true) {
    const { d: d2, P } = CURVE;
    hex = ensureBytes(hex, 32);
    const normed = hex.slice();
    normed[31] = hex[31] & ~128;
    const y2 = bytesToNumberLE(normed);
    if (strict && y2 >= P)
      throw new Error("Expected 0 < hex < P");
    if (!strict && y2 >= POW_2_256)
      throw new Error("Expected 0 < hex < 2**256");
    const y22 = mod(y2 * y2);
    const u = mod(y22 - _1n);
    const v = mod(d2 * y22 + _1n);
    let { isValid, value: x } = uvRatio(u, v);
    if (!isValid)
      throw new Error("Point.fromHex: invalid y coordinate");
    const isXOdd = (x & _1n) === _1n;
    const isLastByteOdd = (hex[31] & 128) !== 0;
    if (isLastByteOdd !== isXOdd) {
      x = mod(-x);
    }
    return new Point(x, y2);
  }
  static fromPrivateKey(privateKey) {
    return __async(this, null, function* () {
      return (yield getExtendedPublicKey(privateKey)).point;
    });
  }
  toRawBytes() {
    const bytes2 = numberTo32BytesLE(this.y);
    bytes2[31] |= this.x & _1n ? 128 : 0;
    return bytes2;
  }
  toHex() {
    return bytesToHex(this.toRawBytes());
  }
  toX25519() {
    const { y: y2 } = this;
    const u = mod((_1n + y2) * invert(_1n - y2));
    return numberTo32BytesLE(u);
  }
  isTorsionFree() {
    return ExtendedPoint.fromAffine(this).isTorsionFree();
  }
  equals(other) {
    return this.x === other.x && this.y === other.y;
  }
  negate() {
    return new Point(mod(-this.x), this.y);
  }
  add(other) {
    return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiply(scalar) {
    return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();
  }
};
Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
Point.ZERO = new Point(_0n, _1n);
var Signature = class {
  constructor(r, s2) {
    this.r = r;
    this.s = s2;
    this.assertValidity();
  }
  static fromHex(hex) {
    const bytes2 = ensureBytes(hex, 64);
    const r = Point.fromHex(bytes2.slice(0, 32), false);
    const s2 = bytesToNumberLE(bytes2.slice(32, 64));
    return new Signature(r, s2);
  }
  assertValidity() {
    const { r, s: s2 } = this;
    if (!(r instanceof Point))
      throw new Error("Expected Point instance");
    normalizeScalar(s2, CURVE.l, false);
    return this;
  }
  toRawBytes() {
    const u87 = new Uint8Array(64);
    u87.set(this.r.toRawBytes());
    u87.set(numberTo32BytesLE(this.s), 32);
    return u87;
  }
  toHex() {
    return bytesToHex(this.toRawBytes());
  }
};
function concatBytes(...arrays) {
  if (!arrays.every((a) => a instanceof Uint8Array))
    throw new Error("Expected Uint8Array list");
  if (arrays.length === 1)
    return arrays[0];
  const length = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const arr = arrays[i];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
var hexes2 = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
function bytesToHex(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i = 0; i < uint8a.length; i++) {
    hex += hexes2[uint8a[i]];
  }
  return hex;
}
function hexToBytes(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex);
  }
  if (hex.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex");
  const array2 = new Uint8Array(hex.length / 2);
  for (let i = 0; i < array2.length; i++) {
    const j = i * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array2[i] = byte;
  }
  return array2;
}
function numberTo32BytesBE(num) {
  const length = 32;
  const hex = num.toString(16).padStart(length * 2, "0");
  return hexToBytes(hex);
}
function numberTo32BytesLE(num) {
  return numberTo32BytesBE(num).reverse();
}
function edIsNegative(num) {
  return (mod(num) & _1n) === _1n;
}
function bytesToNumberLE(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  return BigInt("0x" + bytesToHex(Uint8Array.from(uint8a).reverse()));
}
var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function bytes255ToNumberLE(bytes2) {
  return mod(bytesToNumberLE(bytes2) & MAX_255B);
}
function mod(a, b = CURVE.P) {
  const res = a % b;
  return res >= _0n ? res : b + res;
}
function invert(number3, modulo = CURVE.P) {
  if (number3 === _0n || modulo <= _0n) {
    throw new Error(`invert: expected positive integers, got n=${number3} mod=${modulo}`);
  }
  let a = mod(number3, modulo);
  let b = modulo;
  let x = _0n, y2 = _1n, u = _1n, v = _0n;
  while (a !== _0n) {
    const q = b / a;
    const r = b % a;
    const m2 = x - u * q;
    const n = y2 - v * q;
    b = a, a = r, x = u, y2 = v, u = m2, v = n;
  }
  const gcd = b;
  if (gcd !== _1n)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function invertBatch(nums, p = CURVE.P) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (num === _0n)
      return acc;
    tmp[i] = acc;
    return mod(acc * num, p);
  }, _1n);
  const inverted = invert(lastMultiplied, p);
  nums.reduceRight((acc, num, i) => {
    if (num === _0n)
      return acc;
    tmp[i] = mod(acc * tmp[i], p);
    return mod(acc * num, p);
  }, inverted);
  return tmp;
}
function pow2(x, power) {
  const { P } = CURVE;
  let res = x;
  while (power-- > _0n) {
    res *= res;
    res %= P;
  }
  return res;
}
function pow_2_252_3(x) {
  const { P } = CURVE;
  const _5n = BigInt(5);
  const _10n = BigInt(10);
  const _20n = BigInt(20);
  const _40n = BigInt(40);
  const _80n = BigInt(80);
  const x2 = x * x % P;
  const b2 = x2 * x % P;
  const b4 = pow2(b2, _2n) * b2 % P;
  const b5 = pow2(b4, _1n) * x % P;
  const b10 = pow2(b5, _5n) * b5 % P;
  const b20 = pow2(b10, _10n) * b10 % P;
  const b40 = pow2(b20, _20n) * b20 % P;
  const b80 = pow2(b40, _40n) * b40 % P;
  const b160 = pow2(b80, _80n) * b80 % P;
  const b240 = pow2(b160, _80n) * b80 % P;
  const b250 = pow2(b240, _10n) * b10 % P;
  const pow_p_5_8 = pow2(b250, _2n) * x % P;
  return { pow_p_5_8, b2 };
}
function uvRatio(u, v) {
  const v32 = mod(v * v * v);
  const v7 = mod(v32 * v32 * v);
  const pow = pow_2_252_3(u * v7).pow_p_5_8;
  let x = mod(u * v32 * pow);
  const vx2 = mod(v * x * x);
  const root1 = x;
  const root2 = mod(x * SQRT_M1);
  const useRoot1 = vx2 === u;
  const useRoot2 = vx2 === mod(-u);
  const noRoot = vx2 === mod(-u * SQRT_M1);
  if (useRoot1)
    x = root1;
  if (useRoot2 || noRoot)
    x = root2;
  if (edIsNegative(x))
    x = mod(-x);
  return { isValid: useRoot1 || useRoot2, value: x };
}
function invertSqrt(number3) {
  return uvRatio(_1n, number3);
}
function modlLE(hash2) {
  return mod(bytesToNumberLE(hash2), CURVE.l);
}
function equalBytes(b1, b2) {
  if (b1.length !== b2.length) {
    return false;
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] !== b2[i]) {
      return false;
    }
  }
  return true;
}
function ensureBytes(hex, expectedLength) {
  const bytes2 = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
  if (typeof expectedLength === "number" && bytes2.length !== expectedLength)
    throw new Error(`Expected ${expectedLength} bytes`);
  return bytes2;
}
function normalizeScalar(num, max, strict = true) {
  if (!max)
    throw new TypeError("Specify max value");
  if (typeof num === "number" && Number.isSafeInteger(num))
    num = BigInt(num);
  if (typeof num === "bigint" && num < max) {
    if (strict) {
      if (_0n < num)
        return num;
    } else {
      if (_0n <= num)
        return num;
    }
  }
  throw new TypeError("Expected valid scalar: 0 < scalar < max");
}
function adjustBytes25519(bytes2) {
  bytes2[0] &= 248;
  bytes2[31] &= 127;
  bytes2[31] |= 64;
  return bytes2;
}
function checkPrivateKey(key) {
  key = typeof key === "bigint" || typeof key === "number" ? numberTo32BytesBE(normalizeScalar(key, POW_2_256)) : ensureBytes(key);
  if (key.length !== 32)
    throw new Error(`Expected 32 bytes`);
  return key;
}
function getKeyFromHash(hashed) {
  const head = adjustBytes25519(hashed.slice(0, 32));
  const prefix = hashed.slice(32, 64);
  const scalar = modlLE(head);
  const point = Point.BASE.multiply(scalar);
  const pointBytes = point.toRawBytes();
  return { head, prefix, scalar, point, pointBytes };
}
var _sha512Sync;
function sha512s(...m2) {
  if (typeof _sha512Sync !== "function")
    throw new Error("utils.sha512Sync must be set to use sync methods");
  return _sha512Sync(...m2);
}
function getExtendedPublicKey(key) {
  return __async(this, null, function* () {
    return getKeyFromHash(yield utils.sha512(checkPrivateKey(key)));
  });
}
function getExtendedPublicKeySync(key) {
  return getKeyFromHash(sha512s(checkPrivateKey(key)));
}
function getPublicKeySync(privateKey) {
  return getExtendedPublicKeySync(privateKey).pointBytes;
}
function signSync(message2, privateKey) {
  message2 = ensureBytes(message2);
  const { prefix, scalar, pointBytes } = getExtendedPublicKeySync(privateKey);
  const r = modlLE(sha512s(prefix, message2));
  const R = Point.BASE.multiply(r);
  const k = modlLE(sha512s(R.toRawBytes(), pointBytes, message2));
  const s2 = mod(r + k * scalar, CURVE.l);
  return new Signature(R, s2).toRawBytes();
}
function prepareVerification(sig, message2, publicKey3) {
  message2 = ensureBytes(message2);
  if (!(publicKey3 instanceof Point))
    publicKey3 = Point.fromHex(publicKey3, false);
  const { r, s: s2 } = sig instanceof Signature ? sig.assertValidity() : Signature.fromHex(sig);
  const SB = ExtendedPoint.BASE.multiplyUnsafe(s2);
  return { r, s: s2, SB, pub: publicKey3, msg: message2 };
}
function finishVerification(publicKey3, r, SB, hashed) {
  const k = modlLE(hashed);
  const kA = ExtendedPoint.fromAffine(publicKey3).multiplyUnsafe(k);
  const RkA = ExtendedPoint.fromAffine(r).add(kA);
  return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);
}
function verifySync(sig, message2, publicKey3) {
  const { r, SB, msg, pub } = prepareVerification(sig, message2, publicKey3);
  const hashed = sha512s(r.toRawBytes(), pub.toRawBytes(), msg);
  return finishVerification(pub, r, SB, hashed);
}
var sync = {
  getExtendedPublicKey: getExtendedPublicKeySync,
  getPublicKey: getPublicKeySync,
  sign: signSync,
  verify: verifySync
};
Point.BASE._setWindowSize(8);
var crypto3 = {
  node: nodeCrypto,
  web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
};
var utils = {
  bytesToHex,
  hexToBytes,
  concatBytes,
  getExtendedPublicKey,
  mod,
  invert,
  TORSION_SUBGROUP: [
    "0100000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
    "0000000000000000000000000000000000000000000000000000000000000080",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
    "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
    "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
    "0000000000000000000000000000000000000000000000000000000000000000",
    "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
  ],
  hashToPrivateScalar: (hash2) => {
    hash2 = ensureBytes(hash2);
    if (hash2.length < 40 || hash2.length > 1024)
      throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");
    return mod(bytesToNumberLE(hash2), CURVE.l - _1n) + _1n;
  },
  randomBytes: (bytesLength = 32) => {
    if (crypto3.web) {
      return crypto3.web.getRandomValues(new Uint8Array(bytesLength));
    } else if (crypto3.node) {
      const { randomBytes } = crypto3.node;
      return new Uint8Array(randomBytes(bytesLength).buffer);
    } else {
      throw new Error("The environment doesn't have randomBytes function");
    }
  },
  randomPrivateKey: () => {
    return utils.randomBytes(32);
  },
  sha512: (...messages) => __async(void 0, null, function* () {
    const message2 = concatBytes(...messages);
    if (crypto3.web) {
      const buffer = yield crypto3.web.subtle.digest("SHA-512", message2.buffer);
      return new Uint8Array(buffer);
    } else if (crypto3.node) {
      return Uint8Array.from(crypto3.node.createHash("sha512").update(message2).digest());
    } else {
      throw new Error("The environment doesn't have sha512 function");
    }
  }),
  precompute(windowSize = 8, point = Point.BASE) {
    const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);
    cached._setWindowSize(windowSize);
    cached.multiply(_2n);
    return cached;
  },
  sha512Sync: void 0
};
Object.defineProperties(utils, {
  sha512Sync: {
    configurable: false,
    get() {
      return _sha512Sync;
    },
    set(val) {
      if (!_sha512Sync)
        _sha512Sync = val;
    }
  }
});

// ../../node_modules/@solana/web3.js/lib/index.esm.js
var import_bn = __toESM(require_bn());
var import_bs58 = __toESM(require_bs58());

// ../../node_modules/@noble/hashes/esm/sha256.js
var Chi = (a, b, c) => a & b ^ ~a & c;
var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset2) {
    for (let i = 0; i < 16; i++, offset2 += 4)
      SHA256_W[i] = view.getUint32(offset2, false);
    for (let i = 16; i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0; i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha256 = wrapConstructor(() => new SHA256());
var sha224 = wrapConstructor(() => new SHA224());

// ../../node_modules/@solana/web3.js/lib/index.esm.js
var import_borsh = __toESM(require_lib());
var BufferLayout = __toESM(require_Layout());
var import_buffer_layout = __toESM(require_Layout());
var import_bigint_buffer = __toESM(require_node());
import require$$0$1 from "tty";
import require$$0 from "util";
import require$$0$2 from "events";
import require$$1 from "path";
import require$$0$3 from "http";
import require$$0$4, { Agent as Agent$1 } from "https";

// ../../node_modules/@solana/web3.js/node_modules/superstruct/lib/index.es.js
var StructError = class extends TypeError {
  constructor(failure, failures) {
    let cached;
    const _a = failure, {
      message: message2
    } = _a, rest = __objRest(_a, [
      "message"
    ]);
    const {
      path
    } = failure;
    const msg = path.length === 0 ? message2 : "At path: " + path.join(".") + " -- " + message2;
    super(msg);
    Object.assign(this, rest);
    this.name = this.constructor.name;
    this.failures = () => {
      var _cached;
      return (_cached = cached) != null ? _cached : cached = [failure, ...failures()];
    };
  }
};
function isIterable(x) {
  return isObject(x) && typeof x[Symbol.iterator] === "function";
}
function isObject(x) {
  return typeof x === "object" && x != null;
}
function print(value) {
  return typeof value === "string" ? JSON.stringify(value) : "" + value;
}
function shiftIterator(input) {
  const {
    done,
    value
  } = input.next();
  return done ? void 0 : value;
}
function toFailure(result, context, struct6, value) {
  if (result === true) {
    return;
  } else if (result === false) {
    result = {};
  } else if (typeof result === "string") {
    result = {
      message: result
    };
  }
  const {
    path,
    branch
  } = context;
  const {
    type: type2
  } = struct6;
  const {
    refinement,
    message: message2 = "Expected a value of type `" + type2 + "`" + (refinement ? " with refinement `" + refinement + "`" : "") + ", but received: `" + print(value) + "`"
  } = result;
  return __spreadProps(__spreadValues({
    value,
    type: type2,
    refinement,
    key: path[path.length - 1],
    path,
    branch
  }, result), {
    message: message2
  });
}
function* toFailures(result, context, struct6, value) {
  if (!isIterable(result)) {
    result = [result];
  }
  for (const r of result) {
    const failure = toFailure(r, context, struct6, value);
    if (failure) {
      yield failure;
    }
  }
}
function* run(value, struct6, options = {}) {
  const {
    path = [],
    branch = [value],
    coerce: coerce2 = false,
    mask: mask2 = false
  } = options;
  const ctx = {
    path,
    branch
  };
  if (coerce2) {
    value = struct6.coercer(value, ctx);
    if (mask2 && struct6.type !== "type" && isObject(struct6.schema) && isObject(value) && !Array.isArray(value)) {
      for (const key in value) {
        if (struct6.schema[key] === void 0) {
          delete value[key];
        }
      }
    }
  }
  let valid = true;
  for (const failure of struct6.validator(value, ctx)) {
    valid = false;
    yield [failure, void 0];
  }
  for (let [k, v, s2] of struct6.entries(value, ctx)) {
    const ts = run(v, s2, {
      path: k === void 0 ? path : [...path, k],
      branch: k === void 0 ? branch : [...branch, v],
      coerce: coerce2,
      mask: mask2
    });
    for (const t of ts) {
      if (t[0]) {
        valid = false;
        yield [t[0], void 0];
      } else if (coerce2) {
        v = t[1];
        if (k === void 0) {
          value = v;
        } else if (value instanceof Map) {
          value.set(k, v);
        } else if (value instanceof Set) {
          value.add(v);
        } else if (isObject(value)) {
          value[k] = v;
        }
      }
    }
  }
  if (valid) {
    for (const failure of struct6.refiner(value, ctx)) {
      valid = false;
      yield [failure, void 0];
    }
  }
  if (valid) {
    yield [void 0, value];
  }
}
var Struct = class {
  constructor(props) {
    const {
      type: type2,
      schema,
      validator,
      refiner,
      coercer = (value) => value,
      entries = function* () {
      }
    } = props;
    this.type = type2;
    this.schema = schema;
    this.entries = entries;
    this.coercer = coercer;
    if (validator) {
      this.validator = (value, context) => {
        const result = validator(value, context);
        return toFailures(result, context, this, value);
      };
    } else {
      this.validator = () => [];
    }
    if (refiner) {
      this.refiner = (value, context) => {
        const result = refiner(value, context);
        return toFailures(result, context, this, value);
      };
    } else {
      this.refiner = () => [];
    }
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(value) {
    return assert2(value, this);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(value) {
    return create(value, this);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(value) {
    return is(value, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema.
   */
  mask(value) {
    return mask(value, this);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `withCoercion` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful.
   */
  validate(value, options = {}) {
    return validate(value, this, options);
  }
};
function assert2(value, struct6) {
  const result = validate(value, struct6);
  if (result[0]) {
    throw result[0];
  }
}
function create(value, struct6) {
  const result = validate(value, struct6, {
    coerce: true
  });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function mask(value, struct6) {
  const result = validate(value, struct6, {
    coerce: true,
    mask: true
  });
  if (result[0]) {
    throw result[0];
  } else {
    return result[1];
  }
}
function is(value, struct6) {
  const result = validate(value, struct6);
  return !result[0];
}
function validate(value, struct6, options = {}) {
  const tuples = run(value, struct6, options);
  const tuple2 = shiftIterator(tuples);
  if (tuple2[0]) {
    const error = new StructError(tuple2[0], function* () {
      for (const t of tuples) {
        if (t[0]) {
          yield t[0];
        }
      }
    });
    return [error, void 0];
  } else {
    const v = tuple2[1];
    return [void 0, v];
  }
}
function define(name, validator) {
  return new Struct({
    type: name,
    schema: null,
    validator
  });
}
function any() {
  return define("any", () => true);
}
function array(Element) {
  return new Struct({
    type: "array",
    schema: Element,
    *entries(value) {
      if (Element && Array.isArray(value)) {
        for (const [i, v] of value.entries()) {
          yield [i, v, Element];
        }
      }
    },
    coercer(value) {
      return Array.isArray(value) ? value.slice() : value;
    },
    validator(value) {
      return Array.isArray(value) || "Expected an array value, but received: " + print(value);
    }
  });
}
function boolean() {
  return define("boolean", (value) => {
    return typeof value === "boolean";
  });
}
function instance(Class) {
  return define("instance", (value) => {
    return value instanceof Class || "Expected a `" + Class.name + "` instance, but received: " + print(value);
  });
}
function literal(constant) {
  const description = print(constant);
  const t = typeof constant;
  return new Struct({
    type: "literal",
    schema: t === "string" || t === "number" || t === "boolean" ? constant : null,
    validator(value) {
      return value === constant || "Expected the literal `" + description + "`, but received: " + print(value);
    }
  });
}
function never() {
  return define("never", () => false);
}
function nullable(struct6) {
  return new Struct(__spreadProps(__spreadValues({}, struct6), {
    validator: (value, ctx) => value === null || struct6.validator(value, ctx),
    refiner: (value, ctx) => value === null || struct6.refiner(value, ctx)
  }));
}
function number2() {
  return define("number", (value) => {
    return typeof value === "number" && !isNaN(value) || "Expected a number, but received: " + print(value);
  });
}
function optional(struct6) {
  return new Struct(__spreadProps(__spreadValues({}, struct6), {
    validator: (value, ctx) => value === void 0 || struct6.validator(value, ctx),
    refiner: (value, ctx) => value === void 0 || struct6.refiner(value, ctx)
  }));
}
function record(Key, Value) {
  return new Struct({
    type: "record",
    schema: null,
    *entries(value) {
      if (isObject(value)) {
        for (const k in value) {
          const v = value[k];
          yield [k, k, Key];
          yield [k, v, Value];
        }
      }
    },
    validator(value) {
      return isObject(value) || "Expected an object, but received: " + print(value);
    }
  });
}
function string() {
  return define("string", (value) => {
    return typeof value === "string" || "Expected a string, but received: " + print(value);
  });
}
function tuple(Elements) {
  const Never = never();
  return new Struct({
    type: "tuple",
    schema: null,
    *entries(value) {
      if (Array.isArray(value)) {
        const length = Math.max(Elements.length, value.length);
        for (let i = 0; i < length; i++) {
          yield [i, value[i], Elements[i] || Never];
        }
      }
    },
    validator(value) {
      return Array.isArray(value) || "Expected an array, but received: " + print(value);
    }
  });
}
function type(schema) {
  const keys = Object.keys(schema);
  return new Struct({
    type: "type",
    schema,
    *entries(value) {
      if (isObject(value)) {
        for (const k of keys) {
          yield [k, value[k], schema[k]];
        }
      }
    },
    validator(value) {
      return isObject(value) || "Expected an object, but received: " + print(value);
    }
  });
}
function union(Structs) {
  const description = Structs.map((s2) => s2.type).join(" | ");
  return new Struct({
    type: "union",
    schema: null,
    validator(value, ctx) {
      const failures = [];
      for (const S of Structs) {
        const [...tuples] = run(value, S, ctx);
        const [first] = tuples;
        if (!first[0]) {
          return [];
        } else {
          for (const [failure] of tuples) {
            if (failure) {
              failures.push(failure);
            }
          }
        }
      }
      return ["Expected the value to satisfy a union of `" + description + "`, but received: " + print(value), ...failures];
    }
  });
}
function unknown() {
  return define("unknown", () => true);
}
function coerce(struct6, condition, coercer) {
  return new Struct(__spreadProps(__spreadValues({}, struct6), {
    coercer: (value, ctx) => {
      return is(value, condition) ? struct6.coercer(coercer(value, ctx), ctx) : struct6.coercer(value, ctx);
    }
  }));
}

// ../../node_modules/@solana/web3.js/lib/index.esm.js
var import_browser = __toESM(require_browser());

// ../../node_modules/node-fetch/lib/index.mjs
var import_whatwg_url = __toESM(require_public_api(), 1);
import Stream from "stream";
import http from "http";
import Url from "url";
import https from "https";
import zlib from "zlib";
var Readable = Stream.Readable;
var BUFFER = Symbol("buffer");
var TYPE = Symbol("type");
var Blob = class {
  constructor() {
    this[TYPE] = "";
    const blobParts = arguments[0];
    const options = arguments[1];
    const buffers = [];
    let size = 0;
    if (blobParts) {
      const a = blobParts;
      const length = Number(a.length);
      for (let i = 0; i < length; i++) {
        const element = a[i];
        let buffer;
        if (element instanceof Buffer) {
          buffer = element;
        } else if (ArrayBuffer.isView(element)) {
          buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
        } else if (element instanceof ArrayBuffer) {
          buffer = Buffer.from(element);
        } else if (element instanceof Blob) {
          buffer = element[BUFFER];
        } else {
          buffer = Buffer.from(typeof element === "string" ? element : String(element));
        }
        size += buffer.length;
        buffers.push(buffer);
      }
    }
    this[BUFFER] = Buffer.concat(buffers);
    let type2 = options && options.type !== void 0 && String(options.type).toLowerCase();
    if (type2 && !/[^\u0020-\u007E]/.test(type2)) {
      this[TYPE] = type2;
    }
  }
  get size() {
    return this[BUFFER].length;
  }
  get type() {
    return this[TYPE];
  }
  text() {
    return Promise.resolve(this[BUFFER].toString());
  }
  arrayBuffer() {
    const buf = this[BUFFER];
    const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    return Promise.resolve(ab);
  }
  stream() {
    const readable = new Readable();
    readable._read = function() {
    };
    readable.push(this[BUFFER]);
    readable.push(null);
    return readable;
  }
  toString() {
    return "[object Blob]";
  }
  slice() {
    const size = this.size;
    const start = arguments[0];
    const end = arguments[1];
    let relativeStart, relativeEnd;
    if (start === void 0) {
      relativeStart = 0;
    } else if (start < 0) {
      relativeStart = Math.max(size + start, 0);
    } else {
      relativeStart = Math.min(start, size);
    }
    if (end === void 0) {
      relativeEnd = size;
    } else if (end < 0) {
      relativeEnd = Math.max(size + end, 0);
    } else {
      relativeEnd = Math.min(end, size);
    }
    const span = Math.max(relativeEnd - relativeStart, 0);
    const buffer = this[BUFFER];
    const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
    const blob5 = new Blob([], { type: arguments[2] });
    blob5[BUFFER] = slicedBuffer;
    return blob5;
  }
};
Object.defineProperties(Blob.prototype, {
  size: { enumerable: true },
  type: { enumerable: true },
  slice: { enumerable: true }
});
Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
  value: "Blob",
  writable: false,
  enumerable: false,
  configurable: true
});
function FetchError(message2, type2, systemError) {
  Error.call(this, message2);
  this.message = message2;
  this.type = type2;
  if (systemError) {
    this.code = this.errno = systemError.code;
  }
  Error.captureStackTrace(this, this.constructor);
}
FetchError.prototype = Object.create(Error.prototype);
FetchError.prototype.constructor = FetchError;
FetchError.prototype.name = "FetchError";
var convert;
try {
  convert = __require("encoding").convert;
} catch (e) {
}
var INTERNALS = Symbol("Body internals");
var PassThrough = Stream.PassThrough;
function Body(body) {
  var _this = this;
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
  let size = _ref$size === void 0 ? 0 : _ref$size;
  var _ref$timeout = _ref.timeout;
  let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
  if (body == null) {
    body = null;
  } else if (isURLSearchParams(body)) {
    body = Buffer.from(body.toString());
  } else if (isBlob(body))
    ;
  else if (Buffer.isBuffer(body))
    ;
  else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
    body = Buffer.from(body);
  } else if (ArrayBuffer.isView(body)) {
    body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
  } else if (body instanceof Stream)
    ;
  else {
    body = Buffer.from(String(body));
  }
  this[INTERNALS] = {
    body,
    disturbed: false,
    error: null
  };
  this.size = size;
  this.timeout = timeout;
  if (body instanceof Stream) {
    body.on("error", function(err) {
      const error = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
      _this[INTERNALS].error = error;
    });
  }
}
Body.prototype = {
  get body() {
    return this[INTERNALS].body;
  },
  get bodyUsed() {
    return this[INTERNALS].disturbed;
  },
  /**
   * Decode response as ArrayBuffer
   *
   * @return  Promise
   */
  arrayBuffer() {
    return consumeBody.call(this).then(function(buf) {
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    });
  },
  /**
   * Return raw response as Blob
   *
   * @return Promise
   */
  blob() {
    let ct = this.headers && this.headers.get("content-type") || "";
    return consumeBody.call(this).then(function(buf) {
      return Object.assign(
        // Prevent copying
        new Blob([], {
          type: ct.toLowerCase()
        }),
        {
          [BUFFER]: buf
        }
      );
    });
  },
  /**
   * Decode response as json
   *
   * @return  Promise
   */
  json() {
    var _this2 = this;
    return consumeBody.call(this).then(function(buffer) {
      try {
        return JSON.parse(buffer.toString());
      } catch (err) {
        return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
      }
    });
  },
  /**
   * Decode response as text
   *
   * @return  Promise
   */
  text() {
    return consumeBody.call(this).then(function(buffer) {
      return buffer.toString();
    });
  },
  /**
   * Decode response as buffer (non-spec api)
   *
   * @return  Promise
   */
  buffer() {
    return consumeBody.call(this);
  },
  /**
   * Decode response as text, while automatically detecting the encoding and
   * trying to decode to UTF-8 (non-spec api)
   *
   * @return  Promise
   */
  textConverted() {
    var _this3 = this;
    return consumeBody.call(this).then(function(buffer) {
      return convertBody(buffer, _this3.headers);
    });
  }
};
Object.defineProperties(Body.prototype, {
  body: { enumerable: true },
  bodyUsed: { enumerable: true },
  arrayBuffer: { enumerable: true },
  blob: { enumerable: true },
  json: { enumerable: true },
  text: { enumerable: true }
});
Body.mixIn = function(proto) {
  for (const name of Object.getOwnPropertyNames(Body.prototype)) {
    if (!(name in proto)) {
      const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
      Object.defineProperty(proto, name, desc);
    }
  }
};
function consumeBody() {
  var _this4 = this;
  if (this[INTERNALS].disturbed) {
    return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
  }
  this[INTERNALS].disturbed = true;
  if (this[INTERNALS].error) {
    return Body.Promise.reject(this[INTERNALS].error);
  }
  let body = this.body;
  if (body === null) {
    return Body.Promise.resolve(Buffer.alloc(0));
  }
  if (isBlob(body)) {
    body = body.stream();
  }
  if (Buffer.isBuffer(body)) {
    return Body.Promise.resolve(body);
  }
  if (!(body instanceof Stream)) {
    return Body.Promise.resolve(Buffer.alloc(0));
  }
  let accum = [];
  let accumBytes = 0;
  let abort = false;
  return new Body.Promise(function(resolve, reject) {
    let resTimeout;
    if (_this4.timeout) {
      resTimeout = setTimeout(function() {
        abort = true;
        reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
      }, _this4.timeout);
    }
    body.on("error", function(err) {
      if (err.name === "AbortError") {
        abort = true;
        reject(err);
      } else {
        reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
      }
    });
    body.on("data", function(chunk) {
      if (abort || chunk === null) {
        return;
      }
      if (_this4.size && accumBytes + chunk.length > _this4.size) {
        abort = true;
        reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
        return;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    });
    body.on("end", function() {
      if (abort) {
        return;
      }
      clearTimeout(resTimeout);
      try {
        resolve(Buffer.concat(accum, accumBytes));
      } catch (err) {
        reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
      }
    });
  });
}
function convertBody(buffer, headers) {
  if (typeof convert !== "function") {
    throw new Error("The package `encoding` must be installed to use the textConverted() function");
  }
  const ct = headers.get("content-type");
  let charset = "utf-8";
  let res, str;
  if (ct) {
    res = /charset=([^;]*)/i.exec(ct);
  }
  str = buffer.slice(0, 1024).toString();
  if (!res && str) {
    res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
  }
  if (!res && str) {
    res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
    if (!res) {
      res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
      if (res) {
        res.pop();
      }
    }
    if (res) {
      res = /charset=(.*)/i.exec(res.pop());
    }
  }
  if (!res && str) {
    res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
  }
  if (res) {
    charset = res.pop();
    if (charset === "gb2312" || charset === "gbk") {
      charset = "gb18030";
    }
  }
  return convert(buffer, "UTF-8", charset).toString();
}
function isURLSearchParams(obj) {
  if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
    return false;
  }
  return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
}
function isBlob(obj) {
  return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
}
function clone(instance2) {
  let p1, p2;
  let body = instance2.body;
  if (instance2.bodyUsed) {
    throw new Error("cannot clone body after it is used");
  }
  if (body instanceof Stream && typeof body.getBoundary !== "function") {
    p1 = new PassThrough();
    p2 = new PassThrough();
    body.pipe(p1);
    body.pipe(p2);
    instance2[INTERNALS].body = p1;
    body = p2;
  }
  return body;
}
function extractContentType(body) {
  if (body === null) {
    return null;
  } else if (typeof body === "string") {
    return "text/plain;charset=UTF-8";
  } else if (isURLSearchParams(body)) {
    return "application/x-www-form-urlencoded;charset=UTF-8";
  } else if (isBlob(body)) {
    return body.type || null;
  } else if (Buffer.isBuffer(body)) {
    return null;
  } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
    return null;
  } else if (ArrayBuffer.isView(body)) {
    return null;
  } else if (typeof body.getBoundary === "function") {
    return `multipart/form-data;boundary=${body.getBoundary()}`;
  } else if (body instanceof Stream) {
    return null;
  } else {
    return "text/plain;charset=UTF-8";
  }
}
function getTotalBytes(instance2) {
  const body = instance2.body;
  if (body === null) {
    return 0;
  } else if (isBlob(body)) {
    return body.size;
  } else if (Buffer.isBuffer(body)) {
    return body.length;
  } else if (body && typeof body.getLengthSync === "function") {
    if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
    body.hasKnownLength && body.hasKnownLength()) {
      return body.getLengthSync();
    }
    return null;
  } else {
    return null;
  }
}
function writeToStream(dest, instance2) {
  const body = instance2.body;
  if (body === null) {
    dest.end();
  } else if (isBlob(body)) {
    body.stream().pipe(dest);
  } else if (Buffer.isBuffer(body)) {
    dest.write(body);
    dest.end();
  } else {
    body.pipe(dest);
  }
}
Body.Promise = global.Promise;
var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
function validateName(name) {
  name = `${name}`;
  if (invalidTokenRegex.test(name) || name === "") {
    throw new TypeError(`${name} is not a legal HTTP header name`);
  }
}
function validateValue(value) {
  value = `${value}`;
  if (invalidHeaderCharRegex.test(value)) {
    throw new TypeError(`${value} is not a legal HTTP header value`);
  }
}
function find(map, name) {
  name = name.toLowerCase();
  for (const key in map) {
    if (key.toLowerCase() === name) {
      return key;
    }
  }
  return void 0;
}
var MAP = Symbol("map");
var Headers = class {
  /**
   * Headers class
   *
   * @param   Object  headers  Response headers
   * @return  Void
   */
  constructor() {
    let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
    this[MAP] = /* @__PURE__ */ Object.create(null);
    if (init instanceof Headers) {
      const rawHeaders = init.raw();
      const headerNames = Object.keys(rawHeaders);
      for (const headerName of headerNames) {
        for (const value of rawHeaders[headerName]) {
          this.append(headerName, value);
        }
      }
      return;
    }
    if (init == null)
      ;
    else if (typeof init === "object") {
      const method = init[Symbol.iterator];
      if (method != null) {
        if (typeof method !== "function") {
          throw new TypeError("Header pairs must be iterable");
        }
        const pairs = [];
        for (const pair of init) {
          if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
            throw new TypeError("Each header pair must be iterable");
          }
          pairs.push(Array.from(pair));
        }
        for (const pair of pairs) {
          if (pair.length !== 2) {
            throw new TypeError("Each header pair must be a name/value tuple");
          }
          this.append(pair[0], pair[1]);
        }
      } else {
        for (const key of Object.keys(init)) {
          const value = init[key];
          this.append(key, value);
        }
      }
    } else {
      throw new TypeError("Provided initializer must be an object");
    }
  }
  /**
   * Return combined header value given name
   *
   * @param   String  name  Header name
   * @return  Mixed
   */
  get(name) {
    name = `${name}`;
    validateName(name);
    const key = find(this[MAP], name);
    if (key === void 0) {
      return null;
    }
    return this[MAP][key].join(", ");
  }
  /**
   * Iterate over all headers
   *
   * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
   * @param   Boolean   thisArg   `this` context for callback function
   * @return  Void
   */
  forEach(callback) {
    let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
    let pairs = getHeaders(this);
    let i = 0;
    while (i < pairs.length) {
      var _pairs$i = pairs[i];
      const name = _pairs$i[0], value = _pairs$i[1];
      callback.call(thisArg, value, name, this);
      pairs = getHeaders(this);
      i++;
    }
  }
  /**
   * Overwrite header values given name
   *
   * @param   String  name   Header name
   * @param   String  value  Header value
   * @return  Void
   */
  set(name, value) {
    name = `${name}`;
    value = `${value}`;
    validateName(name);
    validateValue(value);
    const key = find(this[MAP], name);
    this[MAP][key !== void 0 ? key : name] = [value];
  }
  /**
   * Append a value onto existing header
   *
   * @param   String  name   Header name
   * @param   String  value  Header value
   * @return  Void
   */
  append(name, value) {
    name = `${name}`;
    value = `${value}`;
    validateName(name);
    validateValue(value);
    const key = find(this[MAP], name);
    if (key !== void 0) {
      this[MAP][key].push(value);
    } else {
      this[MAP][name] = [value];
    }
  }
  /**
   * Check for header name existence
   *
   * @param   String   name  Header name
   * @return  Boolean
   */
  has(name) {
    name = `${name}`;
    validateName(name);
    return find(this[MAP], name) !== void 0;
  }
  /**
   * Delete all header values given name
   *
   * @param   String  name  Header name
   * @return  Void
   */
  delete(name) {
    name = `${name}`;
    validateName(name);
    const key = find(this[MAP], name);
    if (key !== void 0) {
      delete this[MAP][key];
    }
  }
  /**
   * Return raw headers (non-spec api)
   *
   * @return  Object
   */
  raw() {
    return this[MAP];
  }
  /**
   * Get an iterator on keys.
   *
   * @return  Iterator
   */
  keys() {
    return createHeadersIterator(this, "key");
  }
  /**
   * Get an iterator on values.
   *
   * @return  Iterator
   */
  values() {
    return createHeadersIterator(this, "value");
  }
  /**
   * Get an iterator on entries.
   *
   * This is the default iterator of the Headers object.
   *
   * @return  Iterator
   */
  [Symbol.iterator]() {
    return createHeadersIterator(this, "key+value");
  }
};
Headers.prototype.entries = Headers.prototype[Symbol.iterator];
Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
  value: "Headers",
  writable: false,
  enumerable: false,
  configurable: true
});
Object.defineProperties(Headers.prototype, {
  get: { enumerable: true },
  forEach: { enumerable: true },
  set: { enumerable: true },
  append: { enumerable: true },
  has: { enumerable: true },
  delete: { enumerable: true },
  keys: { enumerable: true },
  values: { enumerable: true },
  entries: { enumerable: true }
});
function getHeaders(headers) {
  let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
  const keys = Object.keys(headers[MAP]).sort();
  return keys.map(kind === "key" ? function(k) {
    return k.toLowerCase();
  } : kind === "value" ? function(k) {
    return headers[MAP][k].join(", ");
  } : function(k) {
    return [k.toLowerCase(), headers[MAP][k].join(", ")];
  });
}
var INTERNAL = Symbol("internal");
function createHeadersIterator(target, kind) {
  const iterator = Object.create(HeadersIteratorPrototype);
  iterator[INTERNAL] = {
    target,
    kind,
    index: 0
  };
  return iterator;
}
var HeadersIteratorPrototype = Object.setPrototypeOf({
  next() {
    if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
      throw new TypeError("Value of `this` is not a HeadersIterator");
    }
    var _INTERNAL = this[INTERNAL];
    const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
    const values = getHeaders(target, kind);
    const len = values.length;
    if (index >= len) {
      return {
        value: void 0,
        done: true
      };
    }
    this[INTERNAL].index = index + 1;
    return {
      value: values[index],
      done: false
    };
  }
}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
  value: "HeadersIterator",
  writable: false,
  enumerable: false,
  configurable: true
});
function exportNodeCompatibleHeaders(headers) {
  const obj = Object.assign({ __proto__: null }, headers[MAP]);
  const hostHeaderKey = find(headers[MAP], "Host");
  if (hostHeaderKey !== void 0) {
    obj[hostHeaderKey] = obj[hostHeaderKey][0];
  }
  return obj;
}
function createHeadersLenient(obj) {
  const headers = new Headers();
  for (const name of Object.keys(obj)) {
    if (invalidTokenRegex.test(name)) {
      continue;
    }
    if (Array.isArray(obj[name])) {
      for (const val of obj[name]) {
        if (invalidHeaderCharRegex.test(val)) {
          continue;
        }
        if (headers[MAP][name] === void 0) {
          headers[MAP][name] = [val];
        } else {
          headers[MAP][name].push(val);
        }
      }
    } else if (!invalidHeaderCharRegex.test(obj[name])) {
      headers[MAP][name] = [obj[name]];
    }
  }
  return headers;
}
var INTERNALS$1 = Symbol("Response internals");
var STATUS_CODES = http.STATUS_CODES;
var Response = class {
  constructor() {
    let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Body.call(this, body, opts);
    const status = opts.status || 200;
    const headers = new Headers(opts.headers);
    if (body != null && !headers.has("Content-Type")) {
      const contentType = extractContentType(body);
      if (contentType) {
        headers.append("Content-Type", contentType);
      }
    }
    this[INTERNALS$1] = {
      url: opts.url,
      status,
      statusText: opts.statusText || STATUS_CODES[status],
      headers,
      counter: opts.counter
    };
  }
  get url() {
    return this[INTERNALS$1].url || "";
  }
  get status() {
    return this[INTERNALS$1].status;
  }
  /**
   * Convenience property representing if the request ended normally
   */
  get ok() {
    return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
  }
  get redirected() {
    return this[INTERNALS$1].counter > 0;
  }
  get statusText() {
    return this[INTERNALS$1].statusText;
  }
  get headers() {
    return this[INTERNALS$1].headers;
  }
  /**
   * Clone this response
   *
   * @return  Response
   */
  clone() {
    return new Response(clone(this), {
      url: this.url,
      status: this.status,
      statusText: this.statusText,
      headers: this.headers,
      ok: this.ok,
      redirected: this.redirected
    });
  }
};
Body.mixIn(Response.prototype);
Object.defineProperties(Response.prototype, {
  url: { enumerable: true },
  status: { enumerable: true },
  ok: { enumerable: true },
  redirected: { enumerable: true },
  statusText: { enumerable: true },
  headers: { enumerable: true },
  clone: { enumerable: true }
});
Object.defineProperty(Response.prototype, Symbol.toStringTag, {
  value: "Response",
  writable: false,
  enumerable: false,
  configurable: true
});
var INTERNALS$2 = Symbol("Request internals");
var URL2 = Url.URL || import_whatwg_url.default.URL;
var parse_url = Url.parse;
var format_url = Url.format;
function parseURL(urlStr) {
  if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
    urlStr = new URL2(urlStr).toString();
  }
  return parse_url(urlStr);
}
var streamDestructionSupported = "destroy" in Stream.Readable.prototype;
function isRequest(input) {
  return typeof input === "object" && typeof input[INTERNALS$2] === "object";
}
function isAbortSignal(signal) {
  const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
  return !!(proto && proto.constructor.name === "AbortSignal");
}
var Request = class {
  constructor(input) {
    let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let parsedURL;
    if (!isRequest(input)) {
      if (input && input.href) {
        parsedURL = parseURL(input.href);
      } else {
        parsedURL = parseURL(`${input}`);
      }
      input = {};
    } else {
      parsedURL = parseURL(input.url);
    }
    let method = init.method || input.method || "GET";
    method = method.toUpperCase();
    if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
      throw new TypeError("Request with GET/HEAD method cannot have body");
    }
    let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
    Body.call(this, inputBody, {
      timeout: init.timeout || input.timeout || 0,
      size: init.size || input.size || 0
    });
    const headers = new Headers(init.headers || input.headers || {});
    if (inputBody != null && !headers.has("Content-Type")) {
      const contentType = extractContentType(inputBody);
      if (contentType) {
        headers.append("Content-Type", contentType);
      }
    }
    let signal = isRequest(input) ? input.signal : null;
    if ("signal" in init)
      signal = init.signal;
    if (signal != null && !isAbortSignal(signal)) {
      throw new TypeError("Expected signal to be an instanceof AbortSignal");
    }
    this[INTERNALS$2] = {
      method,
      redirect: init.redirect || input.redirect || "follow",
      headers,
      parsedURL,
      signal
    };
    this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
    this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
    this.counter = init.counter || input.counter || 0;
    this.agent = init.agent || input.agent;
  }
  get method() {
    return this[INTERNALS$2].method;
  }
  get url() {
    return format_url(this[INTERNALS$2].parsedURL);
  }
  get headers() {
    return this[INTERNALS$2].headers;
  }
  get redirect() {
    return this[INTERNALS$2].redirect;
  }
  get signal() {
    return this[INTERNALS$2].signal;
  }
  /**
   * Clone this request
   *
   * @return  Request
   */
  clone() {
    return new Request(this);
  }
};
Body.mixIn(Request.prototype);
Object.defineProperty(Request.prototype, Symbol.toStringTag, {
  value: "Request",
  writable: false,
  enumerable: false,
  configurable: true
});
Object.defineProperties(Request.prototype, {
  method: { enumerable: true },
  url: { enumerable: true },
  headers: { enumerable: true },
  redirect: { enumerable: true },
  clone: { enumerable: true },
  signal: { enumerable: true }
});
function getNodeRequestOptions(request) {
  const parsedURL = request[INTERNALS$2].parsedURL;
  const headers = new Headers(request[INTERNALS$2].headers);
  if (!headers.has("Accept")) {
    headers.set("Accept", "*/*");
  }
  if (!parsedURL.protocol || !parsedURL.hostname) {
    throw new TypeError("Only absolute URLs are supported");
  }
  if (!/^https?:$/.test(parsedURL.protocol)) {
    throw new TypeError("Only HTTP(S) protocols are supported");
  }
  if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
    throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
  }
  let contentLengthValue = null;
  if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
    contentLengthValue = "0";
  }
  if (request.body != null) {
    const totalBytes = getTotalBytes(request);
    if (typeof totalBytes === "number") {
      contentLengthValue = String(totalBytes);
    }
  }
  if (contentLengthValue) {
    headers.set("Content-Length", contentLengthValue);
  }
  if (!headers.has("User-Agent")) {
    headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
  }
  if (request.compress && !headers.has("Accept-Encoding")) {
    headers.set("Accept-Encoding", "gzip,deflate");
  }
  let agent2 = request.agent;
  if (typeof agent2 === "function") {
    agent2 = agent2(parsedURL);
  }
  if (!headers.has("Connection") && !agent2) {
    headers.set("Connection", "close");
  }
  return Object.assign({}, parsedURL, {
    method: request.method,
    headers: exportNodeCompatibleHeaders(headers),
    agent: agent2
  });
}
function AbortError(message2) {
  Error.call(this, message2);
  this.type = "aborted";
  this.message = message2;
  Error.captureStackTrace(this, this.constructor);
}
AbortError.prototype = Object.create(Error.prototype);
AbortError.prototype.constructor = AbortError;
AbortError.prototype.name = "AbortError";
var URL$1 = Url.URL || import_whatwg_url.default.URL;
var PassThrough$1 = Stream.PassThrough;
var isDomainOrSubdomain = function isDomainOrSubdomain2(destination, original) {
  const orig = new URL$1(original).hostname;
  const dest = new URL$1(destination).hostname;
  return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
};
var isSameProtocol = function isSameProtocol2(destination, original) {
  const orig = new URL$1(original).protocol;
  const dest = new URL$1(destination).protocol;
  return orig === dest;
};
function fetch(url, opts) {
  if (!fetch.Promise) {
    throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
  }
  Body.Promise = fetch.Promise;
  return new fetch.Promise(function(resolve, reject) {
    const request = new Request(url, opts);
    const options = getNodeRequestOptions(request);
    const send = (options.protocol === "https:" ? https : http).request;
    const signal = request.signal;
    let response = null;
    const abort = function abort2() {
      let error = new AbortError("The user aborted a request.");
      reject(error);
      if (request.body && request.body instanceof Stream.Readable) {
        destroyStream(request.body, error);
      }
      if (!response || !response.body)
        return;
      response.body.emit("error", error);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = function abortAndFinalize2() {
      abort();
      finalize();
    };
    const req = send(options);
    let reqTimeout;
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    function finalize() {
      req.abort();
      if (signal)
        signal.removeEventListener("abort", abortAndFinalize);
      clearTimeout(reqTimeout);
    }
    if (request.timeout) {
      req.once("socket", function(socket) {
        reqTimeout = setTimeout(function() {
          reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
          finalize();
        }, request.timeout);
      });
    }
    req.on("error", function(err) {
      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
      if (response && response.body) {
        destroyStream(response.body, err);
      }
      finalize();
    });
    fixResponseChunkedTransferBadEnding(req, function(err) {
      if (signal && signal.aborted) {
        return;
      }
      if (response && response.body) {
        destroyStream(response.body, err);
      }
    });
    if (parseInt(process.version.substring(1)) < 14) {
      req.on("socket", function(s2) {
        s2.addListener("close", function(hadError) {
          const hasDataListener = s2.listenerCount("data") > 0;
          if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
            const err = new Error("Premature close");
            err.code = "ERR_STREAM_PREMATURE_CLOSE";
            response.body.emit("error", err);
          }
        });
      });
    }
    req.on("response", function(res) {
      clearTimeout(reqTimeout);
      const headers = createHeadersLenient(res.headers);
      if (fetch.isRedirect(res.statusCode)) {
        const location = headers.get("Location");
        let locationURL = null;
        try {
          locationURL = location === null ? null : new URL$1(location, request.url).toString();
        } catch (err) {
          if (request.redirect !== "manual") {
            reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
            finalize();
            return;
          }
        }
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            if (locationURL !== null) {
              try {
                headers.set("Location", locationURL);
              } catch (err) {
                reject(err);
              }
            }
            break;
          case "follow":
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOpts = {
              headers: new Headers(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: request.body,
              signal: request.signal,
              timeout: request.timeout,
              size: request.size
            };
            if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
              for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                requestOpts.headers.delete(name);
              }
            }
            if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
              requestOpts.method = "GET";
              requestOpts.body = void 0;
              requestOpts.headers.delete("content-length");
            }
            resolve(fetch(new Request(locationURL, requestOpts)));
            finalize();
            return;
        }
      }
      res.once("end", function() {
        if (signal)
          signal.removeEventListener("abort", abortAndFinalize);
      });
      let body = res.pipe(new PassThrough$1());
      const response_options = {
        url: request.url,
        status: res.statusCode,
        statusText: res.statusMessage,
        headers,
        size: request.size,
        timeout: request.timeout,
        counter: request.counter
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
        response = new Response(body, response_options);
        resolve(response);
        return;
      }
      const zlibOptions = {
        flush: zlib.Z_SYNC_FLUSH,
        finishFlush: zlib.Z_SYNC_FLUSH
      };
      if (codings == "gzip" || codings == "x-gzip") {
        body = body.pipe(zlib.createGunzip(zlibOptions));
        response = new Response(body, response_options);
        resolve(response);
        return;
      }
      if (codings == "deflate" || codings == "x-deflate") {
        const raw = res.pipe(new PassThrough$1());
        raw.once("data", function(chunk) {
          if ((chunk[0] & 15) === 8) {
            body = body.pipe(zlib.createInflate());
          } else {
            body = body.pipe(zlib.createInflateRaw());
          }
          response = new Response(body, response_options);
          resolve(response);
        });
        raw.on("end", function() {
          if (!response) {
            response = new Response(body, response_options);
            resolve(response);
          }
        });
        return;
      }
      if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
        body = body.pipe(zlib.createBrotliDecompress());
        response = new Response(body, response_options);
        resolve(response);
        return;
      }
      response = new Response(body, response_options);
      resolve(response);
    });
    writeToStream(req, request);
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  let socket;
  request.on("socket", function(s2) {
    socket = s2;
  });
  request.on("response", function(response) {
    const headers = response.headers;
    if (headers["transfer-encoding"] === "chunked" && !headers["content-length"]) {
      response.once("close", function(hadError) {
        const hasDataListener = socket.listenerCount("data") > 0;
        if (hasDataListener && !hadError) {
          const err = new Error("Premature close");
          err.code = "ERR_STREAM_PREMATURE_CLOSE";
          errorCallback(err);
        }
      });
    }
  });
}
function destroyStream(stream, err) {
  if (stream.destroy) {
    stream.destroy(err);
  } else {
    stream.emit("error", err);
    stream.end();
  }
}
fetch.isRedirect = function(code) {
  return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
};
fetch.Promise = global.Promise;
var lib_default = fetch;

// ../../node_modules/@solana/web3.js/lib/index.esm.js
var import_client = __toESM(require_client());
var import_websocket = __toESM(require_websocket2());

// ../../node_modules/@noble/hashes/esm/sha3.js
var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var _7n = BigInt(7);
var _256n = BigInt(256);
var _0x71n = BigInt(113);
for (let round = 0, R = _1n2, x = 1, y2 = 0; round < 24; round++) {
  [x, y2] = [y2, (2 * x + 3 * y2) % 5];
  SHA3_PI.push(2 * (5 * y2 + x));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n2;
  for (let j = 0; j < 7; j++) {
    R = (R << _1n2 ^ (R >> _7n) * _0x71n) % _256n;
    if (R & _2n2)
      t ^= _1n2 << (_1n2 << BigInt(j)) - _1n2;
  }
  _SHA3_IOTA.push(t);
}
var [SHA3_IOTA_H, SHA3_IOTA_L] = u64_default.split(_SHA3_IOTA, true);
var rotlH = (h2, l, s2) => s2 > 32 ? u64_default.rotlBH(h2, l, s2) : u64_default.rotlSH(h2, l, s2);
var rotlL = (h2, l, s2) => s2 > 32 ? u64_default.rotlBL(h2, l, s2) : u64_default.rotlSL(h2, l, s2);
function keccakP(s2, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s2[x] ^ s2[x + 10] ^ s2[x + 20] ^ s2[x + 30] ^ s2[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y2 = 0; y2 < 50; y2 += 10) {
        s2[x + y2] ^= Th;
        s2[x + y2 + 1] ^= Tl;
      }
    }
    let curH = s2[2];
    let curL = s2[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s2[PI];
      curL = s2[PI + 1];
      s2[PI] = Th;
      s2[PI + 1] = Tl;
    }
    for (let y2 = 0; y2 < 50; y2 += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s2[y2 + x];
      for (let x = 0; x < 10; x++)
        s2[y2 + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s2[0] ^= SHA3_IOTA_H[round];
    s2[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}
var Keccak = class extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    assert_default.number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    assert_default.exists(this);
    const { blockLen, state } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0; i < take; i++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    assert_default.exists(this, false);
    assert_default.bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    assert_default.number(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    assert_default.output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
var sha3_224 = gen(6, 144, 224 / 8);
var sha3_256 = gen(6, 136, 256 / 8);
var sha3_384 = gen(6, 104, 384 / 8);
var sha3_512 = gen(6, 72, 512 / 8);
var keccak_224 = gen(1, 144, 224 / 8);
var keccak_256 = gen(1, 136, 256 / 8);
var keccak_384 = gen(1, 104, 384 / 8);
var keccak_512 = gen(1, 72, 512 / 8);
var genShake = (suffix, blockLen, outputLen) => wrapConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
var shake128 = genShake(31, 168, 128 / 8);
var shake256 = genShake(31, 136, 256 / 8);

// ../../node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    assert_default.hash(hash2);
    const key = toBytes(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new TypeError("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash2.create();
    for (let i = 0; i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    assert_default.exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    assert_default.exists(this);
    assert_default.bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash2, key, message2) => new HMAC(hash2, key).update(message2).digest();
hmac.create = (hash2, key) => new HMAC(hash2, key);

// ../../node_modules/@noble/secp256k1/lib/esm/index.js
import * as nodeCrypto2 from "crypto";
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
var _2n3 = BigInt(2);
var _3n = BigInt(3);
var _8n2 = BigInt(8);
var CURVE2 = Object.freeze({
  a: _0n3,
  b: BigInt(7),
  P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: _1n3,
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
});
var divNearest = (a, b) => (a + b / _2n3) / b;
var endo = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  splitScalar(k) {
    const { n } = CURVE2;
    const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
    const b1 = -_1n3 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
    const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
    const b2 = a1;
    const POW_2_128 = BigInt("0x100000000000000000000000000000000");
    const c1 = divNearest(b2 * k, n);
    const c2 = divNearest(-b1 * k, n);
    let k1 = mod2(k - c1 * a1 - c2 * a2, n);
    let k2 = mod2(-c1 * b1 - c2 * b2, n);
    const k1neg = k1 > POW_2_128;
    const k2neg = k2 > POW_2_128;
    if (k1neg)
      k1 = n - k1;
    if (k2neg)
      k2 = n - k2;
    if (k1 > POW_2_128 || k2 > POW_2_128) {
      throw new Error("splitScalarEndo: Endomorphism failed, k=" + k);
    }
    return { k1neg, k1, k2neg, k2 };
  }
};
var fieldLen = 32;
var groupLen = 32;
var hashLen = 32;
var compressedLen = fieldLen + 1;
var uncompressedLen = 2 * fieldLen + 1;
function weierstrass(x) {
  const { a, b } = CURVE2;
  const x2 = mod2(x * x);
  const x3 = mod2(x2 * x);
  return mod2(x3 + a * x + b);
}
var USE_ENDOMORPHISM = CURVE2.a === _0n3;
var ShaError = class extends Error {
  constructor(message2) {
    super(message2);
  }
};
function assertJacPoint(other) {
  if (!(other instanceof JacobianPoint))
    throw new TypeError("JacobianPoint expected");
}
var JacobianPoint = class {
  constructor(x, y2, z2) {
    this.x = x;
    this.y = y2;
    this.z = z2;
  }
  static fromAffine(p) {
    if (!(p instanceof Point2)) {
      throw new TypeError("JacobianPoint#fromAffine: expected Point");
    }
    if (p.equals(Point2.ZERO))
      return JacobianPoint.ZERO;
    return new JacobianPoint(p.x, p.y, _1n3);
  }
  static toAffineBatch(points) {
    const toInv = invertBatch2(points.map((p) => p.z));
    return points.map((p, i) => p.toAffine(toInv[i]));
  }
  static normalizeZ(points) {
    return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);
  }
  equals(other) {
    assertJacPoint(other);
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X2, y: Y2, z: Z2 } = other;
    const Z1Z1 = mod2(Z1 * Z1);
    const Z2Z2 = mod2(Z2 * Z2);
    const U1 = mod2(X1 * Z2Z2);
    const U2 = mod2(X2 * Z1Z1);
    const S1 = mod2(mod2(Y1 * Z2) * Z2Z2);
    const S2 = mod2(mod2(Y2 * Z1) * Z1Z1);
    return U1 === U2 && S1 === S2;
  }
  negate() {
    return new JacobianPoint(this.x, mod2(-this.y), this.z);
  }
  double() {
    const { x: X1, y: Y1, z: Z1 } = this;
    const A = mod2(X1 * X1);
    const B = mod2(Y1 * Y1);
    const C = mod2(B * B);
    const x1b = X1 + B;
    const D = mod2(_2n3 * (mod2(x1b * x1b) - A - C));
    const E = mod2(_3n * A);
    const F = mod2(E * E);
    const X3 = mod2(F - _2n3 * D);
    const Y3 = mod2(E * (D - X3) - _8n2 * C);
    const Z3 = mod2(_2n3 * Y1 * Z1);
    return new JacobianPoint(X3, Y3, Z3);
  }
  add(other) {
    assertJacPoint(other);
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X2, y: Y2, z: Z2 } = other;
    if (X2 === _0n3 || Y2 === _0n3)
      return this;
    if (X1 === _0n3 || Y1 === _0n3)
      return other;
    const Z1Z1 = mod2(Z1 * Z1);
    const Z2Z2 = mod2(Z2 * Z2);
    const U1 = mod2(X1 * Z2Z2);
    const U2 = mod2(X2 * Z1Z1);
    const S1 = mod2(mod2(Y1 * Z2) * Z2Z2);
    const S2 = mod2(mod2(Y2 * Z1) * Z1Z1);
    const H = mod2(U2 - U1);
    const r = mod2(S2 - S1);
    if (H === _0n3) {
      if (r === _0n3) {
        return this.double();
      } else {
        return JacobianPoint.ZERO;
      }
    }
    const HH = mod2(H * H);
    const HHH = mod2(H * HH);
    const V = mod2(U1 * HH);
    const X3 = mod2(r * r - HHH - _2n3 * V);
    const Y3 = mod2(r * (V - X3) - S1 * HHH);
    const Z3 = mod2(Z1 * Z2 * H);
    return new JacobianPoint(X3, Y3, Z3);
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiplyUnsafe(scalar) {
    const P0 = JacobianPoint.ZERO;
    if (typeof scalar === "bigint" && scalar === _0n3)
      return P0;
    let n = normalizeScalar2(scalar);
    if (n === _1n3)
      return this;
    if (!USE_ENDOMORPHISM) {
      let p = P0;
      let d3 = this;
      while (n > _0n3) {
        if (n & _1n3)
          p = p.add(d3);
        d3 = d3.double();
        n >>= _1n3;
      }
      return p;
    }
    let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
    let k1p = P0;
    let k2p = P0;
    let d2 = this;
    while (k1 > _0n3 || k2 > _0n3) {
      if (k1 & _1n3)
        k1p = k1p.add(d2);
      if (k2 & _1n3)
        k2p = k2p.add(d2);
      d2 = d2.double();
      k1 >>= _1n3;
      k2 >>= _1n3;
    }
    if (k1neg)
      k1p = k1p.negate();
    if (k2neg)
      k2p = k2p.negate();
    k2p = new JacobianPoint(mod2(k2p.x * endo.beta), k2p.y, k2p.z);
    return k1p.add(k2p);
  }
  precomputeWindow(W) {
    const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
    const points = [];
    let p = this;
    let base = p;
    for (let window2 = 0; window2 < windows; window2++) {
      base = p;
      points.push(base);
      for (let i = 1; i < 2 ** (W - 1); i++) {
        base = base.add(p);
        points.push(base);
      }
      p = base.double();
    }
    return points;
  }
  wNAF(n, affinePoint) {
    if (!affinePoint && this.equals(JacobianPoint.BASE))
      affinePoint = Point2.BASE;
    const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
    if (256 % W) {
      throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
    }
    let precomputes = affinePoint && pointPrecomputes2.get(affinePoint);
    if (!precomputes) {
      precomputes = this.precomputeWindow(W);
      if (affinePoint && W !== 1) {
        precomputes = JacobianPoint.normalizeZ(precomputes);
        pointPrecomputes2.set(affinePoint, precomputes);
      }
    }
    let p = JacobianPoint.ZERO;
    let f = JacobianPoint.BASE;
    const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);
    const windowSize = 2 ** (W - 1);
    const mask2 = BigInt(2 ** W - 1);
    const maxNumber = 2 ** W;
    const shiftBy = BigInt(W);
    for (let window2 = 0; window2 < windows; window2++) {
      const offset2 = window2 * windowSize;
      let wbits = Number(n & mask2);
      n >>= shiftBy;
      if (wbits > windowSize) {
        wbits -= maxNumber;
        n += _1n3;
      }
      const offset1 = offset2;
      const offset22 = offset2 + Math.abs(wbits) - 1;
      const cond1 = window2 % 2 !== 0;
      const cond2 = wbits < 0;
      if (wbits === 0) {
        f = f.add(constTimeNegate2(cond1, precomputes[offset1]));
      } else {
        p = p.add(constTimeNegate2(cond2, precomputes[offset22]));
      }
    }
    return { p, f };
  }
  multiply(scalar, affinePoint) {
    let n = normalizeScalar2(scalar);
    let point;
    let fake;
    if (USE_ENDOMORPHISM) {
      const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
      let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);
      let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);
      k1p = constTimeNegate2(k1neg, k1p);
      k2p = constTimeNegate2(k2neg, k2p);
      k2p = new JacobianPoint(mod2(k2p.x * endo.beta), k2p.y, k2p.z);
      point = k1p.add(k2p);
      fake = f1p.add(f2p);
    } else {
      const { p, f } = this.wNAF(n, affinePoint);
      point = p;
      fake = f;
    }
    return JacobianPoint.normalizeZ([point, fake])[0];
  }
  toAffine(invZ) {
    const { x, y: y2, z: z2 } = this;
    const is0 = this.equals(JacobianPoint.ZERO);
    if (invZ == null)
      invZ = is0 ? _8n2 : invert2(z2);
    const iz1 = invZ;
    const iz2 = mod2(iz1 * iz1);
    const iz3 = mod2(iz2 * iz1);
    const ax = mod2(x * iz2);
    const ay = mod2(y2 * iz3);
    const zz = mod2(z2 * iz1);
    if (is0)
      return Point2.ZERO;
    if (zz !== _1n3)
      throw new Error("invZ was invalid");
    return new Point2(ax, ay);
  }
};
JacobianPoint.BASE = new JacobianPoint(CURVE2.Gx, CURVE2.Gy, _1n3);
JacobianPoint.ZERO = new JacobianPoint(_0n3, _1n3, _0n3);
function constTimeNegate2(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
}
var pointPrecomputes2 = /* @__PURE__ */ new WeakMap();
var Point2 = class {
  constructor(x, y2) {
    this.x = x;
    this.y = y2;
  }
  _setWindowSize(windowSize) {
    this._WINDOW_SIZE = windowSize;
    pointPrecomputes2.delete(this);
  }
  hasEvenY() {
    return this.y % _2n3 === _0n3;
  }
  static fromCompressedHex(bytes2) {
    const isShort = bytes2.length === 32;
    const x = bytesToNumber(isShort ? bytes2 : bytes2.subarray(1));
    if (!isValidFieldElement(x))
      throw new Error("Point is not on curve");
    const y2 = weierstrass(x);
    let y3 = sqrtMod(y2);
    const isYOdd = (y3 & _1n3) === _1n3;
    if (isShort) {
      if (isYOdd)
        y3 = mod2(-y3);
    } else {
      const isFirstByteOdd = (bytes2[0] & 1) === 1;
      if (isFirstByteOdd !== isYOdd)
        y3 = mod2(-y3);
    }
    const point = new Point2(x, y3);
    point.assertValidity();
    return point;
  }
  static fromUncompressedHex(bytes2) {
    const x = bytesToNumber(bytes2.subarray(1, fieldLen + 1));
    const y2 = bytesToNumber(bytes2.subarray(fieldLen + 1, fieldLen * 2 + 1));
    const point = new Point2(x, y2);
    point.assertValidity();
    return point;
  }
  static fromHex(hex) {
    const bytes2 = ensureBytes2(hex);
    const len = bytes2.length;
    const header = bytes2[0];
    if (len === fieldLen)
      return this.fromCompressedHex(bytes2);
    if (len === compressedLen && (header === 2 || header === 3)) {
      return this.fromCompressedHex(bytes2);
    }
    if (len === uncompressedLen && header === 4)
      return this.fromUncompressedHex(bytes2);
    throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);
  }
  static fromPrivateKey(privateKey) {
    return Point2.BASE.multiply(normalizePrivateKey(privateKey));
  }
  static fromSignature(msgHash, signature2, recovery) {
    const { r, s: s2 } = normalizeSignature(signature2);
    if (![0, 1, 2, 3].includes(recovery))
      throw new Error("Cannot recover: invalid recovery bit");
    const h2 = truncateHash(ensureBytes2(msgHash));
    const { n } = CURVE2;
    const radj = recovery === 2 || recovery === 3 ? r + n : r;
    const rinv = invert2(radj, n);
    const u1 = mod2(-h2 * rinv, n);
    const u2 = mod2(s2 * rinv, n);
    const prefix = recovery & 1 ? "03" : "02";
    const R = Point2.fromHex(prefix + numTo32bStr(radj));
    const Q = Point2.BASE.multiplyAndAddUnsafe(R, u1, u2);
    if (!Q)
      throw new Error("Cannot recover signature: point at infinify");
    Q.assertValidity();
    return Q;
  }
  toRawBytes(isCompressed = false) {
    return hexToBytes2(this.toHex(isCompressed));
  }
  toHex(isCompressed = false) {
    const x = numTo32bStr(this.x);
    if (isCompressed) {
      const prefix = this.hasEvenY() ? "02" : "03";
      return `${prefix}${x}`;
    } else {
      return `04${x}${numTo32bStr(this.y)}`;
    }
  }
  toHexX() {
    return this.toHex(true).slice(2);
  }
  toRawX() {
    return this.toRawBytes(true).slice(1);
  }
  assertValidity() {
    const msg = "Point is not on elliptic curve";
    const { x, y: y2 } = this;
    if (!isValidFieldElement(x) || !isValidFieldElement(y2))
      throw new Error(msg);
    const left = mod2(y2 * y2);
    const right = weierstrass(x);
    if (mod2(left - right) !== _0n3)
      throw new Error(msg);
  }
  equals(other) {
    return this.x === other.x && this.y === other.y;
  }
  negate() {
    return new Point2(this.x, mod2(-this.y));
  }
  double() {
    return JacobianPoint.fromAffine(this).double().toAffine();
  }
  add(other) {
    return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiply(scalar) {
    return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
  }
  multiplyAndAddUnsafe(Q, a, b) {
    const P = JacobianPoint.fromAffine(this);
    const aP = a === _0n3 || a === _1n3 || this !== Point2.BASE ? P.multiplyUnsafe(a) : P.multiply(a);
    const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);
    const sum = aP.add(bQ);
    return sum.equals(JacobianPoint.ZERO) ? void 0 : sum.toAffine();
  }
};
Point2.BASE = new Point2(CURVE2.Gx, CURVE2.Gy);
Point2.ZERO = new Point2(_0n3, _0n3);
function sliceDER(s2) {
  return Number.parseInt(s2[0], 16) >= 8 ? "00" + s2 : s2;
}
function parseDERInt(data) {
  if (data.length < 2 || data[0] !== 2) {
    throw new Error(`Invalid signature integer tag: ${bytesToHex2(data)}`);
  }
  const len = data[1];
  const res = data.subarray(2, len + 2);
  if (!len || res.length !== len) {
    throw new Error(`Invalid signature integer: wrong length`);
  }
  if (res[0] === 0 && res[1] <= 127) {
    throw new Error("Invalid signature integer: trailing length");
  }
  return { data: bytesToNumber(res), left: data.subarray(len + 2) };
}
function parseDERSignature(data) {
  if (data.length < 2 || data[0] != 48) {
    throw new Error(`Invalid signature tag: ${bytesToHex2(data)}`);
  }
  if (data[1] !== data.length - 2) {
    throw new Error("Invalid signature: incorrect length");
  }
  const { data: r, left: sBytes } = parseDERInt(data.subarray(2));
  const { data: s2, left: rBytesLeft } = parseDERInt(sBytes);
  if (rBytesLeft.length) {
    throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex2(rBytesLeft)}`);
  }
  return { r, s: s2 };
}
var Signature2 = class {
  constructor(r, s2) {
    this.r = r;
    this.s = s2;
    this.assertValidity();
  }
  static fromCompact(hex) {
    const arr = hex instanceof Uint8Array;
    const name = "Signature.fromCompact";
    if (typeof hex !== "string" && !arr)
      throw new TypeError(`${name}: Expected string or Uint8Array`);
    const str = arr ? bytesToHex2(hex) : hex;
    if (str.length !== 128)
      throw new Error(`${name}: Expected 64-byte hex`);
    return new Signature2(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));
  }
  static fromDER(hex) {
    const arr = hex instanceof Uint8Array;
    if (typeof hex !== "string" && !arr)
      throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
    const { r, s: s2 } = parseDERSignature(arr ? hex : hexToBytes2(hex));
    return new Signature2(r, s2);
  }
  static fromHex(hex) {
    return this.fromDER(hex);
  }
  assertValidity() {
    const { r, s: s2 } = this;
    if (!isWithinCurveOrder(r))
      throw new Error("Invalid Signature: r must be 0 < r < n");
    if (!isWithinCurveOrder(s2))
      throw new Error("Invalid Signature: s must be 0 < s < n");
  }
  hasHighS() {
    const HALF = CURVE2.n >> _1n3;
    return this.s > HALF;
  }
  normalizeS() {
    return this.hasHighS() ? new Signature2(this.r, mod2(-this.s, CURVE2.n)) : this;
  }
  toDERRawBytes() {
    return hexToBytes2(this.toDERHex());
  }
  toDERHex() {
    const sHex = sliceDER(numberToHexUnpadded(this.s));
    const rHex = sliceDER(numberToHexUnpadded(this.r));
    const sHexL = sHex.length / 2;
    const rHexL = rHex.length / 2;
    const sLen = numberToHexUnpadded(sHexL);
    const rLen = numberToHexUnpadded(rHexL);
    const length = numberToHexUnpadded(rHexL + sHexL + 4);
    return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;
  }
  toRawBytes() {
    return this.toDERRawBytes();
  }
  toHex() {
    return this.toDERHex();
  }
  toCompactRawBytes() {
    return hexToBytes2(this.toCompactHex());
  }
  toCompactHex() {
    return numTo32bStr(this.r) + numTo32bStr(this.s);
  }
};
function concatBytes2(...arrays) {
  if (!arrays.every((b) => b instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (arrays.length === 1)
    return arrays[0];
  const length = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length);
  for (let i = 0, pad = 0; i < arrays.length; i++) {
    const arr = arrays[i];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
}
var hexes3 = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
function bytesToHex2(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  let hex = "";
  for (let i = 0; i < uint8a.length; i++) {
    hex += hexes3[uint8a[i]];
  }
  return hex;
}
var POW_2_2562 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
function numTo32bStr(num) {
  if (typeof num !== "bigint")
    throw new Error("Expected bigint");
  if (!(_0n3 <= num && num < POW_2_2562))
    throw new Error("Expected number 0 <= n < 2^256");
  return num.toString(16).padStart(64, "0");
}
function numTo32b(num) {
  const b = hexToBytes2(numTo32bStr(num));
  if (b.length !== 32)
    throw new Error("Error: expected 32 bytes");
  return b;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToNumber: expected string, got " + typeof hex);
  }
  return BigInt(`0x${hex}`);
}
function hexToBytes2(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex);
  }
  if (hex.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex" + hex.length);
  const array2 = new Uint8Array(hex.length / 2);
  for (let i = 0; i < array2.length; i++) {
    const j = i * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array2[i] = byte;
  }
  return array2;
}
function bytesToNumber(bytes2) {
  return hexToNumber(bytesToHex2(bytes2));
}
function ensureBytes2(hex) {
  return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes2(hex);
}
function normalizeScalar2(num) {
  if (typeof num === "number" && Number.isSafeInteger(num) && num > 0)
    return BigInt(num);
  if (typeof num === "bigint" && isWithinCurveOrder(num))
    return num;
  throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
}
function mod2(a, b = CURVE2.P) {
  const result = a % b;
  return result >= _0n3 ? result : b + result;
}
function pow22(x, power) {
  const { P } = CURVE2;
  let res = x;
  while (power-- > _0n3) {
    res *= res;
    res %= P;
  }
  return res;
}
function sqrtMod(x) {
  const { P } = CURVE2;
  const _6n = BigInt(6);
  const _11n = BigInt(11);
  const _22n = BigInt(22);
  const _23n = BigInt(23);
  const _44n = BigInt(44);
  const _88n = BigInt(88);
  const b2 = x * x * x % P;
  const b3 = b2 * b2 * x % P;
  const b6 = pow22(b3, _3n) * b3 % P;
  const b9 = pow22(b6, _3n) * b3 % P;
  const b11 = pow22(b9, _2n3) * b2 % P;
  const b22 = pow22(b11, _11n) * b11 % P;
  const b44 = pow22(b22, _22n) * b22 % P;
  const b88 = pow22(b44, _44n) * b44 % P;
  const b176 = pow22(b88, _88n) * b88 % P;
  const b220 = pow22(b176, _44n) * b44 % P;
  const b223 = pow22(b220, _3n) * b3 % P;
  const t1 = pow22(b223, _23n) * b22 % P;
  const t2 = pow22(t1, _6n) * b2 % P;
  const rt = pow22(t2, _2n3);
  const xc = rt * rt % P;
  if (xc !== x)
    throw new Error("Cannot find square root");
  return rt;
}
function invert2(number3, modulo = CURVE2.P) {
  if (number3 === _0n3 || modulo <= _0n3) {
    throw new Error(`invert: expected positive integers, got n=${number3} mod=${modulo}`);
  }
  let a = mod2(number3, modulo);
  let b = modulo;
  let x = _0n3, y2 = _1n3, u = _1n3, v = _0n3;
  while (a !== _0n3) {
    const q = b / a;
    const r = b % a;
    const m2 = x - u * q;
    const n = y2 - v * q;
    b = a, a = r, x = u, y2 = v, u = m2, v = n;
  }
  const gcd = b;
  if (gcd !== _1n3)
    throw new Error("invert: does not exist");
  return mod2(x, modulo);
}
function invertBatch2(nums, p = CURVE2.P) {
  const scratch = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (num === _0n3)
      return acc;
    scratch[i] = acc;
    return mod2(acc * num, p);
  }, _1n3);
  const inverted = invert2(lastMultiplied, p);
  nums.reduceRight((acc, num, i) => {
    if (num === _0n3)
      return acc;
    scratch[i] = mod2(acc * scratch[i], p);
    return mod2(acc * num, p);
  }, inverted);
  return scratch;
}
function bits2int_2(bytes2) {
  const delta = bytes2.length * 8 - groupLen * 8;
  const num = bytesToNumber(bytes2);
  return delta > 0 ? num >> BigInt(delta) : num;
}
function truncateHash(hash2, truncateOnly = false) {
  const h2 = bits2int_2(hash2);
  if (truncateOnly)
    return h2;
  const { n } = CURVE2;
  return h2 >= n ? h2 - n : h2;
}
var _sha256Sync;
var _hmacSha256Sync;
var HmacDrbg = class {
  constructor(hashLen2, qByteLen) {
    this.hashLen = hashLen2;
    this.qByteLen = qByteLen;
    if (typeof hashLen2 !== "number" || hashLen2 < 2)
      throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2)
      throw new Error("qByteLen must be a number");
    this.v = new Uint8Array(hashLen2).fill(1);
    this.k = new Uint8Array(hashLen2).fill(0);
    this.counter = 0;
  }
  hmac(...values) {
    return utils2.hmacSha256(this.k, ...values);
  }
  hmacSync(...values) {
    return _hmacSha256Sync(this.k, ...values);
  }
  checkSync() {
    if (typeof _hmacSha256Sync !== "function")
      throw new ShaError("hmacSha256Sync needs to be set");
  }
  incr() {
    if (this.counter >= 1e3)
      throw new Error("Tried 1,000 k values for sign(), all were invalid");
    this.counter += 1;
  }
  reseed() {
    return __async(this, arguments, function* (seed = new Uint8Array()) {
      this.k = yield this.hmac(this.v, Uint8Array.from([0]), seed);
      this.v = yield this.hmac(this.v);
      if (seed.length === 0)
        return;
      this.k = yield this.hmac(this.v, Uint8Array.from([1]), seed);
      this.v = yield this.hmac(this.v);
    });
  }
  reseedSync(seed = new Uint8Array()) {
    this.checkSync();
    this.k = this.hmacSync(this.v, Uint8Array.from([0]), seed);
    this.v = this.hmacSync(this.v);
    if (seed.length === 0)
      return;
    this.k = this.hmacSync(this.v, Uint8Array.from([1]), seed);
    this.v = this.hmacSync(this.v);
  }
  generate() {
    return __async(this, null, function* () {
      this.incr();
      let len = 0;
      const out = [];
      while (len < this.qByteLen) {
        this.v = yield this.hmac(this.v);
        const sl = this.v.slice();
        out.push(sl);
        len += this.v.length;
      }
      return concatBytes2(...out);
    });
  }
  generateSync() {
    this.checkSync();
    this.incr();
    let len = 0;
    const out = [];
    while (len < this.qByteLen) {
      this.v = this.hmacSync(this.v);
      const sl = this.v.slice();
      out.push(sl);
      len += this.v.length;
    }
    return concatBytes2(...out);
  }
};
function isWithinCurveOrder(num) {
  return _0n3 < num && num < CURVE2.n;
}
function isValidFieldElement(num) {
  return _0n3 < num && num < CURVE2.P;
}
function kmdToSig(kBytes, m2, d2, lowS = true) {
  const { n } = CURVE2;
  const k = truncateHash(kBytes, true);
  if (!isWithinCurveOrder(k))
    return;
  const kinv = invert2(k, n);
  const q = Point2.BASE.multiply(k);
  const r = mod2(q.x, n);
  if (r === _0n3)
    return;
  const s2 = mod2(kinv * mod2(m2 + d2 * r, n), n);
  if (s2 === _0n3)
    return;
  let sig = new Signature2(r, s2);
  let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n3);
  if (lowS && sig.hasHighS()) {
    sig = sig.normalizeS();
    recovery ^= 1;
  }
  return { sig, recovery };
}
function normalizePrivateKey(key) {
  let num;
  if (typeof key === "bigint") {
    num = key;
  } else if (typeof key === "number" && Number.isSafeInteger(key) && key > 0) {
    num = BigInt(key);
  } else if (typeof key === "string") {
    if (key.length !== 2 * groupLen)
      throw new Error("Expected 32 bytes of private key");
    num = hexToNumber(key);
  } else if (key instanceof Uint8Array) {
    if (key.length !== groupLen)
      throw new Error("Expected 32 bytes of private key");
    num = bytesToNumber(key);
  } else {
    throw new TypeError("Expected valid private key");
  }
  if (!isWithinCurveOrder(num))
    throw new Error("Expected private key: 0 < key < n");
  return num;
}
function normalizeSignature(signature2) {
  if (signature2 instanceof Signature2) {
    signature2.assertValidity();
    return signature2;
  }
  try {
    return Signature2.fromDER(signature2);
  } catch (error) {
    return Signature2.fromCompact(signature2);
  }
}
function getPublicKey(privateKey, isCompressed = false) {
  return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
}
function bits2int(bytes2) {
  const slice = bytes2.length > fieldLen ? bytes2.slice(0, fieldLen) : bytes2;
  return bytesToNumber(slice);
}
function bits2octets(bytes2) {
  const z1 = bits2int(bytes2);
  const z2 = mod2(z1, CURVE2.n);
  return int2octets(z2 < _0n3 ? z1 : z2);
}
function int2octets(num) {
  return numTo32b(num);
}
function initSigArgs(msgHash, privateKey, extraEntropy) {
  if (msgHash == null)
    throw new Error(`sign: expected valid message hash, not "${msgHash}"`);
  const h1 = ensureBytes2(msgHash);
  const d2 = normalizePrivateKey(privateKey);
  const seedArgs = [int2octets(d2), bits2octets(h1)];
  if (extraEntropy != null) {
    if (extraEntropy === true)
      extraEntropy = utils2.randomBytes(fieldLen);
    const e = ensureBytes2(extraEntropy);
    if (e.length !== fieldLen)
      throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);
    seedArgs.push(e);
  }
  const seed = concatBytes2(...seedArgs);
  const m2 = bits2int(h1);
  return { seed, m: m2, d: d2 };
}
function finalizeSig(recSig, opts) {
  const { sig, recovery } = recSig;
  const { der, recovered } = Object.assign({ canonical: true, der: true }, opts);
  const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
  return recovered ? [hashed, recovery] : hashed;
}
function signSync2(msgHash, privKey, opts = {}) {
  const { seed, m: m2, d: d2 } = initSigArgs(msgHash, privKey, opts.extraEntropy);
  const drbg = new HmacDrbg(hashLen, groupLen);
  drbg.reseedSync(seed);
  let sig;
  while (!(sig = kmdToSig(drbg.generateSync(), m2, d2, opts.canonical)))
    drbg.reseedSync();
  return finalizeSig(sig, opts);
}
Point2.BASE._setWindowSize(8);
var crypto7 = {
  node: nodeCrypto2,
  web: typeof self === "object" && "crypto" in self ? self.crypto : void 0
};
var TAGGED_HASH_PREFIXES = {};
var utils2 = {
  bytesToHex: bytesToHex2,
  hexToBytes: hexToBytes2,
  concatBytes: concatBytes2,
  mod: mod2,
  invert: invert2,
  isValidPrivateKey(privateKey) {
    try {
      normalizePrivateKey(privateKey);
      return true;
    } catch (error) {
      return false;
    }
  },
  _bigintTo32Bytes: numTo32b,
  _normalizePrivateKey: normalizePrivateKey,
  hashToPrivateKey: (hash2) => {
    hash2 = ensureBytes2(hash2);
    const minLen = groupLen + 8;
    if (hash2.length < minLen || hash2.length > 1024) {
      throw new Error(`Expected valid bytes of private key as per FIPS 186`);
    }
    const num = mod2(bytesToNumber(hash2), CURVE2.n - _1n3) + _1n3;
    return numTo32b(num);
  },
  randomBytes: (bytesLength = 32) => {
    if (crypto7.web) {
      return crypto7.web.getRandomValues(new Uint8Array(bytesLength));
    } else if (crypto7.node) {
      const { randomBytes } = crypto7.node;
      return Uint8Array.from(randomBytes(bytesLength));
    } else {
      throw new Error("The environment doesn't have randomBytes function");
    }
  },
  randomPrivateKey: () => utils2.hashToPrivateKey(utils2.randomBytes(groupLen + 8)),
  precompute(windowSize = 8, point = Point2.BASE) {
    const cached = point === Point2.BASE ? point : new Point2(point.x, point.y);
    cached._setWindowSize(windowSize);
    cached.multiply(_3n);
    return cached;
  },
  sha256: (...messages) => __async(void 0, null, function* () {
    if (crypto7.web) {
      const buffer = yield crypto7.web.subtle.digest("SHA-256", concatBytes2(...messages));
      return new Uint8Array(buffer);
    } else if (crypto7.node) {
      const { createHash } = crypto7.node;
      const hash2 = createHash("sha256");
      messages.forEach((m2) => hash2.update(m2));
      return Uint8Array.from(hash2.digest());
    } else {
      throw new Error("The environment doesn't have sha256 function");
    }
  }),
  hmacSha256: (key, ...messages) => __async(void 0, null, function* () {
    if (crypto7.web) {
      const ckey = yield crypto7.web.subtle.importKey("raw", key, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
      const message2 = concatBytes2(...messages);
      const buffer = yield crypto7.web.subtle.sign("HMAC", ckey, message2);
      return new Uint8Array(buffer);
    } else if (crypto7.node) {
      const { createHmac } = crypto7.node;
      const hash2 = createHmac("sha256", key);
      messages.forEach((m2) => hash2.update(m2));
      return Uint8Array.from(hash2.digest());
    } else {
      throw new Error("The environment doesn't have hmac-sha256 function");
    }
  }),
  sha256Sync: void 0,
  hmacSha256Sync: void 0,
  taggedHash: (tag, ...messages) => __async(void 0, null, function* () {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === void 0) {
      const tagH = yield utils2.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
      tagP = concatBytes2(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return utils2.sha256(tagP, ...messages);
  }),
  taggedHashSync: (tag, ...messages) => {
    if (typeof _sha256Sync !== "function")
      throw new ShaError("sha256Sync is undefined, you need to set it");
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === void 0) {
      const tagH = _sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
      tagP = concatBytes2(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return _sha256Sync(tagP, ...messages);
  },
  _JacobianPoint: JacobianPoint
};
Object.defineProperties(utils2, {
  sha256Sync: {
    configurable: false,
    get() {
      return _sha256Sync;
    },
    set(val) {
      if (!_sha256Sync)
        _sha256Sync = val;
    }
  },
  hmacSha256Sync: {
    configurable: false,
    get() {
      return _hmacSha256Sync;
    },
    set(val) {
      if (!_hmacSha256Sync)
        _hmacSha256Sync = val;
    }
  }
});

// ../../node_modules/@solana/web3.js/lib/index.esm.js
utils.sha512Sync = (...m2) => sha512(utils.concatBytes(...m2));
var generatePrivateKey = utils.randomPrivateKey;
var generateKeypair = () => {
  const privateScalar = utils.randomPrivateKey();
  const publicKey3 = getPublicKey2(privateScalar);
  const secretKey = new Uint8Array(64);
  secretKey.set(privateScalar);
  secretKey.set(publicKey3, 32);
  return {
    publicKey: publicKey3,
    secretKey
  };
};
var getPublicKey2 = sync.getPublicKey;
function isOnCurve(publicKey3) {
  try {
    Point.fromHex(
      publicKey3,
      true
      /* strict */
    );
    return true;
  } catch (e) {
    return false;
  }
}
var sign = (message2, secretKey) => sync.sign(message2, secretKey.slice(0, 32));
var verify = sync.verify;
var toBuffer = (arr) => {
  if (Buffer2.isBuffer(arr)) {
    return arr;
  } else if (arr instanceof Uint8Array) {
    return Buffer2.from(arr.buffer, arr.byteOffset, arr.byteLength);
  } else {
    return Buffer2.from(arr);
  }
};
var Struct2 = class {
  constructor(properties) {
    Object.assign(this, properties);
  }
  encode() {
    return Buffer2.from((0, import_borsh.serialize)(SOLANA_SCHEMA, this));
  }
  static decode(data) {
    return (0, import_borsh.deserialize)(SOLANA_SCHEMA, this, data);
  }
  static decodeUnchecked(data) {
    return (0, import_borsh.deserializeUnchecked)(SOLANA_SCHEMA, this, data);
  }
};
var Enum = class extends Struct2 {
  constructor(properties) {
    super(properties);
    this.enum = "";
    if (Object.keys(properties).length !== 1) {
      throw new Error("Enum can only take single value");
    }
    Object.keys(properties).map((key) => {
      this.enum = key;
    });
  }
};
var SOLANA_SCHEMA = /* @__PURE__ */ new Map();
var _Symbol$toStringTag;
var MAX_SEED_LENGTH = 32;
var PUBLIC_KEY_LENGTH = 32;
function isPublicKeyData(value) {
  return value._bn !== void 0;
}
var uniquePublicKeyCounter = 1;
_Symbol$toStringTag = Symbol.toStringTag;
var PublicKey = class extends Struct2 {
  /** @internal */
  /**
   * Create a new PublicKey object
   * @param value ed25519 public key as buffer or base-58 encoded string
   */
  constructor(value) {
    super({});
    this._bn = void 0;
    if (isPublicKeyData(value)) {
      this._bn = value._bn;
    } else {
      if (typeof value === "string") {
        const decoded = import_bs58.default.decode(value);
        if (decoded.length != PUBLIC_KEY_LENGTH) {
          throw new Error(`Invalid public key input`);
        }
        this._bn = new import_bn.default(decoded);
      } else {
        this._bn = new import_bn.default(value);
      }
      if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {
        throw new Error(`Invalid public key input`);
      }
    }
  }
  /**
   * Returns a unique PublicKey for tests and benchmarks using a counter
   */
  static unique() {
    const key = new PublicKey(uniquePublicKeyCounter);
    uniquePublicKeyCounter += 1;
    return new PublicKey(key.toBuffer());
  }
  /**
   * Default public key value. The base58-encoded string representation is all ones (as seen below)
   * The underlying BN number is 32 bytes that are all zeros
   */
  /**
   * Checks if two publicKeys are equal
   */
  equals(publicKey3) {
    return this._bn.eq(publicKey3._bn);
  }
  /**
   * Return the base-58 representation of the public key
   */
  toBase58() {
    return import_bs58.default.encode(this.toBytes());
  }
  toJSON() {
    return this.toBase58();
  }
  /**
   * Return the byte array representation of the public key in big endian
   */
  toBytes() {
    const buf = this.toBuffer();
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  /**
   * Return the Buffer representation of the public key in big endian
   */
  toBuffer() {
    const b = this._bn.toArrayLike(Buffer2);
    if (b.length === PUBLIC_KEY_LENGTH) {
      return b;
    }
    const zeroPad = Buffer2.alloc(32);
    b.copy(zeroPad, 32 - b.length);
    return zeroPad;
  }
  get [_Symbol$toStringTag]() {
    return `PublicKey(${this.toString()})`;
  }
  /**
   * Return the base-58 representation of the public key
   */
  toString() {
    return this.toBase58();
  }
  /**
   * Derive a public key from another key, a seed, and a program ID.
   * The program ID will also serve as the owner of the public key, giving
   * it permission to write data to the account.
   */
  /* eslint-disable require-await */
  static createWithSeed(fromPublicKey, seed, programId) {
    return __async(this, null, function* () {
      const buffer = Buffer2.concat([fromPublicKey.toBuffer(), Buffer2.from(seed), programId.toBuffer()]);
      const publicKeyBytes = sha256(buffer);
      return new PublicKey(publicKeyBytes);
    });
  }
  /**
   * Derive a program address from seeds and a program ID.
   */
  /* eslint-disable require-await */
  static createProgramAddressSync(seeds, programId) {
    let buffer = Buffer2.alloc(0);
    seeds.forEach(function(seed) {
      if (seed.length > MAX_SEED_LENGTH) {
        throw new TypeError(`Max seed length exceeded`);
      }
      buffer = Buffer2.concat([buffer, toBuffer(seed)]);
    });
    buffer = Buffer2.concat([buffer, programId.toBuffer(), Buffer2.from("ProgramDerivedAddress")]);
    const publicKeyBytes = sha256(buffer);
    if (isOnCurve(publicKeyBytes)) {
      throw new Error(`Invalid seeds, address must fall off the curve`);
    }
    return new PublicKey(publicKeyBytes);
  }
  /**
   * Async version of createProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link createProgramAddressSync} instead
   */
  /* eslint-disable require-await */
  static createProgramAddress(seeds, programId) {
    return __async(this, null, function* () {
      return this.createProgramAddressSync(seeds, programId);
    });
  }
  /**
   * Find a valid program address
   *
   * Valid program addresses must fall off the ed25519 curve.  This function
   * iterates a nonce until it finds one that when combined with the seeds
   * results in a valid program address.
   */
  static findProgramAddressSync(seeds, programId) {
    let nonce = 255;
    let address;
    while (nonce != 0) {
      try {
        const seedsWithNonce = seeds.concat(Buffer2.from([nonce]));
        address = this.createProgramAddressSync(seedsWithNonce, programId);
      } catch (err) {
        if (err instanceof TypeError) {
          throw err;
        }
        nonce--;
        continue;
      }
      return [address, nonce];
    }
    throw new Error(`Unable to find a viable program address nonce`);
  }
  /**
   * Async version of findProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link findProgramAddressSync} instead
   */
  static findProgramAddress(seeds, programId) {
    return __async(this, null, function* () {
      return this.findProgramAddressSync(seeds, programId);
    });
  }
  /**
   * Check that a pubkey is on the ed25519 curve.
   */
  static isOnCurve(pubkeyData) {
    const pubkey = new PublicKey(pubkeyData);
    return isOnCurve(pubkey.toBytes());
  }
};
PublicKey.default = new PublicKey("11111111111111111111111111111111");
SOLANA_SCHEMA.set(PublicKey, {
  kind: "struct",
  fields: [["_bn", "u256"]]
});
var Account = class {
  /** @internal */
  /** @internal */
  /**
   * Create a new Account object
   *
   * If the secretKey parameter is not provided a new key pair is randomly
   * created for the account
   *
   * @param secretKey Secret key for the account
   */
  constructor(secretKey) {
    this._publicKey = void 0;
    this._secretKey = void 0;
    if (secretKey) {
      const secretKeyBuffer = toBuffer(secretKey);
      if (secretKey.length !== 64) {
        throw new Error("bad secret key size");
      }
      this._publicKey = secretKeyBuffer.slice(32, 64);
      this._secretKey = secretKeyBuffer.slice(0, 32);
    } else {
      this._secretKey = toBuffer(generatePrivateKey());
      this._publicKey = toBuffer(getPublicKey2(this._secretKey));
    }
  }
  /**
   * The public key for this account
   */
  get publicKey() {
    return new PublicKey(this._publicKey);
  }
  /**
   * The **unencrypted** secret key for this account. The first 32 bytes
   * is the private scalar and the last 32 bytes is the public key.
   * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
   */
  get secretKey() {
    return Buffer2.concat([this._secretKey, this._publicKey], 64);
  }
};
var BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey("BPFLoader1111111111111111111111111111111111");
var PACKET_DATA_SIZE = 1280 - 40 - 8;
var VERSION_PREFIX_MASK = 127;
var SIGNATURE_LENGTH_IN_BYTES = 64;
var TransactionExpiredBlockheightExceededError = class extends Error {
  constructor(signature2) {
    super(`Signature ${signature2} has expired: block height exceeded.`);
    this.signature = void 0;
    this.signature = signature2;
  }
};
Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype, "name", {
  value: "TransactionExpiredBlockheightExceededError"
});
var TransactionExpiredTimeoutError = class extends Error {
  constructor(signature2, timeoutSeconds) {
    super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${signature2} using the Solana Explorer or CLI tools.`);
    this.signature = void 0;
    this.signature = signature2;
  }
};
Object.defineProperty(TransactionExpiredTimeoutError.prototype, "name", {
  value: "TransactionExpiredTimeoutError"
});
var TransactionExpiredNonceInvalidError = class extends Error {
  constructor(signature2) {
    super(`Signature ${signature2} has expired: the nonce is no longer valid.`);
    this.signature = void 0;
    this.signature = signature2;
  }
};
Object.defineProperty(TransactionExpiredNonceInvalidError.prototype, "name", {
  value: "TransactionExpiredNonceInvalidError"
});
var MessageAccountKeys = class {
  constructor(staticAccountKeys, accountKeysFromLookups) {
    this.staticAccountKeys = void 0;
    this.accountKeysFromLookups = void 0;
    this.staticAccountKeys = staticAccountKeys;
    this.accountKeysFromLookups = accountKeysFromLookups;
  }
  keySegments() {
    const keySegments = [this.staticAccountKeys];
    if (this.accountKeysFromLookups) {
      keySegments.push(this.accountKeysFromLookups.writable);
      keySegments.push(this.accountKeysFromLookups.readonly);
    }
    return keySegments;
  }
  get(index) {
    for (const keySegment of this.keySegments()) {
      if (index < keySegment.length) {
        return keySegment[index];
      } else {
        index -= keySegment.length;
      }
    }
    return;
  }
  get length() {
    return this.keySegments().flat().length;
  }
  compileInstructions(instructions) {
    const U8_MAX = 255;
    if (this.length > U8_MAX + 1) {
      throw new Error("Account index overflow encountered during compilation");
    }
    const keyIndexMap = /* @__PURE__ */ new Map();
    this.keySegments().flat().forEach((key, index) => {
      keyIndexMap.set(key.toBase58(), index);
    });
    const findKeyIndex = (key) => {
      const keyIndex = keyIndexMap.get(key.toBase58());
      if (keyIndex === void 0)
        throw new Error("Encountered an unknown instruction account key during compilation");
      return keyIndex;
    };
    return instructions.map((instruction) => {
      return {
        programIdIndex: findKeyIndex(instruction.programId),
        accountKeyIndexes: instruction.keys.map((meta) => findKeyIndex(meta.pubkey)),
        data: instruction.data
      };
    });
  }
};
var publicKey = (property = "publicKey") => {
  return BufferLayout.blob(32, property);
};
var signature = (property = "signature") => {
  return BufferLayout.blob(64, property);
};
var rustString = (property = "string") => {
  const rsl = BufferLayout.struct([BufferLayout.u32("length"), BufferLayout.u32("lengthPadding"), BufferLayout.blob(BufferLayout.offset(BufferLayout.u32(), -8), "chars")], property);
  const _decode = rsl.decode.bind(rsl);
  const _encode = rsl.encode.bind(rsl);
  const rslShim = rsl;
  rslShim.decode = (b, offset2) => {
    const data = _decode(b, offset2);
    return data["chars"].toString();
  };
  rslShim.encode = (str, b, offset2) => {
    const data = {
      chars: Buffer2.from(str, "utf8")
    };
    return _encode(data, b, offset2);
  };
  rslShim.alloc = (str) => {
    return BufferLayout.u32().span + BufferLayout.u32().span + Buffer2.from(str, "utf8").length;
  };
  return rslShim;
};
var authorized = (property = "authorized") => {
  return BufferLayout.struct([publicKey("staker"), publicKey("withdrawer")], property);
};
var lockup = (property = "lockup") => {
  return BufferLayout.struct([BufferLayout.ns64("unixTimestamp"), BufferLayout.ns64("epoch"), publicKey("custodian")], property);
};
var voteInit = (property = "voteInit") => {
  return BufferLayout.struct([publicKey("nodePubkey"), publicKey("authorizedVoter"), publicKey("authorizedWithdrawer"), BufferLayout.u8("commission")], property);
};
var voteAuthorizeWithSeedArgs = (property = "voteAuthorizeWithSeedArgs") => {
  return BufferLayout.struct([BufferLayout.u32("voteAuthorizationType"), publicKey("currentAuthorityDerivedKeyOwnerPubkey"), rustString("currentAuthorityDerivedKeySeed"), publicKey("newAuthorized")], property);
};
function getAlloc(type2, fields) {
  const getItemAlloc = (item) => {
    if (item.span >= 0) {
      return item.span;
    } else if (typeof item.alloc === "function") {
      return item.alloc(fields[item.property]);
    } else if ("count" in item && "elementLayout" in item) {
      const field = fields[item.property];
      if (Array.isArray(field)) {
        return field.length * getItemAlloc(item.elementLayout);
      }
    } else if ("fields" in item) {
      return getAlloc({
        layout: item
      }, fields[item.property]);
    }
    return 0;
  };
  let alloc = 0;
  type2.layout.fields.forEach((item) => {
    alloc += getItemAlloc(item);
  });
  return alloc;
}
function decodeLength(bytes2) {
  let len = 0;
  let size = 0;
  for (; ; ) {
    let elem = bytes2.shift();
    len |= (elem & 127) << size * 7;
    size += 1;
    if ((elem & 128) === 0) {
      break;
    }
  }
  return len;
}
function encodeLength(bytes2, len) {
  let rem_len = len;
  for (; ; ) {
    let elem = rem_len & 127;
    rem_len >>= 7;
    if (rem_len == 0) {
      bytes2.push(elem);
      break;
    } else {
      elem |= 128;
      bytes2.push(elem);
    }
  }
}
function assert3(condition, message2) {
  if (!condition) {
    throw new Error(message2 || "Assertion failed");
  }
}
var CompiledKeys = class {
  constructor(payer, keyMetaMap) {
    this.payer = void 0;
    this.keyMetaMap = void 0;
    this.payer = payer;
    this.keyMetaMap = keyMetaMap;
  }
  static compile(instructions, payer) {
    const keyMetaMap = /* @__PURE__ */ new Map();
    const getOrInsertDefault = (pubkey) => {
      const address = pubkey.toBase58();
      let keyMeta = keyMetaMap.get(address);
      if (keyMeta === void 0) {
        keyMeta = {
          isSigner: false,
          isWritable: false,
          isInvoked: false
        };
        keyMetaMap.set(address, keyMeta);
      }
      return keyMeta;
    };
    const payerKeyMeta = getOrInsertDefault(payer);
    payerKeyMeta.isSigner = true;
    payerKeyMeta.isWritable = true;
    for (const ix of instructions) {
      getOrInsertDefault(ix.programId).isInvoked = true;
      for (const accountMeta of ix.keys) {
        const keyMeta = getOrInsertDefault(accountMeta.pubkey);
        keyMeta.isSigner || (keyMeta.isSigner = accountMeta.isSigner);
        keyMeta.isWritable || (keyMeta.isWritable = accountMeta.isWritable);
      }
    }
    return new CompiledKeys(payer, keyMetaMap);
  }
  getMessageComponents() {
    const mapEntries = [...this.keyMetaMap.entries()];
    assert3(mapEntries.length <= 256, "Max static account keys length exceeded");
    const writableSigners = mapEntries.filter(([, meta]) => meta.isSigner && meta.isWritable);
    const readonlySigners = mapEntries.filter(([, meta]) => meta.isSigner && !meta.isWritable);
    const writableNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && meta.isWritable);
    const readonlyNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && !meta.isWritable);
    const header = {
      numRequiredSignatures: writableSigners.length + readonlySigners.length,
      numReadonlySignedAccounts: readonlySigners.length,
      numReadonlyUnsignedAccounts: readonlyNonSigners.length
    };
    {
      assert3(writableSigners.length > 0, "Expected at least one writable signer key");
      const [payerAddress] = writableSigners[0];
      assert3(payerAddress === this.payer.toBase58(), "Expected first writable signer key to be the fee payer");
    }
    const staticAccountKeys = [...writableSigners.map(([address]) => new PublicKey(address)), ...readonlySigners.map(([address]) => new PublicKey(address)), ...writableNonSigners.map(([address]) => new PublicKey(address)), ...readonlyNonSigners.map(([address]) => new PublicKey(address))];
    return [header, staticAccountKeys];
  }
  extractTableLookup(lookupTable) {
    const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);
    const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);
    if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {
      return;
    }
    return [{
      accountKey: lookupTable.key,
      writableIndexes,
      readonlyIndexes
    }, {
      writable: drainedWritableKeys,
      readonly: drainedReadonlyKeys
    }];
  }
  /** @internal */
  drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
    const lookupTableIndexes = new Array();
    const drainedKeys = new Array();
    for (const [address, keyMeta] of this.keyMetaMap.entries()) {
      if (keyMetaFilter(keyMeta)) {
        const key = new PublicKey(address);
        const lookupTableIndex = lookupTableEntries.findIndex((entry) => entry.equals(key));
        if (lookupTableIndex >= 0) {
          assert3(lookupTableIndex < 256, "Max lookup table index exceeded");
          lookupTableIndexes.push(lookupTableIndex);
          drainedKeys.push(key);
          this.keyMetaMap.delete(address);
        }
      }
    }
    return [lookupTableIndexes, drainedKeys];
  }
};
var Message = class {
  constructor(args2) {
    this.header = void 0;
    this.accountKeys = void 0;
    this.recentBlockhash = void 0;
    this.instructions = void 0;
    this.indexToProgramIds = /* @__PURE__ */ new Map();
    this.header = args2.header;
    this.accountKeys = args2.accountKeys.map((account) => new PublicKey(account));
    this.recentBlockhash = args2.recentBlockhash;
    this.instructions = args2.instructions;
    this.instructions.forEach((ix) => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));
  }
  get version() {
    return "legacy";
  }
  get staticAccountKeys() {
    return this.accountKeys;
  }
  get compiledInstructions() {
    return this.instructions.map((ix) => ({
      programIdIndex: ix.programIdIndex,
      accountKeyIndexes: ix.accounts,
      data: import_bs58.default.decode(ix.data)
    }));
  }
  get addressTableLookups() {
    return [];
  }
  getAccountKeys() {
    return new MessageAccountKeys(this.staticAccountKeys);
  }
  static compile(args2) {
    const compiledKeys = CompiledKeys.compile(args2.instructions, args2.payerKey);
    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
    const accountKeys = new MessageAccountKeys(staticAccountKeys);
    const instructions = accountKeys.compileInstructions(args2.instructions).map((ix) => ({
      programIdIndex: ix.programIdIndex,
      accounts: ix.accountKeyIndexes,
      data: import_bs58.default.encode(ix.data)
    }));
    return new Message({
      header,
      accountKeys: staticAccountKeys,
      recentBlockhash: args2.recentBlockhash,
      instructions
    });
  }
  isAccountSigner(index) {
    return index < this.header.numRequiredSignatures;
  }
  isAccountWritable(index) {
    const numSignedAccounts = this.header.numRequiredSignatures;
    if (index >= this.header.numRequiredSignatures) {
      const unsignedAccountIndex = index - numSignedAccounts;
      const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;
      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
      return unsignedAccountIndex < numWritableUnsignedAccounts;
    } else {
      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
      return index < numWritableSignedAccounts;
    }
  }
  isProgramId(index) {
    return this.indexToProgramIds.has(index);
  }
  programIds() {
    return [...this.indexToProgramIds.values()];
  }
  nonProgramIds() {
    return this.accountKeys.filter((_, index) => !this.isProgramId(index));
  }
  serialize() {
    const numKeys = this.accountKeys.length;
    let keyCount = [];
    encodeLength(keyCount, numKeys);
    const instructions = this.instructions.map((instruction) => {
      const {
        accounts,
        programIdIndex
      } = instruction;
      const data = Array.from(import_bs58.default.decode(instruction.data));
      let keyIndicesCount = [];
      encodeLength(keyIndicesCount, accounts.length);
      let dataCount = [];
      encodeLength(dataCount, data.length);
      return {
        programIdIndex,
        keyIndicesCount: Buffer2.from(keyIndicesCount),
        keyIndices: accounts,
        dataLength: Buffer2.from(dataCount),
        data
      };
    });
    let instructionCount = [];
    encodeLength(instructionCount, instructions.length);
    let instructionBuffer = Buffer2.alloc(PACKET_DATA_SIZE);
    Buffer2.from(instructionCount).copy(instructionBuffer);
    let instructionBufferLength = instructionCount.length;
    instructions.forEach((instruction) => {
      const instructionLayout = BufferLayout.struct([BufferLayout.u8("programIdIndex"), BufferLayout.blob(instruction.keyIndicesCount.length, "keyIndicesCount"), BufferLayout.seq(BufferLayout.u8("keyIndex"), instruction.keyIndices.length, "keyIndices"), BufferLayout.blob(instruction.dataLength.length, "dataLength"), BufferLayout.seq(BufferLayout.u8("userdatum"), instruction.data.length, "data")]);
      const length2 = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
      instructionBufferLength += length2;
    });
    instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
    const signDataLayout = BufferLayout.struct([BufferLayout.blob(1, "numRequiredSignatures"), BufferLayout.blob(1, "numReadonlySignedAccounts"), BufferLayout.blob(1, "numReadonlyUnsignedAccounts"), BufferLayout.blob(keyCount.length, "keyCount"), BufferLayout.seq(publicKey("key"), numKeys, "keys"), publicKey("recentBlockhash")]);
    const transaction = {
      numRequiredSignatures: Buffer2.from([this.header.numRequiredSignatures]),
      numReadonlySignedAccounts: Buffer2.from([this.header.numReadonlySignedAccounts]),
      numReadonlyUnsignedAccounts: Buffer2.from([this.header.numReadonlyUnsignedAccounts]),
      keyCount: Buffer2.from(keyCount),
      keys: this.accountKeys.map((key) => toBuffer(key.toBytes())),
      recentBlockhash: import_bs58.default.decode(this.recentBlockhash)
    };
    let signData = Buffer2.alloc(2048);
    const length = signDataLayout.encode(transaction, signData);
    instructionBuffer.copy(signData, length);
    return signData.slice(0, length + instructionBuffer.length);
  }
  /**
   * Decode a compiled message into a Message object.
   */
  static from(buffer) {
    let byteArray = [...buffer];
    const numRequiredSignatures = byteArray.shift();
    if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {
      throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
    }
    const numReadonlySignedAccounts = byteArray.shift();
    const numReadonlyUnsignedAccounts = byteArray.shift();
    const accountCount = decodeLength(byteArray);
    let accountKeys = [];
    for (let i = 0; i < accountCount; i++) {
      const account = byteArray.slice(0, PUBLIC_KEY_LENGTH);
      byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
      accountKeys.push(new PublicKey(Buffer2.from(account)));
    }
    const recentBlockhash = byteArray.slice(0, PUBLIC_KEY_LENGTH);
    byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
    const instructionCount = decodeLength(byteArray);
    let instructions = [];
    for (let i = 0; i < instructionCount; i++) {
      const programIdIndex = byteArray.shift();
      const accountCount2 = decodeLength(byteArray);
      const accounts = byteArray.slice(0, accountCount2);
      byteArray = byteArray.slice(accountCount2);
      const dataLength = decodeLength(byteArray);
      const dataSlice = byteArray.slice(0, dataLength);
      const data = import_bs58.default.encode(Buffer2.from(dataSlice));
      byteArray = byteArray.slice(dataLength);
      instructions.push({
        programIdIndex,
        accounts,
        data
      });
    }
    const messageArgs = {
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      recentBlockhash: import_bs58.default.encode(Buffer2.from(recentBlockhash)),
      accountKeys,
      instructions
    };
    return new Message(messageArgs);
  }
};
var MessageV0 = class {
  constructor(args2) {
    this.header = void 0;
    this.staticAccountKeys = void 0;
    this.recentBlockhash = void 0;
    this.compiledInstructions = void 0;
    this.addressTableLookups = void 0;
    this.header = args2.header;
    this.staticAccountKeys = args2.staticAccountKeys;
    this.recentBlockhash = args2.recentBlockhash;
    this.compiledInstructions = args2.compiledInstructions;
    this.addressTableLookups = args2.addressTableLookups;
  }
  get version() {
    return 0;
  }
  get numAccountKeysFromLookups() {
    let count = 0;
    for (const lookup of this.addressTableLookups) {
      count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;
    }
    return count;
  }
  getAccountKeys(args2) {
    let accountKeysFromLookups;
    if (args2 && "accountKeysFromLookups" in args2 && args2.accountKeysFromLookups) {
      if (this.numAccountKeysFromLookups != args2.accountKeysFromLookups.writable.length + args2.accountKeysFromLookups.readonly.length) {
        throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
      }
      accountKeysFromLookups = args2.accountKeysFromLookups;
    } else if (args2 && "addressLookupTableAccounts" in args2 && args2.addressLookupTableAccounts) {
      accountKeysFromLookups = this.resolveAddressTableLookups(args2.addressLookupTableAccounts);
    } else if (this.addressTableLookups.length > 0) {
      throw new Error("Failed to get account keys because address table lookups were not resolved");
    }
    return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);
  }
  isAccountSigner(index) {
    return index < this.header.numRequiredSignatures;
  }
  isAccountWritable(index) {
    const numSignedAccounts = this.header.numRequiredSignatures;
    const numStaticAccountKeys = this.staticAccountKeys.length;
    if (index >= numStaticAccountKeys) {
      const lookupAccountKeysIndex = index - numStaticAccountKeys;
      const numWritableLookupAccountKeys = this.addressTableLookups.reduce((count, lookup) => count + lookup.writableIndexes.length, 0);
      return lookupAccountKeysIndex < numWritableLookupAccountKeys;
    } else if (index >= this.header.numRequiredSignatures) {
      const unsignedAccountIndex = index - numSignedAccounts;
      const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;
      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
      return unsignedAccountIndex < numWritableUnsignedAccounts;
    } else {
      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
      return index < numWritableSignedAccounts;
    }
  }
  resolveAddressTableLookups(addressLookupTableAccounts) {
    const accountKeysFromLookups = {
      writable: [],
      readonly: []
    };
    for (const tableLookup of this.addressTableLookups) {
      const tableAccount = addressLookupTableAccounts.find((account) => account.key.equals(tableLookup.accountKey));
      if (!tableAccount) {
        throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);
      }
      for (const index of tableLookup.writableIndexes) {
        if (index < tableAccount.state.addresses.length) {
          accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);
        } else {
          throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);
        }
      }
      for (const index of tableLookup.readonlyIndexes) {
        if (index < tableAccount.state.addresses.length) {
          accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index]);
        } else {
          throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);
        }
      }
    }
    return accountKeysFromLookups;
  }
  static compile(args2) {
    const compiledKeys = CompiledKeys.compile(args2.instructions, args2.payerKey);
    const addressTableLookups = new Array();
    const accountKeysFromLookups = {
      writable: new Array(),
      readonly: new Array()
    };
    const lookupTableAccounts = args2.addressLookupTableAccounts || [];
    for (const lookupTable of lookupTableAccounts) {
      const extractResult = compiledKeys.extractTableLookup(lookupTable);
      if (extractResult !== void 0) {
        const [addressTableLookup, {
          writable,
          readonly
        }] = extractResult;
        addressTableLookups.push(addressTableLookup);
        accountKeysFromLookups.writable.push(...writable);
        accountKeysFromLookups.readonly.push(...readonly);
      }
    }
    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();
    const accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);
    const compiledInstructions = accountKeys.compileInstructions(args2.instructions);
    return new MessageV0({
      header,
      staticAccountKeys,
      recentBlockhash: args2.recentBlockhash,
      compiledInstructions,
      addressTableLookups
    });
  }
  serialize() {
    const encodedStaticAccountKeysLength = Array();
    encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);
    const serializedInstructions = this.serializeInstructions();
    const encodedInstructionsLength = Array();
    encodeLength(encodedInstructionsLength, this.compiledInstructions.length);
    const serializedAddressTableLookups = this.serializeAddressTableLookups();
    const encodedAddressTableLookupsLength = Array();
    encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);
    const messageLayout = BufferLayout.struct([BufferLayout.u8("prefix"), BufferLayout.struct([BufferLayout.u8("numRequiredSignatures"), BufferLayout.u8("numReadonlySignedAccounts"), BufferLayout.u8("numReadonlyUnsignedAccounts")], "header"), BufferLayout.blob(encodedStaticAccountKeysLength.length, "staticAccountKeysLength"), BufferLayout.seq(publicKey(), this.staticAccountKeys.length, "staticAccountKeys"), publicKey("recentBlockhash"), BufferLayout.blob(encodedInstructionsLength.length, "instructionsLength"), BufferLayout.blob(serializedInstructions.length, "serializedInstructions"), BufferLayout.blob(encodedAddressTableLookupsLength.length, "addressTableLookupsLength"), BufferLayout.blob(serializedAddressTableLookups.length, "serializedAddressTableLookups")]);
    const serializedMessage = new Uint8Array(PACKET_DATA_SIZE);
    const MESSAGE_VERSION_0_PREFIX = 1 << 7;
    const serializedMessageLength = messageLayout.encode({
      prefix: MESSAGE_VERSION_0_PREFIX,
      header: this.header,
      staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),
      staticAccountKeys: this.staticAccountKeys.map((key) => key.toBytes()),
      recentBlockhash: import_bs58.default.decode(this.recentBlockhash),
      instructionsLength: new Uint8Array(encodedInstructionsLength),
      serializedInstructions,
      addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),
      serializedAddressTableLookups
    }, serializedMessage);
    return serializedMessage.slice(0, serializedMessageLength);
  }
  serializeInstructions() {
    let serializedLength = 0;
    const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);
    for (const instruction of this.compiledInstructions) {
      const encodedAccountKeyIndexesLength = Array();
      encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);
      const encodedDataLength = Array();
      encodeLength(encodedDataLength, instruction.data.length);
      const instructionLayout = BufferLayout.struct([BufferLayout.u8("programIdIndex"), BufferLayout.blob(encodedAccountKeyIndexesLength.length, "encodedAccountKeyIndexesLength"), BufferLayout.seq(BufferLayout.u8(), instruction.accountKeyIndexes.length, "accountKeyIndexes"), BufferLayout.blob(encodedDataLength.length, "encodedDataLength"), BufferLayout.blob(instruction.data.length, "data")]);
      serializedLength += instructionLayout.encode({
        programIdIndex: instruction.programIdIndex,
        encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),
        accountKeyIndexes: instruction.accountKeyIndexes,
        encodedDataLength: new Uint8Array(encodedDataLength),
        data: instruction.data
      }, serializedInstructions, serializedLength);
    }
    return serializedInstructions.slice(0, serializedLength);
  }
  serializeAddressTableLookups() {
    let serializedLength = 0;
    const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);
    for (const lookup of this.addressTableLookups) {
      const encodedWritableIndexesLength = Array();
      encodeLength(encodedWritableIndexesLength, lookup.writableIndexes.length);
      const encodedReadonlyIndexesLength = Array();
      encodeLength(encodedReadonlyIndexesLength, lookup.readonlyIndexes.length);
      const addressTableLookupLayout = BufferLayout.struct([publicKey("accountKey"), BufferLayout.blob(encodedWritableIndexesLength.length, "encodedWritableIndexesLength"), BufferLayout.seq(BufferLayout.u8(), lookup.writableIndexes.length, "writableIndexes"), BufferLayout.blob(encodedReadonlyIndexesLength.length, "encodedReadonlyIndexesLength"), BufferLayout.seq(BufferLayout.u8(), lookup.readonlyIndexes.length, "readonlyIndexes")]);
      serializedLength += addressTableLookupLayout.encode({
        accountKey: lookup.accountKey.toBytes(),
        encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),
        writableIndexes: lookup.writableIndexes,
        encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),
        readonlyIndexes: lookup.readonlyIndexes
      }, serializedAddressTableLookups, serializedLength);
    }
    return serializedAddressTableLookups.slice(0, serializedLength);
  }
  static deserialize(serializedMessage) {
    let byteArray = [...serializedMessage];
    const prefix = byteArray.shift();
    const maskedPrefix = prefix & VERSION_PREFIX_MASK;
    assert3(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);
    const version2 = maskedPrefix;
    assert3(version2 === 0, `Expected versioned message with version 0 but found version ${version2}`);
    const header = {
      numRequiredSignatures: byteArray.shift(),
      numReadonlySignedAccounts: byteArray.shift(),
      numReadonlyUnsignedAccounts: byteArray.shift()
    };
    const staticAccountKeys = [];
    const staticAccountKeysLength = decodeLength(byteArray);
    for (let i = 0; i < staticAccountKeysLength; i++) {
      staticAccountKeys.push(new PublicKey(byteArray.splice(0, PUBLIC_KEY_LENGTH)));
    }
    const recentBlockhash = import_bs58.default.encode(byteArray.splice(0, PUBLIC_KEY_LENGTH));
    const instructionCount = decodeLength(byteArray);
    const compiledInstructions = [];
    for (let i = 0; i < instructionCount; i++) {
      const programIdIndex = byteArray.shift();
      const accountKeyIndexesLength = decodeLength(byteArray);
      const accountKeyIndexes = byteArray.splice(0, accountKeyIndexesLength);
      const dataLength = decodeLength(byteArray);
      const data = new Uint8Array(byteArray.splice(0, dataLength));
      compiledInstructions.push({
        programIdIndex,
        accountKeyIndexes,
        data
      });
    }
    const addressTableLookupsCount = decodeLength(byteArray);
    const addressTableLookups = [];
    for (let i = 0; i < addressTableLookupsCount; i++) {
      const accountKey = new PublicKey(byteArray.splice(0, PUBLIC_KEY_LENGTH));
      const writableIndexesLength = decodeLength(byteArray);
      const writableIndexes = byteArray.splice(0, writableIndexesLength);
      const readonlyIndexesLength = decodeLength(byteArray);
      const readonlyIndexes = byteArray.splice(0, readonlyIndexesLength);
      addressTableLookups.push({
        accountKey,
        writableIndexes,
        readonlyIndexes
      });
    }
    return new MessageV0({
      header,
      staticAccountKeys,
      recentBlockhash,
      compiledInstructions,
      addressTableLookups
    });
  }
};
var VersionedMessage = {
  deserializeMessageVersion(serializedMessage) {
    const prefix = serializedMessage[0];
    const maskedPrefix = prefix & VERSION_PREFIX_MASK;
    if (maskedPrefix === prefix) {
      return "legacy";
    }
    return maskedPrefix;
  },
  deserialize: (serializedMessage) => {
    const version2 = VersionedMessage.deserializeMessageVersion(serializedMessage);
    if (version2 === "legacy") {
      return Message.from(serializedMessage);
    }
    if (version2 === 0) {
      return MessageV0.deserialize(serializedMessage);
    } else {
      throw new Error(`Transaction message version ${version2} deserialization is not supported`);
    }
  }
};
var TransactionStatus;
(function(TransactionStatus2) {
  TransactionStatus2[TransactionStatus2["BLOCKHEIGHT_EXCEEDED"] = 0] = "BLOCKHEIGHT_EXCEEDED";
  TransactionStatus2[TransactionStatus2["PROCESSED"] = 1] = "PROCESSED";
  TransactionStatus2[TransactionStatus2["TIMED_OUT"] = 2] = "TIMED_OUT";
  TransactionStatus2[TransactionStatus2["NONCE_INVALID"] = 3] = "NONCE_INVALID";
})(TransactionStatus || (TransactionStatus = {}));
var DEFAULT_SIGNATURE = Buffer2.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);
var TransactionInstruction = class {
  /**
   * Public keys to include in this transaction
   * Boolean represents whether this pubkey needs to sign the transaction
   */
  /**
   * Program Id to execute
   */
  /**
   * Program input
   */
  constructor(opts) {
    this.keys = void 0;
    this.programId = void 0;
    this.data = Buffer2.alloc(0);
    this.programId = opts.programId;
    this.keys = opts.keys;
    if (opts.data) {
      this.data = opts.data;
    }
  }
  /**
   * @internal
   */
  toJSON() {
    return {
      keys: this.keys.map(({
        pubkey,
        isSigner,
        isWritable
      }) => ({
        pubkey: pubkey.toJSON(),
        isSigner,
        isWritable
      })),
      programId: this.programId.toJSON(),
      data: [...this.data]
    };
  }
};
var Transaction = class {
  /**
   * Signatures for the transaction.  Typically created by invoking the
   * `sign()` method
   */
  /**
   * The first (payer) Transaction signature
   */
  get signature() {
    if (this.signatures.length > 0) {
      return this.signatures[0].signature;
    }
    return null;
  }
  /**
   * The transaction fee payer
   */
  /**
   * Construct an empty Transaction
   */
  constructor(opts) {
    this.signatures = [];
    this.feePayer = void 0;
    this.instructions = [];
    this.recentBlockhash = void 0;
    this.lastValidBlockHeight = void 0;
    this.nonceInfo = void 0;
    this.minNonceContextSlot = void 0;
    this._message = void 0;
    this._json = void 0;
    if (!opts) {
      return;
    }
    if (opts.feePayer) {
      this.feePayer = opts.feePayer;
    }
    if (opts.signatures) {
      this.signatures = opts.signatures;
    }
    if (Object.prototype.hasOwnProperty.call(opts, "nonceInfo")) {
      const {
        minContextSlot,
        nonceInfo
      } = opts;
      this.minNonceContextSlot = minContextSlot;
      this.nonceInfo = nonceInfo;
    } else if (Object.prototype.hasOwnProperty.call(opts, "lastValidBlockHeight")) {
      const {
        blockhash,
        lastValidBlockHeight
      } = opts;
      this.recentBlockhash = blockhash;
      this.lastValidBlockHeight = lastValidBlockHeight;
    } else {
      const {
        recentBlockhash,
        nonceInfo
      } = opts;
      if (nonceInfo) {
        this.nonceInfo = nonceInfo;
      }
      this.recentBlockhash = recentBlockhash;
    }
  }
  /**
   * @internal
   */
  toJSON() {
    return {
      recentBlockhash: this.recentBlockhash || null,
      feePayer: this.feePayer ? this.feePayer.toJSON() : null,
      nonceInfo: this.nonceInfo ? {
        nonce: this.nonceInfo.nonce,
        nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
      } : null,
      instructions: this.instructions.map((instruction) => instruction.toJSON()),
      signers: this.signatures.map(({
        publicKey: publicKey3
      }) => {
        return publicKey3.toJSON();
      })
    };
  }
  /**
   * Add one or more instructions to this Transaction
   */
  add(...items) {
    if (items.length === 0) {
      throw new Error("No instructions");
    }
    items.forEach((item) => {
      if ("instructions" in item) {
        this.instructions = this.instructions.concat(item.instructions);
      } else if ("data" in item && "programId" in item && "keys" in item) {
        this.instructions.push(item);
      } else {
        this.instructions.push(new TransactionInstruction(item));
      }
    });
    return this;
  }
  /**
   * Compile transaction data
   */
  compileMessage() {
    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {
      return this._message;
    }
    let recentBlockhash;
    let instructions;
    if (this.nonceInfo) {
      recentBlockhash = this.nonceInfo.nonce;
      if (this.instructions[0] != this.nonceInfo.nonceInstruction) {
        instructions = [this.nonceInfo.nonceInstruction, ...this.instructions];
      } else {
        instructions = this.instructions;
      }
    } else {
      recentBlockhash = this.recentBlockhash;
      instructions = this.instructions;
    }
    if (!recentBlockhash) {
      throw new Error("Transaction recentBlockhash required");
    }
    if (instructions.length < 1) {
      console.warn("No instructions provided");
    }
    let feePayer;
    if (this.feePayer) {
      feePayer = this.feePayer;
    } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
      feePayer = this.signatures[0].publicKey;
    } else {
      throw new Error("Transaction fee payer required");
    }
    for (let i = 0; i < instructions.length; i++) {
      if (instructions[i].programId === void 0) {
        throw new Error(`Transaction instruction index ${i} has undefined program id`);
      }
    }
    const programIds = [];
    const accountMetas = [];
    instructions.forEach((instruction) => {
      instruction.keys.forEach((accountMeta) => {
        accountMetas.push(__spreadValues({}, accountMeta));
      });
      const programId = instruction.programId.toString();
      if (!programIds.includes(programId)) {
        programIds.push(programId);
      }
    });
    programIds.forEach((programId) => {
      accountMetas.push({
        pubkey: new PublicKey(programId),
        isSigner: false,
        isWritable: false
      });
    });
    const uniqueMetas = [];
    accountMetas.forEach((accountMeta) => {
      const pubkeyString = accountMeta.pubkey.toString();
      const uniqueIndex = uniqueMetas.findIndex((x) => {
        return x.pubkey.toString() === pubkeyString;
      });
      if (uniqueIndex > -1) {
        uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
        uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
      } else {
        uniqueMetas.push(accountMeta);
      }
    });
    uniqueMetas.sort(function(x, y2) {
      if (x.isSigner !== y2.isSigner) {
        return x.isSigner ? -1 : 1;
      }
      if (x.isWritable !== y2.isWritable) {
        return x.isWritable ? -1 : 1;
      }
      return x.pubkey.toBase58().localeCompare(y2.pubkey.toBase58());
    });
    const feePayerIndex = uniqueMetas.findIndex((x) => {
      return x.pubkey.equals(feePayer);
    });
    if (feePayerIndex > -1) {
      const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);
      payerMeta.isSigner = true;
      payerMeta.isWritable = true;
      uniqueMetas.unshift(payerMeta);
    } else {
      uniqueMetas.unshift({
        pubkey: feePayer,
        isSigner: true,
        isWritable: true
      });
    }
    for (const signature2 of this.signatures) {
      const uniqueIndex = uniqueMetas.findIndex((x) => {
        return x.pubkey.equals(signature2.publicKey);
      });
      if (uniqueIndex > -1) {
        if (!uniqueMetas[uniqueIndex].isSigner) {
          uniqueMetas[uniqueIndex].isSigner = true;
          console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release.");
        }
      } else {
        throw new Error(`unknown signer: ${signature2.publicKey.toString()}`);
      }
    }
    let numRequiredSignatures = 0;
    let numReadonlySignedAccounts = 0;
    let numReadonlyUnsignedAccounts = 0;
    const signedKeys = [];
    const unsignedKeys = [];
    uniqueMetas.forEach(({
      pubkey,
      isSigner,
      isWritable
    }) => {
      if (isSigner) {
        signedKeys.push(pubkey.toString());
        numRequiredSignatures += 1;
        if (!isWritable) {
          numReadonlySignedAccounts += 1;
        }
      } else {
        unsignedKeys.push(pubkey.toString());
        if (!isWritable) {
          numReadonlyUnsignedAccounts += 1;
        }
      }
    });
    const accountKeys = signedKeys.concat(unsignedKeys);
    const compiledInstructions = instructions.map((instruction) => {
      const {
        data,
        programId
      } = instruction;
      return {
        programIdIndex: accountKeys.indexOf(programId.toString()),
        accounts: instruction.keys.map((meta) => accountKeys.indexOf(meta.pubkey.toString())),
        data: import_bs58.default.encode(data)
      };
    });
    compiledInstructions.forEach((instruction) => {
      assert3(instruction.programIdIndex >= 0);
      instruction.accounts.forEach((keyIndex) => assert3(keyIndex >= 0));
    });
    return new Message({
      header: {
        numRequiredSignatures,
        numReadonlySignedAccounts,
        numReadonlyUnsignedAccounts
      },
      accountKeys,
      recentBlockhash,
      instructions: compiledInstructions
    });
  }
  /**
   * @internal
   */
  _compile() {
    const message2 = this.compileMessage();
    const signedKeys = message2.accountKeys.slice(0, message2.header.numRequiredSignatures);
    if (this.signatures.length === signedKeys.length) {
      const valid = this.signatures.every((pair, index) => {
        return signedKeys[index].equals(pair.publicKey);
      });
      if (valid)
        return message2;
    }
    this.signatures = signedKeys.map((publicKey3) => ({
      signature: null,
      publicKey: publicKey3
    }));
    return message2;
  }
  /**
   * Get a buffer of the Transaction data that need to be covered by signatures
   */
  serializeMessage() {
    return this._compile().serialize();
  }
  /**
   * Get the estimated fee associated with a transaction
   */
  getEstimatedFee(connection) {
    return __async(this, null, function* () {
      return (yield connection.getFeeForMessage(this.compileMessage())).value;
    });
  }
  /**
   * Specify the public keys which will be used to sign the Transaction.
   * The first signer will be used as the transaction fee payer account.
   *
   * Signatures can be added with either `partialSign` or `addSignature`
   *
   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be
   * specified and it can be set in the Transaction constructor or with the
   * `feePayer` property.
   */
  setSigners(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = /* @__PURE__ */ new Set();
    this.signatures = signers.filter((publicKey3) => {
      const key = publicKey3.toString();
      if (seen.has(key)) {
        return false;
      } else {
        seen.add(key);
        return true;
      }
    }).map((publicKey3) => ({
      signature: null,
      publicKey: publicKey3
    }));
  }
  /**
   * Sign the Transaction with the specified signers. Multiple signatures may
   * be applied to a Transaction. The first signature is considered "primary"
   * and is used identify and confirm transactions.
   *
   * If the Transaction `feePayer` is not set, the first signer will be used
   * as the transaction fee payer account.
   *
   * Transaction fields should not be modified after the first call to `sign`,
   * as doing so may invalidate the signature and cause the Transaction to be
   * rejected.
   *
   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method
   */
  sign(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = /* @__PURE__ */ new Set();
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }
    this.signatures = uniqueSigners.map((signer) => ({
      signature: null,
      publicKey: signer.publicKey
    }));
    const message2 = this._compile();
    this._partialSign(message2, ...uniqueSigners);
  }
  /**
   * Partially sign a transaction with the specified accounts. All accounts must
   * correspond to either the fee payer or a signer account in the transaction
   * instructions.
   *
   * All the caveats from the `sign` method apply to `partialSign`
   */
  partialSign(...signers) {
    if (signers.length === 0) {
      throw new Error("No signers");
    }
    const seen = /* @__PURE__ */ new Set();
    const uniqueSigners = [];
    for (const signer of signers) {
      const key = signer.publicKey.toString();
      if (seen.has(key)) {
        continue;
      } else {
        seen.add(key);
        uniqueSigners.push(signer);
      }
    }
    const message2 = this._compile();
    this._partialSign(message2, ...uniqueSigners);
  }
  /**
   * @internal
   */
  _partialSign(message2, ...signers) {
    const signData = message2.serialize();
    signers.forEach((signer) => {
      const signature2 = sign(signData, signer.secretKey);
      this._addSignature(signer.publicKey, toBuffer(signature2));
    });
  }
  /**
   * Add an externally created signature to a transaction. The public key
   * must correspond to either the fee payer or a signer account in the transaction
   * instructions.
   */
  addSignature(pubkey, signature2) {
    this._compile();
    this._addSignature(pubkey, signature2);
  }
  /**
   * @internal
   */
  _addSignature(pubkey, signature2) {
    assert3(signature2.length === 64);
    const index = this.signatures.findIndex((sigpair) => pubkey.equals(sigpair.publicKey));
    if (index < 0) {
      throw new Error(`unknown signer: ${pubkey.toString()}`);
    }
    this.signatures[index].signature = Buffer2.from(signature2);
  }
  /**
   * Verify signatures of a Transaction
   * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.
   * If no boolean is provided, we expect a fully signed Transaction by default.
   */
  verifySignatures(requireAllSignatures) {
    return this._verifySignatures(this.serializeMessage(), requireAllSignatures === void 0 ? true : requireAllSignatures);
  }
  /**
   * @internal
   */
  _verifySignatures(signData, requireAllSignatures) {
    for (const {
      signature: signature2,
      publicKey: publicKey3
    } of this.signatures) {
      if (signature2 === null) {
        if (requireAllSignatures) {
          return false;
        }
      } else {
        if (!verify(signature2, signData, publicKey3.toBytes())) {
          return false;
        }
      }
    }
    return true;
  }
  /**
   * Serialize the Transaction in the wire format.
   */
  serialize(config) {
    const {
      requireAllSignatures,
      verifySignatures
    } = Object.assign({
      requireAllSignatures: true,
      verifySignatures: true
    }, config);
    const signData = this.serializeMessage();
    if (verifySignatures && !this._verifySignatures(signData, requireAllSignatures)) {
      throw new Error("Signature verification failed");
    }
    return this._serialize(signData);
  }
  /**
   * @internal
   */
  _serialize(signData) {
    const {
      signatures
    } = this;
    const signatureCount = [];
    encodeLength(signatureCount, signatures.length);
    const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
    const wireTransaction = Buffer2.alloc(transactionLength);
    assert3(signatures.length < 256);
    Buffer2.from(signatureCount).copy(wireTransaction, 0);
    signatures.forEach(({
      signature: signature2
    }, index) => {
      if (signature2 !== null) {
        assert3(signature2.length === 64, `signature has invalid length`);
        Buffer2.from(signature2).copy(wireTransaction, signatureCount.length + index * 64);
      }
    });
    signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
    assert3(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);
    return wireTransaction;
  }
  /**
   * Deprecated method
   * @internal
   */
  get keys() {
    assert3(this.instructions.length === 1);
    return this.instructions[0].keys.map((keyObj) => keyObj.pubkey);
  }
  /**
   * Deprecated method
   * @internal
   */
  get programId() {
    assert3(this.instructions.length === 1);
    return this.instructions[0].programId;
  }
  /**
   * Deprecated method
   * @internal
   */
  get data() {
    assert3(this.instructions.length === 1);
    return this.instructions[0].data;
  }
  /**
   * Parse a wire transaction into a Transaction object.
   */
  static from(buffer) {
    let byteArray = [...buffer];
    const signatureCount = decodeLength(byteArray);
    let signatures = [];
    for (let i = 0; i < signatureCount; i++) {
      const signature2 = byteArray.slice(0, SIGNATURE_LENGTH_IN_BYTES);
      byteArray = byteArray.slice(SIGNATURE_LENGTH_IN_BYTES);
      signatures.push(import_bs58.default.encode(Buffer2.from(signature2)));
    }
    return Transaction.populate(Message.from(byteArray), signatures);
  }
  /**
   * Populate Transaction object from message and signatures
   */
  static populate(message2, signatures = []) {
    const transaction = new Transaction();
    transaction.recentBlockhash = message2.recentBlockhash;
    if (message2.header.numRequiredSignatures > 0) {
      transaction.feePayer = message2.accountKeys[0];
    }
    signatures.forEach((signature2, index) => {
      const sigPubkeyPair = {
        signature: signature2 == import_bs58.default.encode(DEFAULT_SIGNATURE) ? null : import_bs58.default.decode(signature2),
        publicKey: message2.accountKeys[index]
      };
      transaction.signatures.push(sigPubkeyPair);
    });
    message2.instructions.forEach((instruction) => {
      const keys = instruction.accounts.map((account) => {
        const pubkey = message2.accountKeys[account];
        return {
          pubkey,
          isSigner: transaction.signatures.some((keyObj) => keyObj.publicKey.toString() === pubkey.toString()) || message2.isAccountSigner(account),
          isWritable: message2.isAccountWritable(account)
        };
      });
      transaction.instructions.push(new TransactionInstruction({
        keys,
        programId: message2.accountKeys[instruction.programIdIndex],
        data: import_bs58.default.decode(instruction.data)
      }));
    });
    transaction._message = message2;
    transaction._json = transaction.toJSON();
    return transaction;
  }
};
var TransactionMessage = class {
  constructor(args2) {
    this.payerKey = void 0;
    this.instructions = void 0;
    this.recentBlockhash = void 0;
    this.payerKey = args2.payerKey;
    this.instructions = args2.instructions;
    this.recentBlockhash = args2.recentBlockhash;
  }
  static decompile(message2, args2) {
    const {
      header,
      compiledInstructions,
      recentBlockhash
    } = message2;
    const {
      numRequiredSignatures,
      numReadonlySignedAccounts,
      numReadonlyUnsignedAccounts
    } = header;
    const numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;
    assert3(numWritableSignedAccounts > 0, "Message header is invalid");
    const numWritableUnsignedAccounts = message2.staticAccountKeys.length - numRequiredSignatures - numReadonlyUnsignedAccounts;
    assert3(numWritableUnsignedAccounts >= 0, "Message header is invalid");
    const accountKeys = message2.getAccountKeys(args2);
    const payerKey = accountKeys.get(0);
    if (payerKey === void 0) {
      throw new Error("Failed to decompile message because no account keys were found");
    }
    const instructions = [];
    for (const compiledIx of compiledInstructions) {
      const keys = [];
      for (const keyIndex of compiledIx.accountKeyIndexes) {
        const pubkey = accountKeys.get(keyIndex);
        if (pubkey === void 0) {
          throw new Error(`Failed to find key for account key index ${keyIndex}`);
        }
        const isSigner = keyIndex < numRequiredSignatures;
        let isWritable;
        if (isSigner) {
          isWritable = keyIndex < numWritableSignedAccounts;
        } else if (keyIndex < accountKeys.staticAccountKeys.length) {
          isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;
        } else {
          isWritable = keyIndex - accountKeys.staticAccountKeys.length < // accountKeysFromLookups cannot be undefined because we already found a pubkey for this index above
          accountKeys.accountKeysFromLookups.writable.length;
        }
        keys.push({
          pubkey,
          isSigner: keyIndex < header.numRequiredSignatures,
          isWritable
        });
      }
      const programId = accountKeys.get(compiledIx.programIdIndex);
      if (programId === void 0) {
        throw new Error(`Failed to find program id for program id index ${compiledIx.programIdIndex}`);
      }
      instructions.push(new TransactionInstruction({
        programId,
        data: toBuffer(compiledIx.data),
        keys
      }));
    }
    return new TransactionMessage({
      payerKey,
      instructions,
      recentBlockhash
    });
  }
  compileToLegacyMessage() {
    return Message.compile({
      payerKey: this.payerKey,
      recentBlockhash: this.recentBlockhash,
      instructions: this.instructions
    });
  }
  compileToV0Message(addressLookupTableAccounts) {
    return MessageV0.compile({
      payerKey: this.payerKey,
      recentBlockhash: this.recentBlockhash,
      instructions: this.instructions,
      addressLookupTableAccounts
    });
  }
};
var VersionedTransaction = class {
  get version() {
    return this.message.version;
  }
  constructor(message2, signatures) {
    this.signatures = void 0;
    this.message = void 0;
    if (signatures !== void 0) {
      assert3(signatures.length === message2.header.numRequiredSignatures, "Expected signatures length to be equal to the number of required signatures");
      this.signatures = signatures;
    } else {
      const defaultSignatures = [];
      for (let i = 0; i < message2.header.numRequiredSignatures; i++) {
        defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));
      }
      this.signatures = defaultSignatures;
    }
    this.message = message2;
  }
  serialize() {
    const serializedMessage = this.message.serialize();
    const encodedSignaturesLength = Array();
    encodeLength(encodedSignaturesLength, this.signatures.length);
    const transactionLayout = BufferLayout.struct([BufferLayout.blob(encodedSignaturesLength.length, "encodedSignaturesLength"), BufferLayout.seq(signature(), this.signatures.length, "signatures"), BufferLayout.blob(serializedMessage.length, "serializedMessage")]);
    const serializedTransaction = new Uint8Array(2048);
    const serializedTransactionLength = transactionLayout.encode({
      encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),
      signatures: this.signatures,
      serializedMessage
    }, serializedTransaction);
    return serializedTransaction.slice(0, serializedTransactionLength);
  }
  static deserialize(serializedTransaction) {
    let byteArray = [...serializedTransaction];
    const signatures = [];
    const signaturesLength = decodeLength(byteArray);
    for (let i = 0; i < signaturesLength; i++) {
      signatures.push(new Uint8Array(byteArray.splice(0, SIGNATURE_LENGTH_IN_BYTES)));
    }
    const message2 = VersionedMessage.deserialize(new Uint8Array(byteArray));
    return new VersionedTransaction(message2, signatures);
  }
  sign(signers) {
    const messageData = this.message.serialize();
    const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
    for (const signer of signers) {
      const signerIndex = signerPubkeys.findIndex((pubkey) => pubkey.equals(signer.publicKey));
      assert3(signerIndex >= 0, `Cannot sign with non signer key ${signer.publicKey.toBase58()}`);
      this.signatures[signerIndex] = sign(messageData, signer.secretKey);
    }
  }
  addSignature(publicKey3, signature2) {
    assert3(signature2.byteLength === 64, "Signature must be 64 bytes long");
    const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
    const signerIndex = signerPubkeys.findIndex((pubkey) => pubkey.equals(publicKey3));
    assert3(signerIndex >= 0, `Can not add signature; \`${publicKey3.toBase58()}\` is not required to sign this transaction`);
    this.signatures[signerIndex] = signature2;
  }
};
var SYSVAR_CLOCK_PUBKEY = new PublicKey("SysvarC1ock11111111111111111111111111111111");
var SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey("SysvarEpochSchedu1e111111111111111111111111");
var SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey("Sysvar1nstructions1111111111111111111111111");
var SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey("SysvarRecentB1ockHashes11111111111111111111");
var SYSVAR_RENT_PUBKEY = new PublicKey("SysvarRent111111111111111111111111111111111");
var SYSVAR_REWARDS_PUBKEY = new PublicKey("SysvarRewards111111111111111111111111111111");
var SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey("SysvarS1otHashes111111111111111111111111111");
var SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey("SysvarS1otHistory11111111111111111111111111");
var SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey("SysvarStakeHistory1111111111111111111111111");
function sendAndConfirmTransaction(connection, transaction, signers, options) {
  return __async(this, null, function* () {
    const sendOptions = options && {
      skipPreflight: options.skipPreflight,
      preflightCommitment: options.preflightCommitment || options.commitment,
      maxRetries: options.maxRetries,
      minContextSlot: options.minContextSlot
    };
    const signature2 = yield connection.sendTransaction(transaction, signers, sendOptions);
    let status;
    if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {
      status = (yield connection.confirmTransaction({
        abortSignal: options == null ? void 0 : options.abortSignal,
        signature: signature2,
        blockhash: transaction.recentBlockhash,
        lastValidBlockHeight: transaction.lastValidBlockHeight
      }, options && options.commitment)).value;
    } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {
      const {
        nonceInstruction
      } = transaction.nonceInfo;
      const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;
      status = (yield connection.confirmTransaction({
        abortSignal: options == null ? void 0 : options.abortSignal,
        minContextSlot: transaction.minNonceContextSlot,
        nonceAccountPubkey,
        nonceValue: transaction.nonceInfo.nonce,
        signature: signature2
      }, options && options.commitment)).value;
    } else {
      if ((options == null ? void 0 : options.abortSignal) != null) {
        console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.");
      }
      status = (yield connection.confirmTransaction(signature2, options && options.commitment)).value;
    }
    if (status.err) {
      throw new Error(`Transaction ${signature2} failed (${JSON.stringify(status)})`);
    }
    return signature2;
  });
}
function sleep(ms2) {
  return new Promise((resolve) => setTimeout(resolve, ms2));
}
function encodeData(type2, fields) {
  const allocLength = type2.layout.span >= 0 ? type2.layout.span : getAlloc(type2, fields);
  const data = Buffer2.alloc(allocLength);
  const layoutFields = Object.assign({
    instruction: type2.index
  }, fields);
  type2.layout.encode(layoutFields, data);
  return data;
}
function decodeData$1(type2, buffer) {
  let data;
  try {
    data = type2.layout.decode(buffer);
  } catch (err) {
    throw new Error("invalid instruction; " + err);
  }
  if (data.instruction !== type2.index) {
    throw new Error(`invalid instruction; instruction index mismatch ${data.instruction} != ${type2.index}`);
  }
  return data;
}
var FeeCalculatorLayout = BufferLayout.nu64("lamportsPerSignature");
var NonceAccountLayout = BufferLayout.struct([BufferLayout.u32("version"), BufferLayout.u32("state"), publicKey("authorizedPubkey"), publicKey("nonce"), BufferLayout.struct([FeeCalculatorLayout], "feeCalculator")]);
var NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;
var NonceAccount = class {
  /**
   * @internal
   */
  constructor(args2) {
    this.authorizedPubkey = void 0;
    this.nonce = void 0;
    this.feeCalculator = void 0;
    this.authorizedPubkey = args2.authorizedPubkey;
    this.nonce = args2.nonce;
    this.feeCalculator = args2.feeCalculator;
  }
  /**
   * Deserialize NonceAccount from the account data.
   *
   * @param buffer account data
   * @return NonceAccount
   */
  static fromAccountData(buffer) {
    const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer), 0);
    return new NonceAccount({
      authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),
      nonce: new PublicKey(nonceAccount.nonce).toString(),
      feeCalculator: nonceAccount.feeCalculator
    });
  }
};
var encodeDecode = (layout) => {
  const decode = layout.decode.bind(layout);
  const encode = layout.encode.bind(layout);
  return {
    decode,
    encode
  };
};
var bigInt = (length) => (property) => {
  const layout = (0, import_buffer_layout.blob)(length, property);
  const {
    encode,
    decode
  } = encodeDecode(layout);
  const bigIntLayout = layout;
  bigIntLayout.decode = (buffer, offset2) => {
    const src2 = decode(buffer, offset2);
    return (0, import_bigint_buffer.toBigIntLE)(Buffer2.from(src2));
  };
  bigIntLayout.encode = (bigInt3, buffer, offset2) => {
    const src2 = (0, import_bigint_buffer.toBufferLE)(bigInt3, length);
    return encode(src2, buffer, offset2);
  };
  return bigIntLayout;
};
var u642 = bigInt(8);
var SystemInstruction = class {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Decode a system instruction and retrieve the instruction type.
   */
  static decodeInstructionType(instruction) {
    this.checkProgramId(instruction.programId);
    const instructionTypeLayout = BufferLayout.u32("instruction");
    const typeIndex = instructionTypeLayout.decode(instruction.data);
    let type2;
    for (const [ixType, layout] of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS)) {
      if (layout.index == typeIndex) {
        type2 = ixType;
        break;
      }
    }
    if (!type2) {
      throw new Error("Instruction type incorrect; not a SystemInstruction");
    }
    return type2;
  }
  /**
   * Decode a create account system instruction and retrieve the instruction params.
   */
  static decodeCreateAccount(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 2);
    const {
      lamports,
      space,
      programId
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data);
    return {
      fromPubkey: instruction.keys[0].pubkey,
      newAccountPubkey: instruction.keys[1].pubkey,
      lamports,
      space,
      programId: new PublicKey(programId)
    };
  }
  /**
   * Decode a transfer system instruction and retrieve the instruction params.
   */
  static decodeTransfer(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 2);
    const {
      lamports
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data);
    return {
      fromPubkey: instruction.keys[0].pubkey,
      toPubkey: instruction.keys[1].pubkey,
      lamports
    };
  }
  /**
   * Decode a transfer with seed system instruction and retrieve the instruction params.
   */
  static decodeTransferWithSeed(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    const {
      lamports,
      seed,
      programId
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data);
    return {
      fromPubkey: instruction.keys[0].pubkey,
      basePubkey: instruction.keys[1].pubkey,
      toPubkey: instruction.keys[2].pubkey,
      lamports,
      seed,
      programId: new PublicKey(programId)
    };
  }
  /**
   * Decode an allocate system instruction and retrieve the instruction params.
   */
  static decodeAllocate(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 1);
    const {
      space
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data);
    return {
      accountPubkey: instruction.keys[0].pubkey,
      space
    };
  }
  /**
   * Decode an allocate with seed system instruction and retrieve the instruction params.
   */
  static decodeAllocateWithSeed(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 1);
    const {
      base,
      seed,
      space,
      programId
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data);
    return {
      accountPubkey: instruction.keys[0].pubkey,
      basePubkey: new PublicKey(base),
      seed,
      space,
      programId: new PublicKey(programId)
    };
  }
  /**
   * Decode an assign system instruction and retrieve the instruction params.
   */
  static decodeAssign(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 1);
    const {
      programId
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data);
    return {
      accountPubkey: instruction.keys[0].pubkey,
      programId: new PublicKey(programId)
    };
  }
  /**
   * Decode an assign with seed system instruction and retrieve the instruction params.
   */
  static decodeAssignWithSeed(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 1);
    const {
      base,
      seed,
      programId
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data);
    return {
      accountPubkey: instruction.keys[0].pubkey,
      basePubkey: new PublicKey(base),
      seed,
      programId: new PublicKey(programId)
    };
  }
  /**
   * Decode a create account with seed system instruction and retrieve the instruction params.
   */
  static decodeCreateWithSeed(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 2);
    const {
      base,
      seed,
      lamports,
      space,
      programId
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data);
    return {
      fromPubkey: instruction.keys[0].pubkey,
      newAccountPubkey: instruction.keys[1].pubkey,
      basePubkey: new PublicKey(base),
      seed,
      lamports,
      space,
      programId: new PublicKey(programId)
    };
  }
  /**
   * Decode a nonce initialize system instruction and retrieve the instruction params.
   */
  static decodeNonceInitialize(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    const {
      authorized: authorized2
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data);
    return {
      noncePubkey: instruction.keys[0].pubkey,
      authorizedPubkey: new PublicKey(authorized2)
    };
  }
  /**
   * Decode a nonce advance system instruction and retrieve the instruction params.
   */
  static decodeNonceAdvance(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);
    return {
      noncePubkey: instruction.keys[0].pubkey,
      authorizedPubkey: instruction.keys[2].pubkey
    };
  }
  /**
   * Decode a nonce withdraw system instruction and retrieve the instruction params.
   */
  static decodeNonceWithdraw(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 5);
    const {
      lamports
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data);
    return {
      noncePubkey: instruction.keys[0].pubkey,
      toPubkey: instruction.keys[1].pubkey,
      authorizedPubkey: instruction.keys[4].pubkey,
      lamports
    };
  }
  /**
   * Decode a nonce authorize system instruction and retrieve the instruction params.
   */
  static decodeNonceAuthorize(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 2);
    const {
      authorized: authorized2
    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data);
    return {
      noncePubkey: instruction.keys[0].pubkey,
      authorizedPubkey: instruction.keys[1].pubkey,
      newAuthorizedPubkey: new PublicKey(authorized2)
    };
  }
  /**
   * @internal
   */
  static checkProgramId(programId) {
    if (!programId.equals(SystemProgram.programId)) {
      throw new Error("invalid instruction; programId is not SystemProgram");
    }
  }
  /**
   * @internal
   */
  static checkKeyLength(keys, expectedLength) {
    if (keys.length < expectedLength) {
      throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
    }
  }
};
var SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
  Create: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports"), BufferLayout.ns64("space"), publicKey("programId")])
  },
  Assign: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("programId")])
  },
  Transfer: {
    index: 2,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), u642("lamports")])
  },
  CreateWithSeed: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("base"), rustString("seed"), BufferLayout.ns64("lamports"), BufferLayout.ns64("space"), publicKey("programId")])
  },
  AdvanceNonceAccount: {
    index: 4,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  WithdrawNonceAccount: {
    index: 5,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
  },
  InitializeNonceAccount: {
    index: 6,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("authorized")])
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("authorized")])
  },
  Allocate: {
    index: 8,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("space")])
  },
  AllocateWithSeed: {
    index: 9,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("base"), rustString("seed"), BufferLayout.ns64("space"), publicKey("programId")])
  },
  AssignWithSeed: {
    index: 10,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("base"), rustString("seed"), publicKey("programId")])
  },
  TransferWithSeed: {
    index: 11,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), u642("lamports"), rustString("seed"), publicKey("programId")])
  },
  UpgradeNonceAccount: {
    index: 12,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  }
});
var SystemProgram = class {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the System program
   */
  /**
   * Generate a transaction instruction that creates a new account
   */
  static createAccount(params) {
    const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Create;
    const data = encodeData(type2, {
      lamports: params.lamports,
      space: params.space,
      programId: toBuffer(params.programId.toBuffer())
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.newAccountPubkey,
        isSigner: true,
        isWritable: true
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that transfers lamports from one account to another
   */
  static transfer(params) {
    let data;
    let keys;
    if ("basePubkey" in params) {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
      data = encodeData(type2, {
        lamports: BigInt(params.lamports),
        seed: params.seed,
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.fromPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    } else {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
      data = encodeData(type2, {
        lamports: BigInt(params.lamports)
      });
      keys = [{
        pubkey: params.fromPubkey,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }];
    }
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that assigns an account to a program
   */
  static assign(params) {
    let data;
    let keys;
    if ("basePubkey" in params) {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
      data = encodeData(type2, {
        base: toBuffer(params.basePubkey.toBuffer()),
        seed: params.seed,
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
      data = encodeData(type2, {
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that creates a new account at
   *   an address generated with `from`, a seed, and programId
   */
  static createAccountWithSeed(params) {
    const type2 = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;
    const data = encodeData(type2, {
      base: toBuffer(params.basePubkey.toBuffer()),
      seed: params.seed,
      lamports: params.lamports,
      space: params.space,
      programId: toBuffer(params.programId.toBuffer())
    });
    let keys = [{
      pubkey: params.fromPubkey,
      isSigner: true,
      isWritable: true
    }, {
      pubkey: params.newAccountPubkey,
      isSigner: false,
      isWritable: true
    }];
    if (params.basePubkey != params.fromPubkey) {
      keys.push({
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      });
    }
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction that creates a new Nonce account
   */
  static createNonceAccount(params) {
    const transaction = new Transaction();
    if ("basePubkey" in params && "seed" in params) {
      transaction.add(SystemProgram.createAccountWithSeed({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        basePubkey: params.basePubkey,
        seed: params.seed,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH,
        programId: this.programId
      }));
    } else {
      transaction.add(SystemProgram.createAccount({
        fromPubkey: params.fromPubkey,
        newAccountPubkey: params.noncePubkey,
        lamports: params.lamports,
        space: NONCE_ACCOUNT_LENGTH,
        programId: this.programId
      }));
    }
    const initParams = {
      noncePubkey: params.noncePubkey,
      authorizedPubkey: params.authorizedPubkey
    };
    transaction.add(this.nonceInitialize(initParams));
    return transaction;
  }
  /**
   * Generate an instruction to initialize a Nonce account
   */
  static nonceInitialize(params) {
    const type2 = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;
    const data = encodeData(type2, {
      authorized: toBuffer(params.authorizedPubkey.toBuffer())
    });
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  /**
   * Generate an instruction to advance the nonce in a Nonce account
   */
  static nonceAdvance(params) {
    const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;
    const data = encodeData(type2);
    const instructionData = {
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  /**
   * Generate a transaction instruction that withdraws lamports from a Nonce account
   */
  static nonceWithdraw(params) {
    const type2 = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;
    const data = encodeData(type2, {
      lamports: params.lamports
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.toPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that authorizes a new PublicKey as the authority
   * on a Nonce account.
   */
  static nonceAuthorize(params) {
    const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;
    const data = encodeData(type2, {
      authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: params.noncePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction instruction that allocates space in an account without funding
   */
  static allocate(params) {
    let data;
    let keys;
    if ("basePubkey" in params) {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
      data = encodeData(type2, {
        base: toBuffer(params.basePubkey.toBuffer()),
        seed: params.seed,
        space: params.space,
        programId: toBuffer(params.programId.toBuffer())
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: params.basePubkey,
        isSigner: true,
        isWritable: false
      }];
    } else {
      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
      data = encodeData(type2, {
        space: params.space
      });
      keys = [{
        pubkey: params.accountPubkey,
        isSigner: true,
        isWritable: true
      }];
    }
    return new TransactionInstruction({
      keys,
      programId: this.programId,
      data
    });
  }
};
SystemProgram.programId = new PublicKey("11111111111111111111111111111111");
var CHUNK_SIZE = PACKET_DATA_SIZE - 300;
var Loader = class {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Amount of program data placed in each load Transaction
   */
  /**
   * Minimum number of signatures required to load a program not including
   * retries
   *
   * Can be used to calculate transaction fees
   */
  static getMinNumSignatures(dataLength) {
    return 2 * // Every transaction requires two signatures (payer + program)
    (Math.ceil(dataLength / Loader.chunkSize) + 1 + // Add one for Create transaction
    1);
  }
  /**
   * Loads a generic program
   *
   * @param connection The connection to use
   * @param payer System account that pays to load the program
   * @param program Account to load the program into
   * @param programId Public key that identifies the loader
   * @param data Program octets
   * @return true if program was loaded successfully, false if program was already loaded
   */
  static load(connection, payer, program, programId, data) {
    return __async(this, null, function* () {
      {
        const balanceNeeded = yield connection.getMinimumBalanceForRentExemption(data.length);
        const programInfo = yield connection.getAccountInfo(program.publicKey, "confirmed");
        let transaction = null;
        if (programInfo !== null) {
          if (programInfo.executable) {
            console.error("Program load failed, account is already executable");
            return false;
          }
          if (programInfo.data.length !== data.length) {
            transaction = transaction || new Transaction();
            transaction.add(SystemProgram.allocate({
              accountPubkey: program.publicKey,
              space: data.length
            }));
          }
          if (!programInfo.owner.equals(programId)) {
            transaction = transaction || new Transaction();
            transaction.add(SystemProgram.assign({
              accountPubkey: program.publicKey,
              programId
            }));
          }
          if (programInfo.lamports < balanceNeeded) {
            transaction = transaction || new Transaction();
            transaction.add(SystemProgram.transfer({
              fromPubkey: payer.publicKey,
              toPubkey: program.publicKey,
              lamports: balanceNeeded - programInfo.lamports
            }));
          }
        } else {
          transaction = new Transaction().add(SystemProgram.createAccount({
            fromPubkey: payer.publicKey,
            newAccountPubkey: program.publicKey,
            lamports: balanceNeeded > 0 ? balanceNeeded : 1,
            space: data.length,
            programId
          }));
        }
        if (transaction !== null) {
          yield sendAndConfirmTransaction(connection, transaction, [payer, program], {
            commitment: "confirmed"
          });
        }
      }
      const dataLayout = BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.u32("offset"), BufferLayout.u32("bytesLength"), BufferLayout.u32("bytesLengthPadding"), BufferLayout.seq(BufferLayout.u8("byte"), BufferLayout.offset(BufferLayout.u32(), -8), "bytes")]);
      const chunkSize = Loader.chunkSize;
      let offset2 = 0;
      let array2 = data;
      let transactions = [];
      while (array2.length > 0) {
        const bytes2 = array2.slice(0, chunkSize);
        const data2 = Buffer2.alloc(chunkSize + 16);
        dataLayout.encode({
          instruction: 0,
          // Load instruction
          offset: offset2,
          bytes: bytes2,
          bytesLength: 0,
          bytesLengthPadding: 0
        }, data2);
        const transaction = new Transaction().add({
          keys: [{
            pubkey: program.publicKey,
            isSigner: true,
            isWritable: true
          }],
          programId,
          data: data2
        });
        transactions.push(sendAndConfirmTransaction(connection, transaction, [payer, program], {
          commitment: "confirmed"
        }));
        if (connection._rpcEndpoint.includes("solana.com")) {
          const REQUESTS_PER_SECOND = 4;
          yield sleep(1e3 / REQUESTS_PER_SECOND);
        }
        offset2 += chunkSize;
        array2 = array2.slice(chunkSize);
      }
      yield Promise.all(transactions);
      {
        const dataLayout2 = BufferLayout.struct([BufferLayout.u32("instruction")]);
        const data2 = Buffer2.alloc(dataLayout2.span);
        dataLayout2.encode({
          instruction: 1
          // Finalize instruction
        }, data2);
        const transaction = new Transaction().add({
          keys: [{
            pubkey: program.publicKey,
            isSigner: true,
            isWritable: true
          }, {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false
          }],
          programId,
          data: data2
        });
        yield sendAndConfirmTransaction(connection, transaction, [payer, program], {
          commitment: "confirmed"
        });
      }
      return true;
    });
  }
};
Loader.chunkSize = CHUNK_SIZE;
var BPF_LOADER_PROGRAM_ID = new PublicKey("BPFLoader2111111111111111111111111111111111");
var BpfLoader = class {
  /**
   * Minimum number of signatures required to load a program not including
   * retries
   *
   * Can be used to calculate transaction fees
   */
  static getMinNumSignatures(dataLength) {
    return Loader.getMinNumSignatures(dataLength);
  }
  /**
   * Load a SBF program
   *
   * @param connection The connection to use
   * @param payer Account that will pay program loading fees
   * @param program Account to load the program into
   * @param elf The entire ELF containing the SBF program
   * @param loaderProgramId The program id of the BPF loader to use
   * @return true if program was loaded successfully, false if program was already loaded
   */
  static load(connection, payer, program, elf, loaderProgramId) {
    return Loader.load(connection, payer, program, loaderProgramId, elf);
  }
};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var agentkeepaliveExports = {};
var agentkeepalive = {
  get exports() {
    return agentkeepaliveExports;
  },
  set exports(v) {
    agentkeepaliveExports = v;
  }
};
var s = 1e3;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
var ms$3 = function(val, options) {
  options = options || {};
  var type2 = typeof val;
  if (type2 === "string" && val.length > 0) {
    return parse2(val);
  } else if (type2 === "number" && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
  );
};
function parse2(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type2 = (match[2] || "ms").toLowerCase();
  switch (type2) {
    case "years":
    case "year":
    case "yrs":
    case "yr":
    case "y":
      return n * y;
    case "weeks":
    case "week":
    case "w":
      return n * w;
    case "days":
    case "day":
    case "d":
      return n * d;
    case "hours":
    case "hour":
    case "hrs":
    case "hr":
    case "h":
      return n * h;
    case "minutes":
    case "minute":
    case "mins":
    case "min":
    case "m":
      return n * m;
    case "seconds":
    case "second":
    case "secs":
    case "sec":
    case "s":
      return n * s;
    case "milliseconds":
    case "millisecond":
    case "msecs":
    case "msec":
    case "ms":
      return n;
    default:
      return void 0;
  }
}
function fmtShort(ms2) {
  var msAbs = Math.abs(ms2);
  if (msAbs >= d) {
    return Math.round(ms2 / d) + "d";
  }
  if (msAbs >= h) {
    return Math.round(ms2 / h) + "h";
  }
  if (msAbs >= m) {
    return Math.round(ms2 / m) + "m";
  }
  if (msAbs >= s) {
    return Math.round(ms2 / s) + "s";
  }
  return ms2 + "ms";
}
function fmtLong(ms2) {
  var msAbs = Math.abs(ms2);
  if (msAbs >= d) {
    return plural(ms2, msAbs, d, "day");
  }
  if (msAbs >= h) {
    return plural(ms2, msAbs, h, "hour");
  }
  if (msAbs >= m) {
    return plural(ms2, msAbs, m, "minute");
  }
  if (msAbs >= s) {
    return plural(ms2, msAbs, s, "second");
  }
  return ms2 + " ms";
}
function plural(ms2, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
}
var util = require$$0;
var ms$2 = ms$3;
var humanizeMs = function(t) {
  if (typeof t === "number")
    return t;
  var r = ms$2(t);
  if (r === void 0) {
    var err = new Error(util.format("humanize-ms(%j) result undefined", t));
    console.warn(err.stack);
  }
  return r;
};
var srcExports = {};
var src = {
  get exports() {
    return srcExports;
  },
  set exports(v) {
    srcExports = v;
  }
};
var browserExports = {};
var browser$1 = {
  get exports() {
    return browserExports;
  },
  set exports(v) {
    browserExports = v;
  }
};
var ms$1;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms$1;
  hasRequiredMs = 1;
  var s2 = 1e3;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var w2 = d2 * 7;
  var y2 = d2 * 365.25;
  ms$1 = function(val, options) {
    options = options || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse3(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options.long ? fmtLong2(val) : fmtShort2(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse3(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y2;
      case "weeks":
      case "week":
      case "w":
        return n * w2;
      case "days":
      case "day":
      case "d":
        return n * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort2(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return Math.round(ms2 / d2) + "d";
    }
    if (msAbs >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (msAbs >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (msAbs >= s2) {
      return Math.round(ms2 / s2) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong2(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return plural2(ms2, msAbs, d2, "day");
    }
    if (msAbs >= h2) {
      return plural2(ms2, msAbs, h2, "hour");
    }
    if (msAbs >= m2) {
      return plural2(ms2, msAbs, m2, "minute");
    }
    if (msAbs >= s2) {
      return plural2(ms2, msAbs, s2, "second");
    }
    return ms2 + " ms";
  }
  function plural2(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms$1;
}
var common;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon)
    return common;
  hasRequiredCommon = 1;
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash2 = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
        hash2 |= 0;
      }
      return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args2) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args2[0] = createDebug.coerce(args2[0]);
        if (typeof args2[0] !== "string") {
          args2.unshift("%O");
        }
        let index = 0;
        args2[0] = args2[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args2[index];
            match = formatter.call(self2, val);
            args2.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args2);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args2);
      }
      debug2.namespace = namespace;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace);
      debug2.extend = extend;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split2.length;
      for (i = 0; i < len; i++) {
        if (!split2[i]) {
          continue;
        }
        namespaces = split2[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common = setup;
  return common;
}
var hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1)
    return browserExports;
  hasRequiredBrowser$1 = 1;
  (function(module, exports) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args2) {
      args2[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args2[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args2.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args2[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args2.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = requireCommon()(exports);
    const { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  })(browser$1, browserExports);
  return browserExports;
}
var nodeExports = {};
var node = {
  get exports() {
    return nodeExports;
  },
  set exports(v) {
    nodeExports = v;
  }
};
var browser;
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browser;
  hasRequiredBrowser = 1;
  function getChromeVersion() {
    const matches = new RegExp("(Chrome|Chromium)\\/(?<chromeVersion>\\d+)\\.").exec(navigator.userAgent);
    if (!matches) {
      return;
    }
    return Number.parseInt(matches.groups.chromeVersion, 10);
  }
  const colorSupport = getChromeVersion() >= 69 ? {
    level: 1,
    hasBasic: true,
    has256: false,
    has16m: false
  } : false;
  browser = {
    stdout: colorSupport,
    stderr: colorSupport
  };
  return browser;
}
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode)
    return nodeExports;
  hasRequiredNode = 1;
  (function(module, exports) {
    const tty = require$$0$1;
    const util2 = require$$0;
    exports.init = init;
    exports.log = log2;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = requireBrowser();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args2) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args2[0] = prefix + args2[0].split("\n").join("\n" + prefix);
        args2.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args2[0] = getDate() + name + " " + args2[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log2(...args2) {
      return process.stderr.write(util2.format(...args2) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug2.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module.exports = requireCommon()(exports);
    const { formatters } = module.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  })(node, nodeExports);
  return nodeExports;
}
(function(module) {
  if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
    module.exports = requireBrowser$1();
  } else {
    module.exports = requireNode();
  }
})(src);
var compatExports = {};
var compat = {
  get exports() {
    return compatExports;
  },
  set exports(v) {
    compatExports = v;
  }
};
var callsiteTostring;
var hasRequiredCallsiteTostring;
function requireCallsiteTostring() {
  if (hasRequiredCallsiteTostring)
    return callsiteTostring;
  hasRequiredCallsiteTostring = 1;
  callsiteTostring = callSiteToString2;
  function callSiteFileLocation(callSite) {
    var fileName;
    var fileLocation = "";
    if (callSite.isNative()) {
      fileLocation = "native";
    } else if (callSite.isEval()) {
      fileName = callSite.getScriptNameOrSourceURL();
      if (!fileName) {
        fileLocation = callSite.getEvalOrigin();
      }
    } else {
      fileName = callSite.getFileName();
    }
    if (fileName) {
      fileLocation += fileName;
      var lineNumber = callSite.getLineNumber();
      if (lineNumber != null) {
        fileLocation += ":" + lineNumber;
        var columnNumber = callSite.getColumnNumber();
        if (columnNumber) {
          fileLocation += ":" + columnNumber;
        }
      }
    }
    return fileLocation || "unknown source";
  }
  function callSiteToString2(callSite) {
    var addSuffix = true;
    var fileLocation = callSiteFileLocation(callSite);
    var functionName = callSite.getFunctionName();
    var isConstructor = callSite.isConstructor();
    var isMethodCall = !(callSite.isToplevel() || isConstructor);
    var line = "";
    if (isMethodCall) {
      var methodName = callSite.getMethodName();
      var typeName = getConstructorName(callSite);
      if (functionName) {
        if (typeName && functionName.indexOf(typeName) !== 0) {
          line += typeName + ".";
        }
        line += functionName;
        if (methodName && functionName.lastIndexOf("." + methodName) !== functionName.length - methodName.length - 1) {
          line += " [as " + methodName + "]";
        }
      } else {
        line += typeName + "." + (methodName || "<anonymous>");
      }
    } else if (isConstructor) {
      line += "new " + (functionName || "<anonymous>");
    } else if (functionName) {
      line += functionName;
    } else {
      addSuffix = false;
      line += fileLocation;
    }
    if (addSuffix) {
      line += " (" + fileLocation + ")";
    }
    return line;
  }
  function getConstructorName(obj) {
    var receiver = obj.receiver;
    return receiver.constructor && receiver.constructor.name || null;
  }
  return callsiteTostring;
}
var eventListenerCount_1;
var hasRequiredEventListenerCount;
function requireEventListenerCount() {
  if (hasRequiredEventListenerCount)
    return eventListenerCount_1;
  hasRequiredEventListenerCount = 1;
  eventListenerCount_1 = eventListenerCount2;
  function eventListenerCount2(emitter, type2) {
    return emitter.listeners(type2).length;
  }
  return eventListenerCount_1;
}
(function(module) {
  var EventEmitter = require$$0$2.EventEmitter;
  lazyProperty(module.exports, "callSiteToString", function callSiteToString2() {
    var limit = Error.stackTraceLimit;
    var obj = {};
    var prep = Error.prepareStackTrace;
    function prepareObjectStackTrace2(obj2, stack3) {
      return stack3;
    }
    Error.prepareStackTrace = prepareObjectStackTrace2;
    Error.stackTraceLimit = 2;
    Error.captureStackTrace(obj);
    var stack2 = obj.stack.slice();
    Error.prepareStackTrace = prep;
    Error.stackTraceLimit = limit;
    return stack2[0].toString ? toString : requireCallsiteTostring();
  });
  lazyProperty(module.exports, "eventListenerCount", function eventListenerCount2() {
    return EventEmitter.listenerCount || requireEventListenerCount();
  });
  function lazyProperty(obj, prop, getter) {
    function get() {
      var val = getter();
      Object.defineProperty(obj, prop, {
        configurable: true,
        enumerable: true,
        value: val
      });
      return val;
    }
    Object.defineProperty(obj, prop, {
      configurable: true,
      enumerable: true,
      get
    });
  }
  function toString(obj) {
    return obj.toString();
  }
})(compat);
var callSiteToString = compatExports.callSiteToString;
var eventListenerCount = compatExports.eventListenerCount;
var relative = require$$1.relative;
var depd_1 = depd;
var basePath = process.cwd();
function containsNamespace(str, namespace) {
  var vals = str.split(/[ ,]+/);
  var ns = String(namespace).toLowerCase();
  for (var i = 0; i < vals.length; i++) {
    var val = vals[i];
    if (val && (val === "*" || val.toLowerCase() === ns)) {
      return true;
    }
  }
  return false;
}
function convertDataDescriptorToAccessor(obj, prop, message2) {
  var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
  var value = descriptor.value;
  descriptor.get = function getter() {
    return value;
  };
  if (descriptor.writable) {
    descriptor.set = function setter(val) {
      return value = val;
    };
  }
  delete descriptor.value;
  delete descriptor.writable;
  Object.defineProperty(obj, prop, descriptor);
  return descriptor;
}
function createArgumentsString(arity) {
  var str = "";
  for (var i = 0; i < arity; i++) {
    str += ", arg" + i;
  }
  return str.substr(2);
}
function createStackString(stack2) {
  var str = this.name + ": " + this.namespace;
  if (this.message) {
    str += " deprecated " + this.message;
  }
  for (var i = 0; i < stack2.length; i++) {
    str += "\n    at " + callSiteToString(stack2[i]);
  }
  return str;
}
function depd(namespace) {
  if (!namespace) {
    throw new TypeError("argument namespace is required");
  }
  var stack2 = getStack();
  var site2 = callSiteLocation(stack2[1]);
  var file = site2[0];
  function deprecate2(message2) {
    log.call(deprecate2, message2);
  }
  deprecate2._file = file;
  deprecate2._ignored = isignored(namespace);
  deprecate2._namespace = namespace;
  deprecate2._traced = istraced(namespace);
  deprecate2._warned = /* @__PURE__ */ Object.create(null);
  deprecate2.function = wrapfunction;
  deprecate2.property = wrapproperty;
  return deprecate2;
}
function isignored(namespace) {
  if (process.noDeprecation) {
    return true;
  }
  var str = process.env.NO_DEPRECATION || "";
  return containsNamespace(str, namespace);
}
function istraced(namespace) {
  if (process.traceDeprecation) {
    return true;
  }
  var str = process.env.TRACE_DEPRECATION || "";
  return containsNamespace(str, namespace);
}
function log(message2, site2) {
  var haslisteners = eventListenerCount(process, "deprecation") !== 0;
  if (!haslisteners && this._ignored) {
    return;
  }
  var caller;
  var callFile;
  var callSite;
  var depSite;
  var i = 0;
  var seen = false;
  var stack2 = getStack();
  var file = this._file;
  if (site2) {
    depSite = site2;
    callSite = callSiteLocation(stack2[1]);
    callSite.name = depSite.name;
    file = callSite[0];
  } else {
    i = 2;
    depSite = callSiteLocation(stack2[i]);
    callSite = depSite;
  }
  for (; i < stack2.length; i++) {
    caller = callSiteLocation(stack2[i]);
    callFile = caller[0];
    if (callFile === file) {
      seen = true;
    } else if (callFile === this._file) {
      file = this._file;
    } else if (seen) {
      break;
    }
  }
  var key = caller ? depSite.join(":") + "__" + caller.join(":") : void 0;
  if (key !== void 0 && key in this._warned) {
    return;
  }
  this._warned[key] = true;
  var msg = message2;
  if (!msg) {
    msg = callSite === depSite || !callSite.name ? defaultMessage(depSite) : defaultMessage(callSite);
  }
  if (haslisteners) {
    var err = DeprecationError(this._namespace, msg, stack2.slice(i));
    process.emit("deprecation", err);
    return;
  }
  var format = process.stderr.isTTY ? formatColor : formatPlain;
  var output2 = format.call(this, msg, caller, stack2.slice(i));
  process.stderr.write(output2 + "\n", "utf8");
}
function callSiteLocation(callSite) {
  var file = callSite.getFileName() || "<anonymous>";
  var line = callSite.getLineNumber();
  var colm = callSite.getColumnNumber();
  if (callSite.isEval()) {
    file = callSite.getEvalOrigin() + ", " + file;
  }
  var site2 = [file, line, colm];
  site2.callSite = callSite;
  site2.name = callSite.getFunctionName();
  return site2;
}
function defaultMessage(site2) {
  var callSite = site2.callSite;
  var funcName = site2.name;
  if (!funcName) {
    funcName = "<anonymous@" + formatLocation(site2) + ">";
  }
  var context = callSite.getThis();
  var typeName = context && callSite.getTypeName();
  if (typeName === "Object") {
    typeName = void 0;
  }
  if (typeName === "Function") {
    typeName = context.name || typeName;
  }
  return typeName && callSite.getMethodName() ? typeName + "." + funcName : funcName;
}
function formatPlain(msg, caller, stack2) {
  var timestamp = (/* @__PURE__ */ new Date()).toUTCString();
  var formatted = timestamp + " " + this._namespace + " deprecated " + msg;
  if (this._traced) {
    for (var i = 0; i < stack2.length; i++) {
      formatted += "\n    at " + callSiteToString(stack2[i]);
    }
    return formatted;
  }
  if (caller) {
    formatted += " at " + formatLocation(caller);
  }
  return formatted;
}
function formatColor(msg, caller, stack2) {
  var formatted = "\x1B[36;1m" + this._namespace + "\x1B[22;39m \x1B[33;1mdeprecated\x1B[22;39m \x1B[0m" + msg + "\x1B[39m";
  if (this._traced) {
    for (var i = 0; i < stack2.length; i++) {
      formatted += "\n    \x1B[36mat " + callSiteToString(stack2[i]) + "\x1B[39m";
    }
    return formatted;
  }
  if (caller) {
    formatted += " \x1B[36m" + formatLocation(caller) + "\x1B[39m";
  }
  return formatted;
}
function formatLocation(callSite) {
  return relative(basePath, callSite[0]) + ":" + callSite[1] + ":" + callSite[2];
}
function getStack() {
  var limit = Error.stackTraceLimit;
  var obj = {};
  var prep = Error.prepareStackTrace;
  Error.prepareStackTrace = prepareObjectStackTrace;
  Error.stackTraceLimit = Math.max(10, limit);
  Error.captureStackTrace(obj);
  var stack2 = obj.stack.slice(1);
  Error.prepareStackTrace = prep;
  Error.stackTraceLimit = limit;
  return stack2;
}
function prepareObjectStackTrace(obj, stack2) {
  return stack2;
}
function wrapfunction(fn, message) {
  if (typeof fn !== "function") {
    throw new TypeError("argument fn must be a function");
  }
  var args = createArgumentsString(fn.length);
  var stack = getStack();
  var site = callSiteLocation(stack[1]);
  site.name = fn.name;
  var deprecatedfn = eval("(function (" + args + ') {\n"use strict"\nlog.call(deprecate, message, site)\nreturn fn.apply(this, arguments)\n})');
  return deprecatedfn;
}
function wrapproperty(obj, prop, message2) {
  if (!obj || typeof obj !== "object" && typeof obj !== "function") {
    throw new TypeError("argument obj must be object");
  }
  var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
  if (!descriptor) {
    throw new TypeError("must call property on owner object");
  }
  if (!descriptor.configurable) {
    throw new TypeError("property must be configurable");
  }
  var deprecate2 = this;
  var stack2 = getStack();
  var site2 = callSiteLocation(stack2[1]);
  site2.name = prop;
  if ("value" in descriptor) {
    descriptor = convertDataDescriptorToAccessor(obj, prop);
  }
  var get = descriptor.get;
  var set = descriptor.set;
  if (typeof get === "function") {
    descriptor.get = function getter() {
      log.call(deprecate2, message2, site2);
      return get.apply(this, arguments);
    };
  }
  if (typeof set === "function") {
    descriptor.set = function setter() {
      log.call(deprecate2, message2, site2);
      return set.apply(this, arguments);
    };
  }
  Object.defineProperty(obj, prop, descriptor);
}
function DeprecationError(namespace, message2, stack2) {
  var error = new Error();
  var stackString;
  Object.defineProperty(error, "constructor", {
    value: DeprecationError
  });
  Object.defineProperty(error, "message", {
    configurable: true,
    enumerable: false,
    value: message2,
    writable: true
  });
  Object.defineProperty(error, "name", {
    enumerable: false,
    configurable: true,
    value: "DeprecationError",
    writable: true
  });
  Object.defineProperty(error, "namespace", {
    configurable: true,
    enumerable: false,
    value: namespace,
    writable: true
  });
  Object.defineProperty(error, "stack", {
    configurable: true,
    enumerable: false,
    get: function() {
      if (stackString !== void 0) {
        return stackString;
      }
      return stackString = createStackString.call(this, stack2);
    },
    set: function setter(val) {
      stackString = val;
    }
  });
  return error;
}
var constants = {
  // agent
  CURRENT_ID: Symbol("agentkeepalive#currentId"),
  CREATE_ID: Symbol("agentkeepalive#createId"),
  INIT_SOCKET: Symbol("agentkeepalive#initSocket"),
  CREATE_HTTPS_CONNECTION: Symbol("agentkeepalive#createHttpsConnection"),
  // socket
  SOCKET_CREATED_TIME: Symbol("agentkeepalive#socketCreatedTime"),
  SOCKET_NAME: Symbol("agentkeepalive#socketName"),
  SOCKET_REQUEST_COUNT: Symbol("agentkeepalive#socketRequestCount"),
  SOCKET_REQUEST_FINISHED_COUNT: Symbol("agentkeepalive#socketRequestFinishedCount")
};
var OriginalAgent = require$$0$3.Agent;
var ms = humanizeMs;
var debug = srcExports("agentkeepalive");
var deprecate = depd_1("agentkeepalive");
var {
  INIT_SOCKET: INIT_SOCKET$1,
  CURRENT_ID,
  CREATE_ID,
  SOCKET_CREATED_TIME,
  SOCKET_NAME,
  SOCKET_REQUEST_COUNT,
  SOCKET_REQUEST_FINISHED_COUNT
} = constants;
var defaultTimeoutListenerCount = 1;
var majorVersion = parseInt(process.version.split(".", 1)[0].substring(1));
if (majorVersion >= 11 && majorVersion <= 12) {
  defaultTimeoutListenerCount = 2;
} else if (majorVersion >= 13) {
  defaultTimeoutListenerCount = 3;
}
var Agent = class extends OriginalAgent {
  constructor(options) {
    options = options || {};
    options.keepAlive = options.keepAlive !== false;
    if (options.freeSocketTimeout === void 0) {
      options.freeSocketTimeout = 4e3;
    }
    if (options.keepAliveTimeout) {
      deprecate("options.keepAliveTimeout is deprecated, please use options.freeSocketTimeout instead");
      options.freeSocketTimeout = options.keepAliveTimeout;
      delete options.keepAliveTimeout;
    }
    if (options.freeSocketKeepAliveTimeout) {
      deprecate("options.freeSocketKeepAliveTimeout is deprecated, please use options.freeSocketTimeout instead");
      options.freeSocketTimeout = options.freeSocketKeepAliveTimeout;
      delete options.freeSocketKeepAliveTimeout;
    }
    if (options.timeout === void 0) {
      options.timeout = Math.max(options.freeSocketTimeout * 2, 8e3);
    }
    options.timeout = ms(options.timeout);
    options.freeSocketTimeout = ms(options.freeSocketTimeout);
    options.socketActiveTTL = options.socketActiveTTL ? ms(options.socketActiveTTL) : 0;
    super(options);
    this[CURRENT_ID] = 0;
    this.createSocketCount = 0;
    this.createSocketCountLastCheck = 0;
    this.createSocketErrorCount = 0;
    this.createSocketErrorCountLastCheck = 0;
    this.closeSocketCount = 0;
    this.closeSocketCountLastCheck = 0;
    this.errorSocketCount = 0;
    this.errorSocketCountLastCheck = 0;
    this.requestCount = 0;
    this.requestCountLastCheck = 0;
    this.timeoutSocketCount = 0;
    this.timeoutSocketCountLastCheck = 0;
    this.on("free", (socket) => {
      const timeout = this.calcSocketTimeout(socket);
      if (timeout > 0 && socket.timeout !== timeout) {
        socket.setTimeout(timeout);
      }
    });
  }
  get freeSocketKeepAliveTimeout() {
    deprecate("agent.freeSocketKeepAliveTimeout is deprecated, please use agent.options.freeSocketTimeout instead");
    return this.options.freeSocketTimeout;
  }
  get timeout() {
    deprecate("agent.timeout is deprecated, please use agent.options.timeout instead");
    return this.options.timeout;
  }
  get socketActiveTTL() {
    deprecate("agent.socketActiveTTL is deprecated, please use agent.options.socketActiveTTL instead");
    return this.options.socketActiveTTL;
  }
  calcSocketTimeout(socket) {
    let freeSocketTimeout = this.options.freeSocketTimeout;
    const socketActiveTTL = this.options.socketActiveTTL;
    if (socketActiveTTL) {
      const aliveTime = Date.now() - socket[SOCKET_CREATED_TIME];
      const diff = socketActiveTTL - aliveTime;
      if (diff <= 0) {
        return diff;
      }
      if (freeSocketTimeout && diff < freeSocketTimeout) {
        freeSocketTimeout = diff;
      }
    }
    if (freeSocketTimeout) {
      const customFreeSocketTimeout = socket.freeSocketTimeout || socket.freeSocketKeepAliveTimeout;
      return customFreeSocketTimeout || freeSocketTimeout;
    }
  }
  keepSocketAlive(socket) {
    const result = super.keepSocketAlive(socket);
    if (!result)
      return result;
    const customTimeout = this.calcSocketTimeout(socket);
    if (typeof customTimeout === "undefined") {
      return true;
    }
    if (customTimeout <= 0) {
      debug(
        "%s(requests: %s, finished: %s) free but need to destroy by TTL, request count %s, diff is %s",
        socket[SOCKET_NAME],
        socket[SOCKET_REQUEST_COUNT],
        socket[SOCKET_REQUEST_FINISHED_COUNT],
        customTimeout
      );
      return false;
    }
    if (socket.timeout !== customTimeout) {
      socket.setTimeout(customTimeout);
    }
    return true;
  }
  // only call on addRequest
  reuseSocket(...args2) {
    super.reuseSocket(...args2);
    const socket = args2[0];
    const req = args2[1];
    req.reusedSocket = true;
    const agentTimeout = this.options.timeout;
    if (getSocketTimeout(socket) !== agentTimeout) {
      socket.setTimeout(agentTimeout);
      debug("%s reset timeout to %sms", socket[SOCKET_NAME], agentTimeout);
    }
    socket[SOCKET_REQUEST_COUNT]++;
    debug(
      "%s(requests: %s, finished: %s) reuse on addRequest, timeout %sms",
      socket[SOCKET_NAME],
      socket[SOCKET_REQUEST_COUNT],
      socket[SOCKET_REQUEST_FINISHED_COUNT],
      getSocketTimeout(socket)
    );
  }
  [CREATE_ID]() {
    const id = this[CURRENT_ID]++;
    if (this[CURRENT_ID] === Number.MAX_SAFE_INTEGER)
      this[CURRENT_ID] = 0;
    return id;
  }
  [INIT_SOCKET$1](socket, options) {
    if (options.timeout) {
      const timeout = getSocketTimeout(socket);
      if (!timeout) {
        socket.setTimeout(options.timeout);
      }
    }
    if (this.options.keepAlive) {
      socket.setNoDelay(true);
    }
    this.createSocketCount++;
    if (this.options.socketActiveTTL) {
      socket[SOCKET_CREATED_TIME] = Date.now();
    }
    socket[SOCKET_NAME] = `sock[${this[CREATE_ID]()}#${options._agentKey}]`.split("-----BEGIN", 1)[0];
    socket[SOCKET_REQUEST_COUNT] = 1;
    socket[SOCKET_REQUEST_FINISHED_COUNT] = 0;
    installListeners(this, socket, options);
  }
  createConnection(options, oncreate) {
    let called = false;
    const onNewCreate = (err, socket) => {
      if (called)
        return;
      called = true;
      if (err) {
        this.createSocketErrorCount++;
        return oncreate(err);
      }
      this[INIT_SOCKET$1](socket, options);
      oncreate(err, socket);
    };
    const newSocket = super.createConnection(options, onNewCreate);
    if (newSocket)
      onNewCreate(null, newSocket);
  }
  get statusChanged() {
    const changed = this.createSocketCount !== this.createSocketCountLastCheck || this.createSocketErrorCount !== this.createSocketErrorCountLastCheck || this.closeSocketCount !== this.closeSocketCountLastCheck || this.errorSocketCount !== this.errorSocketCountLastCheck || this.timeoutSocketCount !== this.timeoutSocketCountLastCheck || this.requestCount !== this.requestCountLastCheck;
    if (changed) {
      this.createSocketCountLastCheck = this.createSocketCount;
      this.createSocketErrorCountLastCheck = this.createSocketErrorCount;
      this.closeSocketCountLastCheck = this.closeSocketCount;
      this.errorSocketCountLastCheck = this.errorSocketCount;
      this.timeoutSocketCountLastCheck = this.timeoutSocketCount;
      this.requestCountLastCheck = this.requestCount;
    }
    return changed;
  }
  getCurrentStatus() {
    return {
      createSocketCount: this.createSocketCount,
      createSocketErrorCount: this.createSocketErrorCount,
      closeSocketCount: this.closeSocketCount,
      errorSocketCount: this.errorSocketCount,
      timeoutSocketCount: this.timeoutSocketCount,
      requestCount: this.requestCount,
      freeSockets: inspect(this.freeSockets),
      sockets: inspect(this.sockets),
      requests: inspect(this.requests)
    };
  }
};
function getSocketTimeout(socket) {
  return socket.timeout || socket._idleTimeout;
}
function installListeners(agent2, socket, options) {
  debug("%s create, timeout %sms", socket[SOCKET_NAME], getSocketTimeout(socket));
  function onFree() {
    if (!socket._httpMessage && socket[SOCKET_REQUEST_COUNT] === 1)
      return;
    socket[SOCKET_REQUEST_FINISHED_COUNT]++;
    agent2.requestCount++;
    debug(
      "%s(requests: %s, finished: %s) free",
      socket[SOCKET_NAME],
      socket[SOCKET_REQUEST_COUNT],
      socket[SOCKET_REQUEST_FINISHED_COUNT]
    );
    const name = agent2.getName(options);
    if (socket.writable && agent2.requests[name] && agent2.requests[name].length) {
      socket[SOCKET_REQUEST_COUNT]++;
      debug(
        "%s(requests: %s, finished: %s) will be reuse on agent free event",
        socket[SOCKET_NAME],
        socket[SOCKET_REQUEST_COUNT],
        socket[SOCKET_REQUEST_FINISHED_COUNT]
      );
    }
  }
  socket.on("free", onFree);
  function onClose(isError) {
    debug(
      "%s(requests: %s, finished: %s) close, isError: %s",
      socket[SOCKET_NAME],
      socket[SOCKET_REQUEST_COUNT],
      socket[SOCKET_REQUEST_FINISHED_COUNT],
      isError
    );
    agent2.closeSocketCount++;
  }
  socket.on("close", onClose);
  function onTimeout() {
    const listenerCount = socket.listeners("timeout").length;
    const timeout = getSocketTimeout(socket);
    const req = socket._httpMessage;
    const reqTimeoutListenerCount = req && req.listeners("timeout").length || 0;
    debug(
      "%s(requests: %s, finished: %s) timeout after %sms, listeners %s, defaultTimeoutListenerCount %s, hasHttpRequest %s, HttpRequest timeoutListenerCount %s",
      socket[SOCKET_NAME],
      socket[SOCKET_REQUEST_COUNT],
      socket[SOCKET_REQUEST_FINISHED_COUNT],
      timeout,
      listenerCount,
      defaultTimeoutListenerCount,
      !!req,
      reqTimeoutListenerCount
    );
    if (debug.enabled) {
      debug("timeout listeners: %s", socket.listeners("timeout").map((f) => f.name).join(", "));
    }
    agent2.timeoutSocketCount++;
    const name = agent2.getName(options);
    if (agent2.freeSockets[name] && agent2.freeSockets[name].indexOf(socket) !== -1) {
      socket.destroy();
      agent2.removeSocket(socket, options);
      debug("%s is free, destroy quietly", socket[SOCKET_NAME]);
    } else {
      if (reqTimeoutListenerCount === 0) {
        const error = new Error("Socket timeout");
        error.code = "ERR_SOCKET_TIMEOUT";
        error.timeout = timeout;
        socket.destroy(error);
        agent2.removeSocket(socket, options);
        debug("%s destroy with timeout error", socket[SOCKET_NAME]);
      }
    }
  }
  socket.on("timeout", onTimeout);
  function onError(err) {
    const listenerCount = socket.listeners("error").length;
    debug(
      "%s(requests: %s, finished: %s) error: %s, listenerCount: %s",
      socket[SOCKET_NAME],
      socket[SOCKET_REQUEST_COUNT],
      socket[SOCKET_REQUEST_FINISHED_COUNT],
      err,
      listenerCount
    );
    agent2.errorSocketCount++;
    if (listenerCount === 1) {
      debug("%s emit uncaught error event", socket[SOCKET_NAME]);
      socket.removeListener("error", onError);
      socket.emit("error", err);
    }
  }
  socket.on("error", onError);
  function onRemove() {
    debug(
      "%s(requests: %s, finished: %s) agentRemove",
      socket[SOCKET_NAME],
      socket[SOCKET_REQUEST_COUNT],
      socket[SOCKET_REQUEST_FINISHED_COUNT]
    );
    socket.removeListener("close", onClose);
    socket.removeListener("error", onError);
    socket.removeListener("free", onFree);
    socket.removeListener("timeout", onTimeout);
    socket.removeListener("agentRemove", onRemove);
  }
  socket.on("agentRemove", onRemove);
}
var agent = Agent;
function inspect(obj) {
  const res = {};
  for (const key in obj) {
    res[key] = obj[key].length;
  }
  return res;
}
var OriginalHttpsAgent = require$$0$4.Agent;
var HttpAgent = agent;
var {
  INIT_SOCKET,
  CREATE_HTTPS_CONNECTION
} = constants;
var HttpsAgent = class extends HttpAgent {
  constructor(options) {
    super(options);
    this.defaultPort = 443;
    this.protocol = "https:";
    this.maxCachedSessions = this.options.maxCachedSessions;
    if (this.maxCachedSessions === void 0) {
      this.maxCachedSessions = 100;
    }
    this._sessionCache = {
      map: {},
      list: []
    };
  }
  createConnection(options) {
    const socket = this[CREATE_HTTPS_CONNECTION](options);
    this[INIT_SOCKET](socket, options);
    return socket;
  }
};
HttpsAgent.prototype[CREATE_HTTPS_CONNECTION] = OriginalHttpsAgent.prototype.createConnection;
[
  "getName",
  "_getSession",
  "_cacheSession",
  // https://github.com/nodejs/node/pull/4982
  "_evictSession"
].forEach(function(method) {
  if (typeof OriginalHttpsAgent.prototype[method] === "function") {
    HttpsAgent.prototype[method] = OriginalHttpsAgent.prototype[method];
  }
});
var https_agent = HttpsAgent;
(function(module) {
  module.exports = agent;
  module.exports.HttpsAgent = https_agent;
  module.exports.constants = constants;
})(agentkeepalive);
var HttpKeepAliveAgent = /* @__PURE__ */ getDefaultExportFromCjs(agentkeepaliveExports);
var objToString = Object.prototype.toString;
var objKeys = Object.keys || function(obj) {
  var keys = [];
  for (var name in obj) {
    keys.push(name);
  }
  return keys;
};
function stringify2(val, isArrayProp) {
  var i, max, str, keys, key, propVal, toStr;
  if (val === true) {
    return "true";
  }
  if (val === false) {
    return "false";
  }
  switch (typeof val) {
    case "object":
      if (val === null) {
        return null;
      } else if (val.toJSON && typeof val.toJSON === "function") {
        return stringify2(val.toJSON(), isArrayProp);
      } else {
        toStr = objToString.call(val);
        if (toStr === "[object Array]") {
          str = "[";
          max = val.length - 1;
          for (i = 0; i < max; i++) {
            str += stringify2(val[i], true) + ",";
          }
          if (max > -1) {
            str += stringify2(val[i], true);
          }
          return str + "]";
        } else if (toStr === "[object Object]") {
          keys = objKeys(val).sort();
          max = keys.length;
          str = "";
          i = 0;
          while (i < max) {
            key = keys[i];
            propVal = stringify2(val[key], false);
            if (propVal !== void 0) {
              if (str) {
                str += ",";
              }
              str += JSON.stringify(key) + ":" + propVal;
            }
            i++;
          }
          return "{" + str + "}";
        } else {
          return JSON.stringify(val);
        }
      }
    case "function":
    case "undefined":
      return isArrayProp ? null : void 0;
    case "string":
      return JSON.stringify(val);
    default:
      return isFinite(val) ? val : null;
  }
}
var fastStableStringify = function(val) {
  var returnVal = stringify2(val, false);
  if (returnVal !== void 0) {
    return "" + returnVal;
  }
};
var fastStableStringify$1 = fastStableStringify;
var MINIMUM_SLOT_PER_EPOCH = 32;
function trailingZeros(n) {
  let trailingZeros2 = 0;
  while (n > 1) {
    n /= 2;
    trailingZeros2++;
  }
  return trailingZeros2;
}
function nextPowerOfTwo(n) {
  if (n === 0)
    return 1;
  n--;
  n |= n >> 1;
  n |= n >> 2;
  n |= n >> 4;
  n |= n >> 8;
  n |= n >> 16;
  n |= n >> 32;
  return n + 1;
}
var EpochSchedule = class {
  /** The maximum number of slots in each epoch */
  /** The number of slots before beginning of an epoch to calculate a leader schedule for that epoch */
  /** Indicates whether epochs start short and grow */
  /** The first epoch with `slotsPerEpoch` slots */
  /** The first slot of `firstNormalEpoch` */
  constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot) {
    this.slotsPerEpoch = void 0;
    this.leaderScheduleSlotOffset = void 0;
    this.warmup = void 0;
    this.firstNormalEpoch = void 0;
    this.firstNormalSlot = void 0;
    this.slotsPerEpoch = slotsPerEpoch;
    this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;
    this.warmup = warmup;
    this.firstNormalEpoch = firstNormalEpoch;
    this.firstNormalSlot = firstNormalSlot;
  }
  getEpoch(slot) {
    return this.getEpochAndSlotIndex(slot)[0];
  }
  getEpochAndSlotIndex(slot) {
    if (slot < this.firstNormalSlot) {
      const epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;
      const epochLen = this.getSlotsInEpoch(epoch);
      const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);
      return [epoch, slotIndex];
    } else {
      const normalSlotIndex = slot - this.firstNormalSlot;
      const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);
      const epoch = this.firstNormalEpoch + normalEpochIndex;
      const slotIndex = normalSlotIndex % this.slotsPerEpoch;
      return [epoch, slotIndex];
    }
  }
  getFirstSlotInEpoch(epoch) {
    if (epoch <= this.firstNormalEpoch) {
      return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;
    } else {
      return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
    }
  }
  getLastSlotInEpoch(epoch) {
    return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;
  }
  getSlotsInEpoch(epoch) {
    if (epoch < this.firstNormalEpoch) {
      return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));
    } else {
      return this.slotsPerEpoch;
    }
  }
};
var SendTransactionError = class extends Error {
  constructor(message2, logs) {
    super(message2);
    this.logs = void 0;
    this.logs = logs;
  }
};
var SolanaJSONRPCErrorCode = {
  JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
  JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
  JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
  JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
  JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
  JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
  JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
  JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
  JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
  JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
  JSON_RPC_SCAN_ERROR: -32012,
  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
  JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
  JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
  JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016
};
var SolanaJSONRPCError = class extends Error {
  constructor({
    code,
    message: message2,
    data
  }, customMessage) {
    super(customMessage != null ? `${customMessage}: ${message2}` : message2);
    this.code = void 0;
    this.data = void 0;
    this.code = code;
    this.data = data;
    this.name = "SolanaJSONRPCError";
  }
};
function fetchImpl(input, init) {
  return __async(this, null, function* () {
    const processedInput = typeof input === "string" && input.slice(0, 2) === "//" ? "https:" + input : input;
    return yield lib_default(processedInput, init);
  });
}
var RpcWebSocketClient = class extends import_client.default {
  constructor(address, options, generate_request_id) {
    const webSocketFactory = (url) => {
      const rpc = (0, import_websocket.default)(url, __spreadValues({
        autoconnect: true,
        max_reconnects: 5,
        reconnect: true,
        reconnect_interval: 1e3
      }, options));
      if ("socket" in rpc) {
        this.underlyingSocket = rpc.socket;
      } else {
        this.underlyingSocket = rpc;
      }
      return rpc;
    };
    super(webSocketFactory, address, options, generate_request_id);
    this.underlyingSocket = void 0;
  }
  call(...args2) {
    var _a;
    const readyState = (_a = this.underlyingSocket) == null ? void 0 : _a.readyState;
    if (readyState === 1) {
      return super.call(...args2);
    }
    return Promise.reject(new Error("Tried to call a JSON-RPC method `" + args2[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + readyState + ")"));
  }
  notify(...args2) {
    var _a;
    const readyState = (_a = this.underlyingSocket) == null ? void 0 : _a.readyState;
    if (readyState === 1) {
      return super.notify(...args2);
    }
    return Promise.reject(new Error("Tried to send a JSON-RPC notification `" + args2[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + readyState + ")"));
  }
};
var NUM_TICKS_PER_SECOND = 160;
var DEFAULT_TICKS_PER_SLOT = 64;
var NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;
var MS_PER_SLOT = 1e3 / NUM_SLOTS_PER_SECOND;
function decodeData(type2, data) {
  let decoded;
  try {
    decoded = type2.layout.decode(data);
  } catch (err) {
    throw new Error("invalid instruction; " + err);
  }
  if (decoded.typeIndex !== type2.index) {
    throw new Error(`invalid account data; account type mismatch ${decoded.typeIndex} != ${type2.index}`);
  }
  return decoded;
}
var LOOKUP_TABLE_META_SIZE = 56;
var AddressLookupTableAccount = class {
  constructor(args2) {
    this.key = void 0;
    this.state = void 0;
    this.key = args2.key;
    this.state = args2.state;
  }
  isActive() {
    const U64_MAX = BigInt("0xffffffffffffffff");
    return this.state.deactivationSlot === U64_MAX;
  }
  static deserialize(accountData) {
    const meta = decodeData(LookupTableMetaLayout, accountData);
    const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;
    assert3(serializedAddressesLen >= 0, "lookup table is invalid");
    assert3(serializedAddressesLen % 32 === 0, "lookup table is invalid");
    const numSerializedAddresses = serializedAddressesLen / 32;
    const {
      addresses
    } = BufferLayout.struct([BufferLayout.seq(publicKey(), numSerializedAddresses, "addresses")]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE));
    return {
      deactivationSlot: meta.deactivationSlot,
      lastExtendedSlot: meta.lastExtendedSlot,
      lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,
      authority: meta.authority.length !== 0 ? new PublicKey(meta.authority[0]) : void 0,
      addresses: addresses.map((address) => new PublicKey(address))
    };
  }
};
var LookupTableMetaLayout = {
  index: 1,
  layout: BufferLayout.struct([
    BufferLayout.u32("typeIndex"),
    u642("deactivationSlot"),
    BufferLayout.nu64("lastExtendedSlot"),
    BufferLayout.u8("lastExtendedStartIndex"),
    BufferLayout.u8(),
    // option
    BufferLayout.seq(publicKey(), BufferLayout.offset(BufferLayout.u8(), -1), "authority")
  ])
};
var URL_RE = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
function makeWebsocketUrl(endpoint2) {
  const matches = endpoint2.match(URL_RE);
  if (matches == null) {
    throw TypeError(`Failed to validate endpoint URL \`${endpoint2}\``);
  }
  const [
    _,
    // eslint-disable-line @typescript-eslint/no-unused-vars
    hostish,
    portWithColon,
    rest
  ] = matches;
  const protocol = endpoint2.startsWith("https:") ? "wss:" : "ws:";
  const startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);
  const websocketPort = (
    // Only shift the port by +1 as a convention for ws(s) only if given endpoint
    // is explictly specifying the endpoint port (HTTP-based RPC), assuming
    // we're directly trying to connect to solana-validator's ws listening port.
    // When the endpoint omits the port, we're connecting to the protocol
    // default ports: http(80) or https(443) and it's assumed we're behind a reverse
    // proxy which manages WebSocket upgrade and backend port redirection.
    startPort == null ? "" : `:${startPort + 1}`
  );
  return `${protocol}//${hostish}${websocketPort}${rest}`;
}
var PublicKeyFromString = coerce(instance(PublicKey), string(), (value) => new PublicKey(value));
var RawAccountDataResult = tuple([string(), literal("base64")]);
var BufferFromRawAccountData = coerce(instance(Buffer2), RawAccountDataResult, (value) => Buffer2.from(value[0], "base64"));
var BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1e3;
function assertEndpointUrl(putativeUrl) {
  if (/^https?:/.test(putativeUrl) === false) {
    throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
  }
  return putativeUrl;
}
function extractCommitmentFromConfig(commitmentOrConfig) {
  let commitment;
  let config;
  if (typeof commitmentOrConfig === "string") {
    commitment = commitmentOrConfig;
  } else if (commitmentOrConfig) {
    const _a = commitmentOrConfig, {
      commitment: specifiedCommitment
    } = _a, specifiedConfig = __objRest(_a, [
      "commitment"
    ]);
    commitment = specifiedCommitment;
    config = specifiedConfig;
  }
  return {
    commitment,
    config
  };
}
function createRpcResult(result) {
  return union([type({
    jsonrpc: literal("2.0"),
    id: string(),
    result
  }), type({
    jsonrpc: literal("2.0"),
    id: string(),
    error: type({
      code: unknown(),
      message: string(),
      data: optional(any())
    })
  })]);
}
var UnknownRpcResult = createRpcResult(unknown());
function jsonRpcResult(schema) {
  return coerce(createRpcResult(schema), UnknownRpcResult, (value) => {
    if ("error" in value) {
      return value;
    } else {
      return __spreadProps(__spreadValues({}, value), {
        result: create(value.result, schema)
      });
    }
  });
}
function jsonRpcResultAndContext(value) {
  return jsonRpcResult(type({
    context: type({
      slot: number2()
    }),
    value
  }));
}
function notificationResultAndContext(value) {
  return type({
    context: type({
      slot: number2()
    }),
    value
  });
}
function versionedMessageFromResponse(version2, response) {
  if (version2 === 0) {
    return new MessageV0({
      header: response.header,
      staticAccountKeys: response.accountKeys.map((accountKey) => new PublicKey(accountKey)),
      recentBlockhash: response.recentBlockhash,
      compiledInstructions: response.instructions.map((ix) => ({
        programIdIndex: ix.programIdIndex,
        accountKeyIndexes: ix.accounts,
        data: import_bs58.default.decode(ix.data)
      })),
      addressTableLookups: response.addressTableLookups
    });
  } else {
    return new Message(response);
  }
}
var GetInflationGovernorResult = type({
  foundation: number2(),
  foundationTerm: number2(),
  initial: number2(),
  taper: number2(),
  terminal: number2()
});
var GetInflationRewardResult = jsonRpcResult(array(nullable(type({
  epoch: number2(),
  effectiveSlot: number2(),
  amount: number2(),
  postBalance: number2(),
  commission: optional(nullable(number2()))
}))));
var GetRecentPrioritizationFeesResult = array(type({
  slot: number2(),
  prioritizationFee: number2()
}));
var GetInflationRateResult = type({
  total: number2(),
  validator: number2(),
  foundation: number2(),
  epoch: number2()
});
var GetEpochInfoResult = type({
  epoch: number2(),
  slotIndex: number2(),
  slotsInEpoch: number2(),
  absoluteSlot: number2(),
  blockHeight: optional(number2()),
  transactionCount: optional(number2())
});
var GetEpochScheduleResult = type({
  slotsPerEpoch: number2(),
  leaderScheduleSlotOffset: number2(),
  warmup: boolean(),
  firstNormalEpoch: number2(),
  firstNormalSlot: number2()
});
var GetLeaderScheduleResult = record(string(), array(number2()));
var TransactionErrorResult = nullable(union([type({}), string()]));
var SignatureStatusResult = type({
  err: TransactionErrorResult
});
var SignatureReceivedResult = literal("receivedSignature");
var VersionResult = type({
  "solana-core": string(),
  "feature-set": optional(number2())
});
var SimulatedTransactionResponseStruct = jsonRpcResultAndContext(type({
  err: nullable(union([type({}), string()])),
  logs: nullable(array(string())),
  accounts: optional(nullable(array(nullable(type({
    executable: boolean(),
    owner: string(),
    lamports: number2(),
    data: array(string()),
    rentEpoch: optional(number2())
  }))))),
  unitsConsumed: optional(number2()),
  returnData: optional(nullable(type({
    programId: string(),
    data: tuple([string(), literal("base64")])
  })))
}));
var BlockProductionResponseStruct = jsonRpcResultAndContext(type({
  byIdentity: record(string(), array(number2())),
  range: type({
    firstSlot: number2(),
    lastSlot: number2()
  })
}));
function createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {
  const fetch2 = customFetch ? customFetch : fetchImpl;
  let agent2;
  {
    if (httpAgent == null) {
      {
        const agentOptions = {
          // One second fewer than the Solana RPC's keepalive timeout.
          // Read more: https://github.com/solana-labs/solana/issues/27859#issuecomment-1340097889
          freeSocketTimeout: 19e3,
          keepAlive: true,
          maxSockets: 25
        };
        if (url.startsWith("https:")) {
          agent2 = new agentkeepaliveExports.HttpsAgent(agentOptions);
        } else {
          agent2 = new HttpKeepAliveAgent(agentOptions);
        }
      }
    } else {
      if (httpAgent !== false) {
        const isHttps = url.startsWith("https:");
        if (isHttps && !(httpAgent instanceof Agent$1)) {
          throw new Error("The endpoint `" + url + "` can only be paired with an `https.Agent`. You have, instead, supplied an `http.Agent` through `httpAgent`.");
        } else if (!isHttps && httpAgent instanceof Agent$1) {
          throw new Error("The endpoint `" + url + "` can only be paired with an `http.Agent`. You have, instead, supplied an `https.Agent` through `httpAgent`.");
        }
        agent2 = httpAgent;
      }
    }
  }
  let fetchWithMiddleware;
  if (fetchMiddleware) {
    fetchWithMiddleware = (info, init) => __async(this, null, function* () {
      const modifiedFetchArgs = yield new Promise((resolve, reject) => {
        try {
          fetchMiddleware(info, init, (modifiedInfo, modifiedInit) => resolve([modifiedInfo, modifiedInit]));
        } catch (error) {
          reject(error);
        }
      });
      return yield fetch2(...modifiedFetchArgs);
    });
  }
  const clientBrowser = new import_browser.default((request, callback) => __async(this, null, function* () {
    const options = {
      method: "POST",
      body: request,
      agent: agent2,
      headers: Object.assign({
        "Content-Type": "application/json"
      }, httpHeaders || {}, COMMON_HTTP_HEADERS)
    };
    try {
      let too_many_requests_retries = 5;
      let res;
      let waitTime = 500;
      for (; ; ) {
        if (fetchWithMiddleware) {
          res = yield fetchWithMiddleware(url, options);
        } else {
          res = yield fetch2(url, options);
        }
        if (res.status !== 429) {
          break;
        }
        if (disableRetryOnRateLimit === true) {
          break;
        }
        too_many_requests_retries -= 1;
        if (too_many_requests_retries === 0) {
          break;
        }
        console.log(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);
        yield sleep(waitTime);
        waitTime *= 2;
      }
      const text = yield res.text();
      if (res.ok) {
        callback(null, text);
      } else {
        callback(new Error(`${res.status} ${res.statusText}: ${text}`));
      }
    } catch (err) {
      if (err instanceof Error)
        callback(err);
    }
  }), {});
  return clientBrowser;
}
function createRpcRequest(client) {
  return (method, args2) => {
    return new Promise((resolve, reject) => {
      client.request(method, args2, (err, response) => {
        if (err) {
          reject(err);
          return;
        }
        resolve(response);
      });
    });
  };
}
function createRpcBatchRequest(client) {
  return (requests) => {
    return new Promise((resolve, reject) => {
      if (requests.length === 0)
        resolve([]);
      const batch = requests.map((params) => {
        return client.request(params.methodName, params.args);
      });
      client.request(batch, (err, response) => {
        if (err) {
          reject(err);
          return;
        }
        resolve(response);
      });
    });
  };
}
var GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);
var GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);
var GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);
var GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);
var GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);
var GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);
var SlotRpcResult = jsonRpcResult(number2());
var GetSupplyRpcResult = jsonRpcResultAndContext(type({
  total: number2(),
  circulating: number2(),
  nonCirculating: number2(),
  nonCirculatingAccounts: array(PublicKeyFromString)
}));
var TokenAmountResult = type({
  amount: string(),
  uiAmount: nullable(number2()),
  decimals: number2(),
  uiAmountString: optional(string())
});
var GetTokenLargestAccountsResult = jsonRpcResultAndContext(array(type({
  address: PublicKeyFromString,
  amount: string(),
  uiAmount: nullable(number2()),
  decimals: number2(),
  uiAmountString: optional(string())
})));
var GetTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
  pubkey: PublicKeyFromString,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number2(),
    data: BufferFromRawAccountData,
    rentEpoch: number2()
  })
})));
var ParsedAccountDataResult = type({
  program: string(),
  parsed: unknown(),
  space: number2()
});
var GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
  pubkey: PublicKeyFromString,
  account: type({
    executable: boolean(),
    owner: PublicKeyFromString,
    lamports: number2(),
    data: ParsedAccountDataResult,
    rentEpoch: number2()
  })
})));
var GetLargestAccountsRpcResult = jsonRpcResultAndContext(array(type({
  lamports: number2(),
  address: PublicKeyFromString
})));
var AccountInfoResult = type({
  executable: boolean(),
  owner: PublicKeyFromString,
  lamports: number2(),
  data: BufferFromRawAccountData,
  rentEpoch: number2()
});
var KeyedAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});
var ParsedOrRawAccountData = coerce(union([instance(Buffer2), ParsedAccountDataResult]), union([RawAccountDataResult, ParsedAccountDataResult]), (value) => {
  if (Array.isArray(value)) {
    return create(value, BufferFromRawAccountData);
  } else {
    return value;
  }
});
var ParsedAccountInfoResult = type({
  executable: boolean(),
  owner: PublicKeyFromString,
  lamports: number2(),
  data: ParsedOrRawAccountData,
  rentEpoch: number2()
});
var KeyedParsedAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: ParsedAccountInfoResult
});
var StakeActivationResult = type({
  state: union([literal("active"), literal("inactive"), literal("activating"), literal("deactivating")]),
  active: number2(),
  inactive: number2()
});
var GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(array(type({
  signature: string(),
  slot: number2(),
  err: TransactionErrorResult,
  memo: nullable(string()),
  blockTime: optional(nullable(number2()))
})));
var GetSignaturesForAddressRpcResult = jsonRpcResult(array(type({
  signature: string(),
  slot: number2(),
  err: TransactionErrorResult,
  memo: nullable(string()),
  blockTime: optional(nullable(number2()))
})));
var AccountNotificationResult = type({
  subscription: number2(),
  result: notificationResultAndContext(AccountInfoResult)
});
var ProgramAccountInfoResult = type({
  pubkey: PublicKeyFromString,
  account: AccountInfoResult
});
var ProgramAccountNotificationResult = type({
  subscription: number2(),
  result: notificationResultAndContext(ProgramAccountInfoResult)
});
var SlotInfoResult = type({
  parent: number2(),
  slot: number2(),
  root: number2()
});
var SlotNotificationResult = type({
  subscription: number2(),
  result: SlotInfoResult
});
var SlotUpdateResult = union([type({
  type: union([literal("firstShredReceived"), literal("completed"), literal("optimisticConfirmation"), literal("root")]),
  slot: number2(),
  timestamp: number2()
}), type({
  type: literal("createdBank"),
  parent: number2(),
  slot: number2(),
  timestamp: number2()
}), type({
  type: literal("frozen"),
  slot: number2(),
  timestamp: number2(),
  stats: type({
    numTransactionEntries: number2(),
    numSuccessfulTransactions: number2(),
    numFailedTransactions: number2(),
    maxTransactionsPerEntry: number2()
  })
}), type({
  type: literal("dead"),
  slot: number2(),
  timestamp: number2(),
  err: string()
})]);
var SlotUpdateNotificationResult = type({
  subscription: number2(),
  result: SlotUpdateResult
});
var SignatureNotificationResult = type({
  subscription: number2(),
  result: notificationResultAndContext(union([SignatureStatusResult, SignatureReceivedResult]))
});
var RootNotificationResult = type({
  subscription: number2(),
  result: number2()
});
var ContactInfoResult = type({
  pubkey: string(),
  gossip: nullable(string()),
  tpu: nullable(string()),
  rpc: nullable(string()),
  version: nullable(string())
});
var VoteAccountInfoResult = type({
  votePubkey: string(),
  nodePubkey: string(),
  activatedStake: number2(),
  epochVoteAccount: boolean(),
  epochCredits: array(tuple([number2(), number2(), number2()])),
  commission: number2(),
  lastVote: number2(),
  rootSlot: nullable(number2())
});
var GetVoteAccounts = jsonRpcResult(type({
  current: array(VoteAccountInfoResult),
  delinquent: array(VoteAccountInfoResult)
}));
var ConfirmationStatus = union([literal("processed"), literal("confirmed"), literal("finalized")]);
var SignatureStatusResponse = type({
  slot: number2(),
  confirmations: nullable(number2()),
  err: TransactionErrorResult,
  confirmationStatus: optional(ConfirmationStatus)
});
var GetSignatureStatusesRpcResult = jsonRpcResultAndContext(array(nullable(SignatureStatusResponse)));
var GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult(number2());
var AddressTableLookupStruct = type({
  accountKey: PublicKeyFromString,
  writableIndexes: array(number2()),
  readonlyIndexes: array(number2())
});
var ConfirmedTransactionResult = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(string()),
    header: type({
      numRequiredSignatures: number2(),
      numReadonlySignedAccounts: number2(),
      numReadonlyUnsignedAccounts: number2()
    }),
    instructions: array(type({
      accounts: array(number2()),
      data: string(),
      programIdIndex: number2()
    })),
    recentBlockhash: string(),
    addressTableLookups: optional(array(AddressTableLookupStruct))
  })
});
var AnnotatedAccountKey = type({
  pubkey: PublicKeyFromString,
  signer: boolean(),
  writable: boolean(),
  source: optional(union([literal("transaction"), literal("lookupTable")]))
});
var ConfirmedTransactionAccountsModeResult = type({
  accountKeys: array(AnnotatedAccountKey),
  signatures: array(string())
});
var ParsedInstructionResult = type({
  parsed: unknown(),
  program: string(),
  programId: PublicKeyFromString
});
var RawInstructionResult = type({
  accounts: array(PublicKeyFromString),
  data: string(),
  programId: PublicKeyFromString
});
var InstructionResult = union([RawInstructionResult, ParsedInstructionResult]);
var UnknownInstructionResult = union([type({
  parsed: unknown(),
  program: string(),
  programId: string()
}), type({
  accounts: array(string()),
  data: string(),
  programId: string()
})]);
var ParsedOrRawInstruction = coerce(InstructionResult, UnknownInstructionResult, (value) => {
  if ("accounts" in value) {
    return create(value, RawInstructionResult);
  } else {
    return create(value, ParsedInstructionResult);
  }
});
var ParsedConfirmedTransactionResult = type({
  signatures: array(string()),
  message: type({
    accountKeys: array(AnnotatedAccountKey),
    instructions: array(ParsedOrRawInstruction),
    recentBlockhash: string(),
    addressTableLookups: optional(nullable(array(AddressTableLookupStruct)))
  })
});
var TokenBalanceResult = type({
  accountIndex: number2(),
  mint: string(),
  owner: optional(string()),
  uiTokenAmount: TokenAmountResult
});
var LoadedAddressesResult = type({
  writable: array(PublicKeyFromString),
  readonly: array(PublicKeyFromString)
});
var ConfirmedTransactionMetaResult = type({
  err: TransactionErrorResult,
  fee: number2(),
  innerInstructions: optional(nullable(array(type({
    index: number2(),
    instructions: array(type({
      accounts: array(number2()),
      data: string(),
      programIdIndex: number2()
    }))
  })))),
  preBalances: array(number2()),
  postBalances: array(number2()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult))),
  loadedAddresses: optional(LoadedAddressesResult),
  computeUnitsConsumed: optional(number2())
});
var ParsedConfirmedTransactionMetaResult = type({
  err: TransactionErrorResult,
  fee: number2(),
  innerInstructions: optional(nullable(array(type({
    index: number2(),
    instructions: array(ParsedOrRawInstruction)
  })))),
  preBalances: array(number2()),
  postBalances: array(number2()),
  logMessages: optional(nullable(array(string()))),
  preTokenBalances: optional(nullable(array(TokenBalanceResult))),
  postTokenBalances: optional(nullable(array(TokenBalanceResult))),
  loadedAddresses: optional(LoadedAddressesResult),
  computeUnitsConsumed: optional(number2())
});
var TransactionVersionStruct = union([literal(0), literal("legacy")]);
var RewardsResult = type({
  pubkey: string(),
  lamports: number2(),
  postBalance: nullable(number2()),
  rewardType: nullable(string()),
  commission: optional(nullable(number2()))
});
var GetBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number2(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number2()),
  blockHeight: nullable(number2())
})));
var GetNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number2(),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number2()),
  blockHeight: nullable(number2())
})));
var GetAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number2(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: nullable(ConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number2()),
  blockHeight: nullable(number2())
})));
var GetParsedBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number2(),
  transactions: array(type({
    transaction: ParsedConfirmedTransactionResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number2()),
  blockHeight: nullable(number2())
})));
var GetParsedAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number2(),
  transactions: array(type({
    transaction: ConfirmedTransactionAccountsModeResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    version: optional(TransactionVersionStruct)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number2()),
  blockHeight: nullable(number2())
})));
var GetParsedNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number2(),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number2()),
  blockHeight: nullable(number2())
})));
var GetConfirmedBlockRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number2(),
  transactions: array(type({
    transaction: ConfirmedTransactionResult,
    meta: nullable(ConfirmedTransactionMetaResult)
  })),
  rewards: optional(array(RewardsResult)),
  blockTime: nullable(number2())
})));
var GetBlockSignaturesRpcResult = jsonRpcResult(nullable(type({
  blockhash: string(),
  previousBlockhash: string(),
  parentSlot: number2(),
  signatures: array(string()),
  blockTime: nullable(number2())
})));
var GetTransactionRpcResult = jsonRpcResult(nullable(type({
  slot: number2(),
  meta: ConfirmedTransactionMetaResult,
  blockTime: optional(nullable(number2())),
  transaction: ConfirmedTransactionResult,
  version: optional(TransactionVersionStruct)
})));
var GetParsedTransactionRpcResult = jsonRpcResult(nullable(type({
  slot: number2(),
  transaction: ParsedConfirmedTransactionResult,
  meta: nullable(ParsedConfirmedTransactionMetaResult),
  blockTime: optional(nullable(number2())),
  version: optional(TransactionVersionStruct)
})));
var GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext(type({
  blockhash: string(),
  feeCalculator: type({
    lamportsPerSignature: number2()
  })
}));
var GetLatestBlockhashRpcResult = jsonRpcResultAndContext(type({
  blockhash: string(),
  lastValidBlockHeight: number2()
}));
var PerfSampleResult = type({
  slot: number2(),
  numTransactions: number2(),
  numSlots: number2(),
  samplePeriodSecs: number2()
});
var GetRecentPerformanceSamplesRpcResult = jsonRpcResult(array(PerfSampleResult));
var GetFeeCalculatorRpcResult = jsonRpcResultAndContext(nullable(type({
  feeCalculator: type({
    lamportsPerSignature: number2()
  })
})));
var RequestAirdropRpcResult = jsonRpcResult(string());
var SendTransactionRpcResult = jsonRpcResult(string());
var LogsResult = type({
  err: TransactionErrorResult,
  logs: array(string()),
  signature: string()
});
var LogsNotificationResult = type({
  result: notificationResultAndContext(LogsResult),
  subscription: number2()
});
var COMMON_HTTP_HEADERS = {
  "solana-client": `js/${"0.0.0-development"}`
};
var Connection = class {
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal
   * A number that we increment every time an active connection closes.
   * Used to determine whether the same socket connection that was open
   * when an async operation started is the same one that's active when
   * its continuation fires.
   *
   */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /** @internal */
  /**
   * Special case.
   * After a signature is processed, RPCs automatically dispose of the
   * subscription on the server side. We need to track which of these
   * subscriptions have been disposed in such a way, so that we know
   * whether the client is dealing with a not-yet-processed signature
   * (in which case we must tear down the server subscription) or an
   * already-processed signature (in which case the client can simply
   * clear out the subscription locally without telling the server).
   *
   * NOTE: There is a proposal to eliminate this special case, here:
   * https://github.com/solana-labs/solana/issues/18892
   */
  /** @internal */
  /**
   * Establish a JSON RPC connection
   *
   * @param endpoint URL to the fullnode JSON RPC endpoint
   * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object
   */
  constructor(endpoint2, _commitmentOrConfig) {
    this._commitment = void 0;
    this._confirmTransactionInitialTimeout = void 0;
    this._rpcEndpoint = void 0;
    this._rpcWsEndpoint = void 0;
    this._rpcClient = void 0;
    this._rpcRequest = void 0;
    this._rpcBatchRequest = void 0;
    this._rpcWebSocket = void 0;
    this._rpcWebSocketConnected = false;
    this._rpcWebSocketHeartbeat = null;
    this._rpcWebSocketIdleTimeout = null;
    this._rpcWebSocketGeneration = 0;
    this._disableBlockhashCaching = false;
    this._pollingBlockhash = false;
    this._blockhashInfo = {
      latestBlockhash: null,
      lastFetch: 0,
      transactionSignatures: [],
      simulatedSignatures: []
    };
    this._nextClientSubscriptionId = 0;
    this._subscriptionDisposeFunctionsByClientSubscriptionId = {};
    this._subscriptionHashByClientSubscriptionId = {};
    this._subscriptionStateChangeCallbacksByHash = {};
    this._subscriptionCallbacksByServerSubscriptionId = {};
    this._subscriptionsByHash = {};
    this._subscriptionsAutoDisposedByRpc = /* @__PURE__ */ new Set();
    this.getBlockHeight = (() => {
      const requestPromises = {};
      return (commitmentOrConfig) => __async(this, null, function* () {
        var _a;
        const {
          commitment,
          config
        } = extractCommitmentFromConfig(commitmentOrConfig);
        const args2 = this._buildArgs([], commitment, void 0, config);
        const requestHash = fastStableStringify$1(args2);
        requestPromises[requestHash] = (_a = requestPromises[requestHash]) != null ? _a : (() => __async(this, null, function* () {
          try {
            const unsafeRes = yield this._rpcRequest("getBlockHeight", args2);
            const res = create(unsafeRes, jsonRpcResult(number2()));
            if ("error" in res) {
              throw new SolanaJSONRPCError(res.error, "failed to get block height information");
            }
            return res.result;
          } finally {
            delete requestPromises[requestHash];
          }
        }))();
        return yield requestPromises[requestHash];
      });
    })();
    let wsEndpoint;
    let httpHeaders;
    let fetch2;
    let fetchMiddleware;
    let disableRetryOnRateLimit;
    let httpAgent;
    if (_commitmentOrConfig && typeof _commitmentOrConfig === "string") {
      this._commitment = _commitmentOrConfig;
    } else if (_commitmentOrConfig) {
      this._commitment = _commitmentOrConfig.commitment;
      this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;
      wsEndpoint = _commitmentOrConfig.wsEndpoint;
      httpHeaders = _commitmentOrConfig.httpHeaders;
      fetch2 = _commitmentOrConfig.fetch;
      fetchMiddleware = _commitmentOrConfig.fetchMiddleware;
      disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;
      httpAgent = _commitmentOrConfig.httpAgent;
    }
    this._rpcEndpoint = assertEndpointUrl(endpoint2);
    this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint2);
    this._rpcClient = createRpcClient(endpoint2, httpHeaders, fetch2, fetchMiddleware, disableRetryOnRateLimit, httpAgent);
    this._rpcRequest = createRpcRequest(this._rpcClient);
    this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);
    this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {
      autoconnect: false,
      max_reconnects: Infinity
    });
    this._rpcWebSocket.on("open", this._wsOnOpen.bind(this));
    this._rpcWebSocket.on("error", this._wsOnError.bind(this));
    this._rpcWebSocket.on("close", this._wsOnClose.bind(this));
    this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this));
    this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this));
    this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this));
    this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this));
    this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this));
    this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this));
    this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this));
  }
  /**
   * The default commitment used for requests
   */
  get commitment() {
    return this._commitment;
  }
  /**
   * The RPC endpoint
   */
  get rpcEndpoint() {
    return this._rpcEndpoint;
  }
  /**
   * Fetch the balance for the specified public key, return with context
   */
  getBalanceAndContext(publicKey3, commitmentOrConfig) {
    return __async(this, null, function* () {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args2 = this._buildArgs([publicKey3.toBase58()], commitment, void 0, config);
      const unsafeRes = yield this._rpcRequest("getBalance", args2);
      const res = create(unsafeRes, jsonRpcResultAndContext(number2()));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get balance for ${publicKey3.toBase58()}`);
      }
      return res.result;
    });
  }
  /**
   * Fetch the balance for the specified public key
   */
  getBalance(publicKey3, commitmentOrConfig) {
    return __async(this, null, function* () {
      return yield this.getBalanceAndContext(publicKey3, commitmentOrConfig).then((x) => x.value).catch((e) => {
        throw new Error("failed to get balance of account " + publicKey3.toBase58() + ": " + e);
      });
    });
  }
  /**
   * Fetch the estimated production time of a block
   */
  getBlockTime(slot) {
    return __async(this, null, function* () {
      const unsafeRes = yield this._rpcRequest("getBlockTime", [slot]);
      const res = create(unsafeRes, jsonRpcResult(nullable(number2())));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get block time for slot ${slot}`);
      }
      return res.result;
    });
  }
  /**
   * Fetch the lowest slot that the node has information about in its ledger.
   * This value may increase over time if the node is configured to purge older ledger data
   */
  getMinimumLedgerSlot() {
    return __async(this, null, function* () {
      const unsafeRes = yield this._rpcRequest("minimumLedgerSlot", []);
      const res = create(unsafeRes, jsonRpcResult(number2()));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get minimum ledger slot");
      }
      return res.result;
    });
  }
  /**
   * Fetch the slot of the lowest confirmed block that has not been purged from the ledger
   */
  getFirstAvailableBlock() {
    return __async(this, null, function* () {
      const unsafeRes = yield this._rpcRequest("getFirstAvailableBlock", []);
      const res = create(unsafeRes, SlotRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get first available block");
      }
      return res.result;
    });
  }
  /**
   * Fetch information about the current supply
   */
  getSupply(config) {
    return __async(this, null, function* () {
      let configArg = {};
      if (typeof config === "string") {
        configArg = {
          commitment: config
        };
      } else if (config) {
        configArg = __spreadProps(__spreadValues({}, config), {
          commitment: config && config.commitment || this.commitment
        });
      } else {
        configArg = {
          commitment: this.commitment
        };
      }
      const unsafeRes = yield this._rpcRequest("getSupply", [configArg]);
      const res = create(unsafeRes, GetSupplyRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get supply");
      }
      return res.result;
    });
  }
  /**
   * Fetch the current supply of a token mint
   */
  getTokenSupply(tokenMintAddress, commitment) {
    return __async(this, null, function* () {
      const args2 = this._buildArgs([tokenMintAddress.toBase58()], commitment);
      const unsafeRes = yield this._rpcRequest("getTokenSupply", args2);
      const res = create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get token supply");
      }
      return res.result;
    });
  }
  /**
   * Fetch the current balance of a token account
   */
  getTokenAccountBalance(tokenAddress, commitment) {
    return __async(this, null, function* () {
      const args2 = this._buildArgs([tokenAddress.toBase58()], commitment);
      const unsafeRes = yield this._rpcRequest("getTokenAccountBalance", args2);
      const res = create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get token account balance");
      }
      return res.result;
    });
  }
  /**
   * Fetch all the token accounts owned by the specified account
   *
   * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>>}
   */
  getTokenAccountsByOwner(ownerAddress, filter, commitmentOrConfig) {
    return __async(this, null, function* () {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      let _args = [ownerAddress.toBase58()];
      if ("mint" in filter) {
        _args.push({
          mint: filter.mint.toBase58()
        });
      } else {
        _args.push({
          programId: filter.programId.toBase58()
        });
      }
      const args2 = this._buildArgs(_args, commitment, "base64", config);
      const unsafeRes = yield this._rpcRequest("getTokenAccountsByOwner", args2);
      const res = create(unsafeRes, GetTokenAccountsByOwner);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
      }
      return res.result;
    });
  }
  /**
   * Fetch parsed token accounts owned by the specified account
   *
   * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}
   */
  getParsedTokenAccountsByOwner(ownerAddress, filter, commitment) {
    return __async(this, null, function* () {
      let _args = [ownerAddress.toBase58()];
      if ("mint" in filter) {
        _args.push({
          mint: filter.mint.toBase58()
        });
      } else {
        _args.push({
          programId: filter.programId.toBase58()
        });
      }
      const args2 = this._buildArgs(_args, commitment, "jsonParsed");
      const unsafeRes = yield this._rpcRequest("getTokenAccountsByOwner", args2);
      const res = create(unsafeRes, GetParsedTokenAccountsByOwner);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);
      }
      return res.result;
    });
  }
  /**
   * Fetch the 20 largest accounts with their current balances
   */
  getLargestAccounts(config) {
    return __async(this, null, function* () {
      const arg = __spreadProps(__spreadValues({}, config), {
        commitment: config && config.commitment || this.commitment
      });
      const args2 = arg.filter || arg.commitment ? [arg] : [];
      const unsafeRes = yield this._rpcRequest("getLargestAccounts", args2);
      const res = create(unsafeRes, GetLargestAccountsRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get largest accounts");
      }
      return res.result;
    });
  }
  /**
   * Fetch the 20 largest token accounts with their current balances
   * for a given mint.
   */
  getTokenLargestAccounts(mintAddress, commitment) {
    return __async(this, null, function* () {
      const args2 = this._buildArgs([mintAddress.toBase58()], commitment);
      const unsafeRes = yield this._rpcRequest("getTokenLargestAccounts", args2);
      const res = create(unsafeRes, GetTokenLargestAccountsResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get token largest accounts");
      }
      return res.result;
    });
  }
  /**
   * Fetch all the account info for the specified public key, return with context
   */
  getAccountInfoAndContext(publicKey3, commitmentOrConfig) {
    return __async(this, null, function* () {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args2 = this._buildArgs([publicKey3.toBase58()], commitment, "base64", config);
      const unsafeRes = yield this._rpcRequest("getAccountInfo", args2);
      const res = create(unsafeRes, jsonRpcResultAndContext(nullable(AccountInfoResult)));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey3.toBase58()}`);
      }
      return res.result;
    });
  }
  /**
   * Fetch parsed account info for the specified public key
   */
  getParsedAccountInfo(publicKey3, commitmentOrConfig) {
    return __async(this, null, function* () {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args2 = this._buildArgs([publicKey3.toBase58()], commitment, "jsonParsed", config);
      const unsafeRes = yield this._rpcRequest("getAccountInfo", args2);
      const res = create(unsafeRes, jsonRpcResultAndContext(nullable(ParsedAccountInfoResult)));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey3.toBase58()}`);
      }
      return res.result;
    });
  }
  /**
   * Fetch all the account info for the specified public key
   */
  getAccountInfo(publicKey3, commitmentOrConfig) {
    return __async(this, null, function* () {
      try {
        const res = yield this.getAccountInfoAndContext(publicKey3, commitmentOrConfig);
        return res.value;
      } catch (e) {
        throw new Error("failed to get info about account " + publicKey3.toBase58() + ": " + e);
      }
    });
  }
  /**
   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
   */
  getMultipleParsedAccounts(publicKeys, rawConfig) {
    return __async(this, null, function* () {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(rawConfig);
      const keys = publicKeys.map((key) => key.toBase58());
      const args2 = this._buildArgs([keys], commitment, "jsonParsed", config);
      const unsafeRes = yield this._rpcRequest("getMultipleAccounts", args2);
      const res = create(unsafeRes, jsonRpcResultAndContext(array(nullable(ParsedAccountInfoResult))));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);
      }
      return res.result;
    });
  }
  /**
   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
   */
  getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig) {
    return __async(this, null, function* () {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const keys = publicKeys.map((key) => key.toBase58());
      const args2 = this._buildArgs([keys], commitment, "base64", config);
      const unsafeRes = yield this._rpcRequest("getMultipleAccounts", args2);
      const res = create(unsafeRes, jsonRpcResultAndContext(array(nullable(AccountInfoResult))));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);
      }
      return res.result;
    });
  }
  /**
   * Fetch all the account info for multiple accounts specified by an array of public keys
   */
  getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {
    return __async(this, null, function* () {
      const res = yield this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);
      return res.value;
    });
  }
  /**
   * Returns epoch activation information for a stake account that has been delegated
   */
  getStakeActivation(publicKey3, commitmentOrConfig, epoch) {
    return __async(this, null, function* () {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args2 = this._buildArgs([publicKey3.toBase58()], commitment, void 0, __spreadProps(__spreadValues({}, config), {
        epoch: epoch != null ? epoch : config == null ? void 0 : config.epoch
      }));
      const unsafeRes = yield this._rpcRequest("getStakeActivation", args2);
      const res = create(unsafeRes, jsonRpcResult(StakeActivationResult));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get Stake Activation ${publicKey3.toBase58()}`);
      }
      return res.result;
    });
  }
  /**
   * Fetch all the accounts owned by the specified program id
   *
   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}
   */
  getProgramAccounts(programId, configOrCommitment) {
    return __async(this, null, function* () {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(configOrCommitment);
      const _a = config || {}, {
        encoding
      } = _a, configWithoutEncoding = __objRest(_a, [
        "encoding"
      ]);
      const args2 = this._buildArgs([programId.toBase58()], commitment, encoding || "base64", configWithoutEncoding);
      const unsafeRes = yield this._rpcRequest("getProgramAccounts", args2);
      const res = create(unsafeRes, jsonRpcResult(array(KeyedAccountInfoResult)));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
      }
      return res.result;
    });
  }
  /**
   * Fetch and parse all the accounts owned by the specified program id
   *
   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}
   */
  getParsedProgramAccounts(programId, configOrCommitment) {
    return __async(this, null, function* () {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(configOrCommitment);
      const args2 = this._buildArgs([programId.toBase58()], commitment, "jsonParsed", config);
      const unsafeRes = yield this._rpcRequest("getProgramAccounts", args2);
      const res = create(unsafeRes, jsonRpcResult(array(KeyedParsedAccountInfoResult)));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);
      }
      return res.result;
    });
  }
  // eslint-disable-next-line no-dupe-class-members
  confirmTransaction(strategy, commitment) {
    return __async(this, null, function* () {
      var _a;
      let rawSignature;
      if (typeof strategy == "string") {
        rawSignature = strategy;
      } else {
        const config = strategy;
        if ((_a = config.abortSignal) == null ? void 0 : _a.aborted) {
          return Promise.reject(config.abortSignal.reason);
        }
        rawSignature = config.signature;
      }
      let decodedSignature;
      try {
        decodedSignature = import_bs58.default.decode(rawSignature);
      } catch (err) {
        throw new Error("signature must be base58 encoded: " + rawSignature);
      }
      assert3(decodedSignature.length === 64, "signature has invalid length");
      if (typeof strategy === "string") {
        return yield this.confirmTransactionUsingLegacyTimeoutStrategy({
          commitment: commitment || this.commitment,
          signature: rawSignature
        });
      } else if ("lastValidBlockHeight" in strategy) {
        return yield this.confirmTransactionUsingBlockHeightExceedanceStrategy({
          commitment: commitment || this.commitment,
          strategy
        });
      } else {
        return yield this.confirmTransactionUsingDurableNonceStrategy({
          commitment: commitment || this.commitment,
          strategy
        });
      }
    });
  }
  getCancellationPromise(signal) {
    return new Promise((_, reject) => {
      if (signal == null) {
        return;
      }
      if (signal.aborted) {
        reject(signal.reason);
      } else {
        signal.addEventListener("abort", () => {
          reject(signal.reason);
        });
      }
    });
  }
  getTransactionConfirmationPromise({
    commitment,
    signature: signature2
  }) {
    let signatureSubscriptionId;
    let disposeSignatureSubscriptionStateChangeObserver;
    let done = false;
    const confirmationPromise = new Promise((resolve, reject) => {
      try {
        signatureSubscriptionId = this.onSignature(signature2, (result, context) => {
          signatureSubscriptionId = void 0;
          const response = {
            context,
            value: result
          };
          resolve({
            __type: TransactionStatus.PROCESSED,
            response
          });
        }, commitment);
        const subscriptionSetupPromise = new Promise((resolveSubscriptionSetup) => {
          if (signatureSubscriptionId == null) {
            resolveSubscriptionSetup();
          } else {
            disposeSignatureSubscriptionStateChangeObserver = this._onSubscriptionStateChange(signatureSubscriptionId, (nextState) => {
              if (nextState === "subscribed") {
                resolveSubscriptionSetup();
              }
            });
          }
        });
        (() => __async(this, null, function* () {
          yield subscriptionSetupPromise;
          if (done)
            return;
          const response = yield this.getSignatureStatus(signature2);
          if (done)
            return;
          if (response == null) {
            return;
          }
          const {
            context,
            value
          } = response;
          if (value == null) {
            return;
          }
          if (value == null ? void 0 : value.err) {
            reject(value.err);
          } else {
            switch (commitment) {
              case "confirmed":
              case "single":
              case "singleGossip": {
                if (value.confirmationStatus === "processed") {
                  return;
                }
                break;
              }
              case "finalized":
              case "max":
              case "root": {
                if (value.confirmationStatus === "processed" || value.confirmationStatus === "confirmed") {
                  return;
                }
                break;
              }
              case "processed":
              case "recent":
            }
            done = true;
            resolve({
              __type: TransactionStatus.PROCESSED,
              response: {
                context,
                value
              }
            });
          }
        }))();
      } catch (err) {
        reject(err);
      }
    });
    const abortConfirmation = () => {
      if (disposeSignatureSubscriptionStateChangeObserver) {
        disposeSignatureSubscriptionStateChangeObserver();
        disposeSignatureSubscriptionStateChangeObserver = void 0;
      }
      if (signatureSubscriptionId != null) {
        this.removeSignatureListener(signatureSubscriptionId);
        signatureSubscriptionId = void 0;
      }
    };
    return {
      abortConfirmation,
      confirmationPromise
    };
  }
  confirmTransactionUsingBlockHeightExceedanceStrategy(_0) {
    return __async(this, arguments, function* ({
      commitment,
      strategy: {
        abortSignal,
        lastValidBlockHeight,
        signature: signature2
      }
    }) {
      let done = false;
      const expiryPromise = new Promise((resolve) => {
        const checkBlockHeight = () => __async(this, null, function* () {
          try {
            const blockHeight = yield this.getBlockHeight(commitment);
            return blockHeight;
          } catch (_e) {
            return -1;
          }
        });
        (() => __async(this, null, function* () {
          let currentBlockHeight = yield checkBlockHeight();
          if (done)
            return;
          while (currentBlockHeight <= lastValidBlockHeight) {
            yield sleep(1e3);
            if (done)
              return;
            currentBlockHeight = yield checkBlockHeight();
            if (done)
              return;
          }
          resolve({
            __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED
          });
        }))();
      });
      const {
        abortConfirmation,
        confirmationPromise
      } = this.getTransactionConfirmationPromise({
        commitment,
        signature: signature2
      });
      const cancellationPromise = this.getCancellationPromise(abortSignal);
      let result;
      try {
        const outcome = yield Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
        if (outcome.__type === TransactionStatus.PROCESSED) {
          result = outcome.response;
        } else {
          throw new TransactionExpiredBlockheightExceededError(signature2);
        }
      } finally {
        done = true;
        abortConfirmation();
      }
      return result;
    });
  }
  confirmTransactionUsingDurableNonceStrategy(_0) {
    return __async(this, arguments, function* ({
      commitment,
      strategy: {
        abortSignal,
        minContextSlot,
        nonceAccountPubkey,
        nonceValue,
        signature: signature2
      }
    }) {
      var _a;
      let done = false;
      const expiryPromise = new Promise((resolve) => {
        let currentNonceValue = nonceValue;
        let lastCheckedSlot = null;
        const getCurrentNonceValue = () => __async(this, null, function* () {
          try {
            const {
              context,
              value: nonceAccount
            } = yield this.getNonceAndContext(nonceAccountPubkey, {
              commitment,
              minContextSlot
            });
            lastCheckedSlot = context.slot;
            return nonceAccount == null ? void 0 : nonceAccount.nonce;
          } catch (e) {
            return currentNonceValue;
          }
        });
        (() => __async(this, null, function* () {
          currentNonceValue = yield getCurrentNonceValue();
          if (done)
            return;
          while (true) {
            if (nonceValue !== currentNonceValue) {
              resolve({
                __type: TransactionStatus.NONCE_INVALID,
                slotInWhichNonceDidAdvance: lastCheckedSlot
              });
              return;
            }
            yield sleep(2e3);
            if (done)
              return;
            currentNonceValue = yield getCurrentNonceValue();
            if (done)
              return;
          }
        }))();
      });
      const {
        abortConfirmation,
        confirmationPromise
      } = this.getTransactionConfirmationPromise({
        commitment,
        signature: signature2
      });
      const cancellationPromise = this.getCancellationPromise(abortSignal);
      let result;
      try {
        const outcome = yield Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);
        if (outcome.__type === TransactionStatus.PROCESSED) {
          result = outcome.response;
        } else {
          let signatureStatus;
          while (true) {
            const status = yield this.getSignatureStatus(signature2);
            if (status == null) {
              break;
            }
            if (status.context.slot < ((_a = outcome.slotInWhichNonceDidAdvance) != null ? _a : minContextSlot)) {
              yield sleep(400);
              continue;
            }
            signatureStatus = status;
            break;
          }
          if (signatureStatus == null ? void 0 : signatureStatus.value) {
            const commitmentForStatus = commitment || "finalized";
            const {
              confirmationStatus
            } = signatureStatus.value;
            switch (commitmentForStatus) {
              case "processed":
              case "recent":
                if (confirmationStatus !== "processed" && confirmationStatus !== "confirmed" && confirmationStatus !== "finalized") {
                  throw new TransactionExpiredNonceInvalidError(signature2);
                }
                break;
              case "confirmed":
              case "single":
              case "singleGossip":
                if (confirmationStatus !== "confirmed" && confirmationStatus !== "finalized") {
                  throw new TransactionExpiredNonceInvalidError(signature2);
                }
                break;
              case "finalized":
              case "max":
              case "root":
                if (confirmationStatus !== "finalized") {
                  throw new TransactionExpiredNonceInvalidError(signature2);
                }
                break;
              default:
                ((_) => {
                })(commitmentForStatus);
            }
            result = {
              context: signatureStatus.context,
              value: {
                err: signatureStatus.value.err
              }
            };
          } else {
            throw new TransactionExpiredNonceInvalidError(signature2);
          }
        }
      } finally {
        done = true;
        abortConfirmation();
      }
      return result;
    });
  }
  confirmTransactionUsingLegacyTimeoutStrategy(_0) {
    return __async(this, arguments, function* ({
      commitment,
      signature: signature2
    }) {
      let timeoutId;
      const expiryPromise = new Promise((resolve) => {
        let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1e3;
        switch (commitment) {
          case "processed":
          case "recent":
          case "single":
          case "confirmed":
          case "singleGossip": {
            timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1e3;
            break;
          }
        }
        timeoutId = setTimeout(() => resolve({
          __type: TransactionStatus.TIMED_OUT,
          timeoutMs
        }), timeoutMs);
      });
      const {
        abortConfirmation,
        confirmationPromise
      } = this.getTransactionConfirmationPromise({
        commitment,
        signature: signature2
      });
      let result;
      try {
        const outcome = yield Promise.race([confirmationPromise, expiryPromise]);
        if (outcome.__type === TransactionStatus.PROCESSED) {
          result = outcome.response;
        } else {
          throw new TransactionExpiredTimeoutError(signature2, outcome.timeoutMs / 1e3);
        }
      } finally {
        clearTimeout(timeoutId);
        abortConfirmation();
      }
      return result;
    });
  }
  /**
   * Return the list of nodes that are currently participating in the cluster
   */
  getClusterNodes() {
    return __async(this, null, function* () {
      const unsafeRes = yield this._rpcRequest("getClusterNodes", []);
      const res = create(unsafeRes, jsonRpcResult(array(ContactInfoResult)));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get cluster nodes");
      }
      return res.result;
    });
  }
  /**
   * Return the list of nodes that are currently participating in the cluster
   */
  getVoteAccounts(commitment) {
    return __async(this, null, function* () {
      const args2 = this._buildArgs([], commitment);
      const unsafeRes = yield this._rpcRequest("getVoteAccounts", args2);
      const res = create(unsafeRes, GetVoteAccounts);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get vote accounts");
      }
      return res.result;
    });
  }
  /**
   * Fetch the current slot that the node is processing
   */
  getSlot(commitmentOrConfig) {
    return __async(this, null, function* () {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args2 = this._buildArgs([], commitment, void 0, config);
      const unsafeRes = yield this._rpcRequest("getSlot", args2);
      const res = create(unsafeRes, jsonRpcResult(number2()));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get slot");
      }
      return res.result;
    });
  }
  /**
   * Fetch the current slot leader of the cluster
   */
  getSlotLeader(commitmentOrConfig) {
    return __async(this, null, function* () {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args2 = this._buildArgs([], commitment, void 0, config);
      const unsafeRes = yield this._rpcRequest("getSlotLeader", args2);
      const res = create(unsafeRes, jsonRpcResult(string()));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get slot leader");
      }
      return res.result;
    });
  }
  /**
   * Fetch `limit` number of slot leaders starting from `startSlot`
   *
   * @param startSlot fetch slot leaders starting from this slot
   * @param limit number of slot leaders to return
   */
  getSlotLeaders(startSlot, limit) {
    return __async(this, null, function* () {
      const args2 = [startSlot, limit];
      const unsafeRes = yield this._rpcRequest("getSlotLeaders", args2);
      const res = create(unsafeRes, jsonRpcResult(array(PublicKeyFromString)));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get slot leaders");
      }
      return res.result;
    });
  }
  /**
   * Fetch the current status of a signature
   */
  getSignatureStatus(signature2, config) {
    return __async(this, null, function* () {
      const {
        context,
        value: values
      } = yield this.getSignatureStatuses([signature2], config);
      assert3(values.length === 1);
      const value = values[0];
      return {
        context,
        value
      };
    });
  }
  /**
   * Fetch the current statuses of a batch of signatures
   */
  getSignatureStatuses(signatures, config) {
    return __async(this, null, function* () {
      const params = [signatures];
      if (config) {
        params.push(config);
      }
      const unsafeRes = yield this._rpcRequest("getSignatureStatuses", params);
      const res = create(unsafeRes, GetSignatureStatusesRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get signature status");
      }
      return res.result;
    });
  }
  /**
   * Fetch the current transaction count of the cluster
   */
  getTransactionCount(commitmentOrConfig) {
    return __async(this, null, function* () {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args2 = this._buildArgs([], commitment, void 0, config);
      const unsafeRes = yield this._rpcRequest("getTransactionCount", args2);
      const res = create(unsafeRes, jsonRpcResult(number2()));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get transaction count");
      }
      return res.result;
    });
  }
  /**
   * Fetch the current total currency supply of the cluster in lamports
   *
   * @deprecated Deprecated since v1.2.8. Please use {@link getSupply} instead.
   */
  getTotalSupply(commitment) {
    return __async(this, null, function* () {
      const result = yield this.getSupply({
        commitment,
        excludeNonCirculatingAccountsList: true
      });
      return result.value.total;
    });
  }
  /**
   * Fetch the cluster InflationGovernor parameters
   */
  getInflationGovernor(commitment) {
    return __async(this, null, function* () {
      const args2 = this._buildArgs([], commitment);
      const unsafeRes = yield this._rpcRequest("getInflationGovernor", args2);
      const res = create(unsafeRes, GetInflationGovernorRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get inflation");
      }
      return res.result;
    });
  }
  /**
   * Fetch the inflation reward for a list of addresses for an epoch
   */
  getInflationReward(addresses, epoch, commitmentOrConfig) {
    return __async(this, null, function* () {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args2 = this._buildArgs([addresses.map((pubkey) => pubkey.toBase58())], commitment, void 0, __spreadProps(__spreadValues({}, config), {
        epoch: epoch != null ? epoch : config == null ? void 0 : config.epoch
      }));
      const unsafeRes = yield this._rpcRequest("getInflationReward", args2);
      const res = create(unsafeRes, GetInflationRewardResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get inflation reward");
      }
      return res.result;
    });
  }
  /**
   * Fetch the specific inflation values for the current epoch
   */
  getInflationRate() {
    return __async(this, null, function* () {
      const unsafeRes = yield this._rpcRequest("getInflationRate", []);
      const res = create(unsafeRes, GetInflationRateRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get inflation rate");
      }
      return res.result;
    });
  }
  /**
   * Fetch the Epoch Info parameters
   */
  getEpochInfo(commitmentOrConfig) {
    return __async(this, null, function* () {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args2 = this._buildArgs([], commitment, void 0, config);
      const unsafeRes = yield this._rpcRequest("getEpochInfo", args2);
      const res = create(unsafeRes, GetEpochInfoRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get epoch info");
      }
      return res.result;
    });
  }
  /**
   * Fetch the Epoch Schedule parameters
   */
  getEpochSchedule() {
    return __async(this, null, function* () {
      const unsafeRes = yield this._rpcRequest("getEpochSchedule", []);
      const res = create(unsafeRes, GetEpochScheduleRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get epoch schedule");
      }
      const epochSchedule = res.result;
      return new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);
    });
  }
  /**
   * Fetch the leader schedule for the current epoch
   * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}
   */
  getLeaderSchedule() {
    return __async(this, null, function* () {
      const unsafeRes = yield this._rpcRequest("getLeaderSchedule", []);
      const res = create(unsafeRes, GetLeaderScheduleRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get leader schedule");
      }
      return res.result;
    });
  }
  /**
   * Fetch the minimum balance needed to exempt an account of `dataLength`
   * size from rent
   */
  getMinimumBalanceForRentExemption(dataLength, commitment) {
    return __async(this, null, function* () {
      const args2 = this._buildArgs([dataLength], commitment);
      const unsafeRes = yield this._rpcRequest("getMinimumBalanceForRentExemption", args2);
      const res = create(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);
      if ("error" in res) {
        console.warn("Unable to fetch minimum balance for rent exemption");
        return 0;
      }
      return res.result;
    });
  }
  /**
   * Fetch a recent blockhash from the cluster, return with context
   * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.
   */
  getRecentBlockhashAndContext(commitment) {
    return __async(this, null, function* () {
      const args2 = this._buildArgs([], commitment);
      const unsafeRes = yield this._rpcRequest("getRecentBlockhash", args2);
      const res = create(unsafeRes, GetRecentBlockhashAndContextRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get recent blockhash");
      }
      return res.result;
    });
  }
  /**
   * Fetch recent performance samples
   * @return {Promise<Array<PerfSample>>}
   */
  getRecentPerformanceSamples(limit) {
    return __async(this, null, function* () {
      const unsafeRes = yield this._rpcRequest("getRecentPerformanceSamples", limit ? [limit] : []);
      const res = create(unsafeRes, GetRecentPerformanceSamplesRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get recent performance samples");
      }
      return res.result;
    });
  }
  /**
   * Fetch the fee calculator for a recent blockhash from the cluster, return with context
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getFeeForMessage} instead.
   */
  getFeeCalculatorForBlockhash(blockhash, commitment) {
    return __async(this, null, function* () {
      const args2 = this._buildArgs([blockhash], commitment);
      const unsafeRes = yield this._rpcRequest("getFeeCalculatorForBlockhash", args2);
      const res = create(unsafeRes, GetFeeCalculatorRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get fee calculator");
      }
      const {
        context,
        value
      } = res.result;
      return {
        context,
        value: value !== null ? value.feeCalculator : null
      };
    });
  }
  /**
   * Fetch the fee for a message from the cluster, return with context
   */
  getFeeForMessage(message2, commitment) {
    return __async(this, null, function* () {
      const wireMessage = toBuffer(message2.serialize()).toString("base64");
      const args2 = this._buildArgs([wireMessage], commitment);
      const unsafeRes = yield this._rpcRequest("getFeeForMessage", args2);
      const res = create(unsafeRes, jsonRpcResultAndContext(nullable(number2())));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get fee for message");
      }
      if (res.result === null) {
        throw new Error("invalid blockhash");
      }
      return res.result;
    });
  }
  /**
   * Fetch a list of prioritization fees from recent blocks.
   */
  getRecentPrioritizationFees(config) {
    return __async(this, null, function* () {
      var _a;
      const accounts = (_a = config == null ? void 0 : config.lockedWritableAccounts) == null ? void 0 : _a.map((key) => key.toBase58());
      const args2 = this._buildArgs((accounts == null ? void 0 : accounts.length) ? [accounts] : []);
      const unsafeRes = yield this._rpcRequest("getRecentPrioritizationFees", args2);
      const res = create(unsafeRes, GetRecentPrioritizationFeesRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get recent prioritization fees");
      }
      return res.result;
    });
  }
  /**
   * Fetch a recent blockhash from the cluster
   * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.
   */
  getRecentBlockhash(commitment) {
    return __async(this, null, function* () {
      try {
        const res = yield this.getRecentBlockhashAndContext(commitment);
        return res.value;
      } catch (e) {
        throw new Error("failed to get recent blockhash: " + e);
      }
    });
  }
  /**
   * Fetch the latest blockhash from the cluster
   * @return {Promise<BlockhashWithExpiryBlockHeight>}
   */
  getLatestBlockhash(commitmentOrConfig) {
    return __async(this, null, function* () {
      try {
        const res = yield this.getLatestBlockhashAndContext(commitmentOrConfig);
        return res.value;
      } catch (e) {
        throw new Error("failed to get recent blockhash: " + e);
      }
    });
  }
  /**
   * Fetch the latest blockhash from the cluster
   * @return {Promise<BlockhashWithExpiryBlockHeight>}
   */
  getLatestBlockhashAndContext(commitmentOrConfig) {
    return __async(this, null, function* () {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args2 = this._buildArgs([], commitment, void 0, config);
      const unsafeRes = yield this._rpcRequest("getLatestBlockhash", args2);
      const res = create(unsafeRes, GetLatestBlockhashRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get latest blockhash");
      }
      return res.result;
    });
  }
  /**
   * Fetch the node version
   */
  getVersion() {
    return __async(this, null, function* () {
      const unsafeRes = yield this._rpcRequest("getVersion", []);
      const res = create(unsafeRes, jsonRpcResult(VersionResult));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get version");
      }
      return res.result;
    });
  }
  /**
   * Fetch the genesis hash
   */
  getGenesisHash() {
    return __async(this, null, function* () {
      const unsafeRes = yield this._rpcRequest("getGenesisHash", []);
      const res = create(unsafeRes, jsonRpcResult(string()));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get genesis hash");
      }
      return res.result;
    });
  }
  /**
   * Fetch a processed block from the cluster.
   *
   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
   * setting the `maxSupportedTransactionVersion` property.
   */
  /**
   * Fetch a processed block from the cluster.
   */
  // eslint-disable-next-line no-dupe-class-members
  getBlock(slot, rawConfig) {
    return __async(this, null, function* () {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(rawConfig);
      const args2 = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, config);
      const unsafeRes = yield this._rpcRequest("getBlock", args2);
      try {
        switch (config == null ? void 0 : config.transactionDetails) {
          case "accounts": {
            const res = create(unsafeRes, GetAccountsModeBlockRpcResult);
            if ("error" in res) {
              throw res.error;
            }
            return res.result;
          }
          case "none": {
            const res = create(unsafeRes, GetNoneModeBlockRpcResult);
            if ("error" in res) {
              throw res.error;
            }
            return res.result;
          }
          default: {
            const res = create(unsafeRes, GetBlockRpcResult);
            if ("error" in res) {
              throw res.error;
            }
            const {
              result
            } = res;
            return result ? __spreadProps(__spreadValues({}, result), {
              transactions: result.transactions.map(({
                transaction,
                meta,
                version: version2
              }) => ({
                meta,
                transaction: __spreadProps(__spreadValues({}, transaction), {
                  message: versionedMessageFromResponse(version2, transaction.message)
                }),
                version: version2
              }))
            }) : null;
          }
        }
      } catch (e) {
        throw new SolanaJSONRPCError(e, "failed to get confirmed block");
      }
    });
  }
  /**
   * Fetch parsed transaction details for a confirmed or finalized block
   */
  // eslint-disable-next-line no-dupe-class-members
  getParsedBlock(slot, rawConfig) {
    return __async(this, null, function* () {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(rawConfig);
      const args2 = this._buildArgsAtLeastConfirmed([slot], commitment, "jsonParsed", config);
      const unsafeRes = yield this._rpcRequest("getBlock", args2);
      try {
        switch (config == null ? void 0 : config.transactionDetails) {
          case "accounts": {
            const res = create(unsafeRes, GetParsedAccountsModeBlockRpcResult);
            if ("error" in res) {
              throw res.error;
            }
            return res.result;
          }
          case "none": {
            const res = create(unsafeRes, GetParsedNoneModeBlockRpcResult);
            if ("error" in res) {
              throw res.error;
            }
            return res.result;
          }
          default: {
            const res = create(unsafeRes, GetParsedBlockRpcResult);
            if ("error" in res) {
              throw res.error;
            }
            return res.result;
          }
        }
      } catch (e) {
        throw new SolanaJSONRPCError(e, "failed to get block");
      }
    });
  }
  /*
   * Returns the current block height of the node
   */
  /*
   * Returns recent block production information from the current or previous epoch
   */
  getBlockProduction(configOrCommitment) {
    return __async(this, null, function* () {
      let extra;
      let commitment;
      if (typeof configOrCommitment === "string") {
        commitment = configOrCommitment;
      } else if (configOrCommitment) {
        const _a = configOrCommitment, {
          commitment: c
        } = _a, rest = __objRest(_a, [
          "commitment"
        ]);
        commitment = c;
        extra = rest;
      }
      const args2 = this._buildArgs([], commitment, "base64", extra);
      const unsafeRes = yield this._rpcRequest("getBlockProduction", args2);
      const res = create(unsafeRes, BlockProductionResponseStruct);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get block production information");
      }
      return res.result;
    });
  }
  /**
   * Fetch a confirmed or finalized transaction from the cluster.
   *
   * @deprecated Instead, call `getTransaction` using a
   * `GetVersionedTransactionConfig` by setting the
   * `maxSupportedTransactionVersion` property.
   */
  /**
   * Fetch a confirmed or finalized transaction from the cluster.
   */
  // eslint-disable-next-line no-dupe-class-members
  getTransaction(signature2, rawConfig) {
    return __async(this, null, function* () {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(rawConfig);
      const args2 = this._buildArgsAtLeastConfirmed([signature2], commitment, void 0, config);
      const unsafeRes = yield this._rpcRequest("getTransaction", args2);
      const res = create(unsafeRes, GetTransactionRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get transaction");
      }
      const result = res.result;
      if (!result)
        return result;
      return __spreadProps(__spreadValues({}, result), {
        transaction: __spreadProps(__spreadValues({}, result.transaction), {
          message: versionedMessageFromResponse(result.version, result.transaction.message)
        })
      });
    });
  }
  /**
   * Fetch parsed transaction details for a confirmed or finalized transaction
   */
  getParsedTransaction(signature2, commitmentOrConfig) {
    return __async(this, null, function* () {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const args2 = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed", config);
      const unsafeRes = yield this._rpcRequest("getTransaction", args2);
      const res = create(unsafeRes, GetParsedTransactionRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get transaction");
      }
      return res.result;
    });
  }
  /**
   * Fetch parsed transaction details for a batch of confirmed transactions
   */
  getParsedTransactions(signatures, commitmentOrConfig) {
    return __async(this, null, function* () {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const batch = signatures.map((signature2) => {
        const args2 = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed", config);
        return {
          methodName: "getTransaction",
          args: args2
        };
      });
      const unsafeRes = yield this._rpcBatchRequest(batch);
      const res = unsafeRes.map((unsafeRes2) => {
        const res2 = create(unsafeRes2, GetParsedTransactionRpcResult);
        if ("error" in res2) {
          throw new SolanaJSONRPCError(res2.error, "failed to get transactions");
        }
        return res2.result;
      });
      return res;
    });
  }
  /**
   * Fetch transaction details for a batch of confirmed transactions.
   * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.
   *
   * @deprecated Instead, call `getTransactions` using a
   * `GetVersionedTransactionConfig` by setting the
   * `maxSupportedTransactionVersion` property.
   */
  /**
   * Fetch transaction details for a batch of confirmed transactions.
   * Similar to {@link getParsedTransactions} but returns a {@link
   * VersionedTransactionResponse}.
   */
  // eslint-disable-next-line no-dupe-class-members
  getTransactions(signatures, commitmentOrConfig) {
    return __async(this, null, function* () {
      const {
        commitment,
        config
      } = extractCommitmentFromConfig(commitmentOrConfig);
      const batch = signatures.map((signature2) => {
        const args2 = this._buildArgsAtLeastConfirmed([signature2], commitment, void 0, config);
        return {
          methodName: "getTransaction",
          args: args2
        };
      });
      const unsafeRes = yield this._rpcBatchRequest(batch);
      const res = unsafeRes.map((unsafeRes2) => {
        const res2 = create(unsafeRes2, GetTransactionRpcResult);
        if ("error" in res2) {
          throw new SolanaJSONRPCError(res2.error, "failed to get transactions");
        }
        const result = res2.result;
        if (!result)
          return result;
        return __spreadProps(__spreadValues({}, result), {
          transaction: __spreadProps(__spreadValues({}, result.transaction), {
            message: versionedMessageFromResponse(result.version, result.transaction.message)
          })
        });
      });
      return res;
    });
  }
  /**
   * Fetch a list of Transactions and transaction statuses from the cluster
   * for a confirmed block.
   *
   * @deprecated Deprecated since v1.13.0. Please use {@link getBlock} instead.
   */
  getConfirmedBlock(slot, commitment) {
    return __async(this, null, function* () {
      const args2 = this._buildArgsAtLeastConfirmed([slot], commitment);
      const unsafeRes = yield this._rpcRequest("getConfirmedBlock", args2);
      const res = create(unsafeRes, GetConfirmedBlockRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get confirmed block");
      }
      const result = res.result;
      if (!result) {
        throw new Error("Confirmed block " + slot + " not found");
      }
      const block = __spreadProps(__spreadValues({}, result), {
        transactions: result.transactions.map(({
          transaction,
          meta
        }) => {
          const message2 = new Message(transaction.message);
          return {
            meta,
            transaction: __spreadProps(__spreadValues({}, transaction), {
              message: message2
            })
          };
        })
      });
      return __spreadProps(__spreadValues({}, block), {
        transactions: block.transactions.map(({
          transaction,
          meta
        }) => {
          return {
            meta,
            transaction: Transaction.populate(transaction.message, transaction.signatures)
          };
        })
      });
    });
  }
  /**
   * Fetch confirmed blocks between two slots
   */
  getBlocks(startSlot, endSlot, commitment) {
    return __async(this, null, function* () {
      const args2 = this._buildArgsAtLeastConfirmed(endSlot !== void 0 ? [startSlot, endSlot] : [startSlot], commitment);
      const unsafeRes = yield this._rpcRequest("getBlocks", args2);
      const res = create(unsafeRes, jsonRpcResult(array(number2())));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get blocks");
      }
      return res.result;
    });
  }
  /**
   * Fetch a list of Signatures from the cluster for a block, excluding rewards
   */
  getBlockSignatures(slot, commitment) {
    return __async(this, null, function* () {
      const args2 = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, {
        transactionDetails: "signatures",
        rewards: false
      });
      const unsafeRes = yield this._rpcRequest("getBlock", args2);
      const res = create(unsafeRes, GetBlockSignaturesRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get block");
      }
      const result = res.result;
      if (!result) {
        throw new Error("Block " + slot + " not found");
      }
      return result;
    });
  }
  /**
   * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getBlockSignatures} instead.
   */
  getConfirmedBlockSignatures(slot, commitment) {
    return __async(this, null, function* () {
      const args2 = this._buildArgsAtLeastConfirmed([slot], commitment, void 0, {
        transactionDetails: "signatures",
        rewards: false
      });
      const unsafeRes = yield this._rpcRequest("getConfirmedBlock", args2);
      const res = create(unsafeRes, GetBlockSignaturesRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get confirmed block");
      }
      const result = res.result;
      if (!result) {
        throw new Error("Confirmed block " + slot + " not found");
      }
      return result;
    });
  }
  /**
   * Fetch a transaction details for a confirmed transaction
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getTransaction} instead.
   */
  getConfirmedTransaction(signature2, commitment) {
    return __async(this, null, function* () {
      const args2 = this._buildArgsAtLeastConfirmed([signature2], commitment);
      const unsafeRes = yield this._rpcRequest("getConfirmedTransaction", args2);
      const res = create(unsafeRes, GetTransactionRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get transaction");
      }
      const result = res.result;
      if (!result)
        return result;
      const message2 = new Message(result.transaction.message);
      const signatures = result.transaction.signatures;
      return __spreadProps(__spreadValues({}, result), {
        transaction: Transaction.populate(message2, signatures)
      });
    });
  }
  /**
   * Fetch parsed transaction details for a confirmed transaction
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransaction} instead.
   */
  getParsedConfirmedTransaction(signature2, commitment) {
    return __async(this, null, function* () {
      const args2 = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed");
      const unsafeRes = yield this._rpcRequest("getConfirmedTransaction", args2);
      const res = create(unsafeRes, GetParsedTransactionRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get confirmed transaction");
      }
      return res.result;
    });
  }
  /**
   * Fetch parsed transaction details for a batch of confirmed transactions
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransactions} instead.
   */
  getParsedConfirmedTransactions(signatures, commitment) {
    return __async(this, null, function* () {
      const batch = signatures.map((signature2) => {
        const args2 = this._buildArgsAtLeastConfirmed([signature2], commitment, "jsonParsed");
        return {
          methodName: "getConfirmedTransaction",
          args: args2
        };
      });
      const unsafeRes = yield this._rpcBatchRequest(batch);
      const res = unsafeRes.map((unsafeRes2) => {
        const res2 = create(unsafeRes2, GetParsedTransactionRpcResult);
        if ("error" in res2) {
          throw new SolanaJSONRPCError(res2.error, "failed to get confirmed transactions");
        }
        return res2.result;
      });
      return res;
    });
  }
  /**
   * Fetch a list of all the confirmed signatures for transactions involving an address
   * within a specified slot range. Max range allowed is 10,000 slots.
   *
   * @deprecated Deprecated since v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.
   *
   * @param address queried address
   * @param startSlot start slot, inclusive
   * @param endSlot end slot, inclusive
   */
  getConfirmedSignaturesForAddress(address, startSlot, endSlot) {
    return __async(this, null, function* () {
      let options = {};
      let firstAvailableBlock = yield this.getFirstAvailableBlock();
      while (!("until" in options)) {
        startSlot--;
        if (startSlot <= 0 || startSlot < firstAvailableBlock) {
          break;
        }
        try {
          const block = yield this.getConfirmedBlockSignatures(startSlot, "finalized");
          if (block.signatures.length > 0) {
            options.until = block.signatures[block.signatures.length - 1].toString();
          }
        } catch (err) {
          if (err instanceof Error && err.message.includes("skipped")) {
            continue;
          } else {
            throw err;
          }
        }
      }
      let highestConfirmedRoot = yield this.getSlot("finalized");
      while (!("before" in options)) {
        endSlot++;
        if (endSlot > highestConfirmedRoot) {
          break;
        }
        try {
          const block = yield this.getConfirmedBlockSignatures(endSlot);
          if (block.signatures.length > 0) {
            options.before = block.signatures[block.signatures.length - 1].toString();
          }
        } catch (err) {
          if (err instanceof Error && err.message.includes("skipped")) {
            continue;
          } else {
            throw err;
          }
        }
      }
      const confirmedSignatureInfo = yield this.getConfirmedSignaturesForAddress2(address, options);
      return confirmedSignatureInfo.map((info) => info.signature);
    });
  }
  /**
   * Returns confirmed signatures for transactions involving an
   * address backwards in time from the provided signature or most recent confirmed block
   *
   *
   * @param address queried address
   * @param options
   */
  getConfirmedSignaturesForAddress2(address, options, commitment) {
    return __async(this, null, function* () {
      const args2 = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, void 0, options);
      const unsafeRes = yield this._rpcRequest("getConfirmedSignaturesForAddress2", args2);
      const res = create(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get confirmed signatures for address");
      }
      return res.result;
    });
  }
  /**
   * Returns confirmed signatures for transactions involving an
   * address backwards in time from the provided signature or most recent confirmed block
   *
   *
   * @param address queried address
   * @param options
   */
  getSignaturesForAddress(address, options, commitment) {
    return __async(this, null, function* () {
      const args2 = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, void 0, options);
      const unsafeRes = yield this._rpcRequest("getSignaturesForAddress", args2);
      const res = create(unsafeRes, GetSignaturesForAddressRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, "failed to get signatures for address");
      }
      return res.result;
    });
  }
  getAddressLookupTable(accountKey, config) {
    return __async(this, null, function* () {
      const {
        context,
        value: accountInfo
      } = yield this.getAccountInfoAndContext(accountKey, config);
      let value = null;
      if (accountInfo !== null) {
        value = new AddressLookupTableAccount({
          key: accountKey,
          state: AddressLookupTableAccount.deserialize(accountInfo.data)
        });
      }
      return {
        context,
        value
      };
    });
  }
  /**
   * Fetch the contents of a Nonce account from the cluster, return with context
   */
  getNonceAndContext(nonceAccount, commitmentOrConfig) {
    return __async(this, null, function* () {
      const {
        context,
        value: accountInfo
      } = yield this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);
      let value = null;
      if (accountInfo !== null) {
        value = NonceAccount.fromAccountData(accountInfo.data);
      }
      return {
        context,
        value
      };
    });
  }
  /**
   * Fetch the contents of a Nonce account from the cluster
   */
  getNonce(nonceAccount, commitmentOrConfig) {
    return __async(this, null, function* () {
      return yield this.getNonceAndContext(nonceAccount, commitmentOrConfig).then((x) => x.value).catch((e) => {
        throw new Error("failed to get nonce for account " + nonceAccount.toBase58() + ": " + e);
      });
    });
  }
  /**
   * Request an allocation of lamports to the specified address
   *
   * ```typescript
   * import { Connection, PublicKey, LAMPORTS_PER_SOL } from "@solana/web3.js";
   *
   * (async () => {
   *   const connection = new Connection("https://api.testnet.solana.com", "confirmed");
   *   const myAddress = new PublicKey("2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM");
   *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);
   *   await connection.confirmTransaction(signature);
   * })();
   * ```
   */
  requestAirdrop(to, lamports) {
    return __async(this, null, function* () {
      const unsafeRes = yield this._rpcRequest("requestAirdrop", [to.toBase58(), lamports]);
      const res = create(unsafeRes, RequestAirdropRpcResult);
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `airdrop to ${to.toBase58()} failed`);
      }
      return res.result;
    });
  }
  /**
   * @internal
   */
  _blockhashWithExpiryBlockHeight(disableCache) {
    return __async(this, null, function* () {
      if (!disableCache) {
        while (this._pollingBlockhash) {
          yield sleep(100);
        }
        const timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;
        const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;
        if (this._blockhashInfo.latestBlockhash !== null && !expired) {
          return this._blockhashInfo.latestBlockhash;
        }
      }
      return yield this._pollNewBlockhash();
    });
  }
  /**
   * @internal
   */
  _pollNewBlockhash() {
    return __async(this, null, function* () {
      this._pollingBlockhash = true;
      try {
        const startTime = Date.now();
        const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;
        const cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;
        for (let i = 0; i < 50; i++) {
          const latestBlockhash = yield this.getLatestBlockhash("finalized");
          if (cachedBlockhash !== latestBlockhash.blockhash) {
            this._blockhashInfo = {
              latestBlockhash,
              lastFetch: Date.now(),
              transactionSignatures: [],
              simulatedSignatures: []
            };
            return latestBlockhash;
          }
          yield sleep(MS_PER_SLOT / 2);
        }
        throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime}ms`);
      } finally {
        this._pollingBlockhash = false;
      }
    });
  }
  /**
   * get the stake minimum delegation
   */
  getStakeMinimumDelegation(config) {
    return __async(this, null, function* () {
      const {
        commitment,
        config: configArg
      } = extractCommitmentFromConfig(config);
      const args2 = this._buildArgs([], commitment, "base64", configArg);
      const unsafeRes = yield this._rpcRequest("getStakeMinimumDelegation", args2);
      const res = create(unsafeRes, jsonRpcResultAndContext(number2()));
      if ("error" in res) {
        throw new SolanaJSONRPCError(res.error, `failed to get stake minimum delegation`);
      }
      return res.result;
    });
  }
  /**
   * Simulate a transaction
   *
   * @deprecated Instead, call {@link simulateTransaction} with {@link
   * VersionedTransaction} and {@link SimulateTransactionConfig} parameters
   */
  /**
   * Simulate a transaction
   */
  // eslint-disable-next-line no-dupe-class-members
  simulateTransaction(transactionOrMessage, configOrSigners, includeAccounts) {
    return __async(this, null, function* () {
      if ("message" in transactionOrMessage) {
        const versionedTx = transactionOrMessage;
        const wireTransaction2 = versionedTx.serialize();
        const encodedTransaction2 = Buffer2.from(wireTransaction2).toString("base64");
        if (Array.isArray(configOrSigners) || includeAccounts !== void 0) {
          throw new Error("Invalid arguments");
        }
        const config2 = configOrSigners || {};
        config2.encoding = "base64";
        if (!("commitment" in config2)) {
          config2.commitment = this.commitment;
        }
        const args3 = [encodedTransaction2, config2];
        const unsafeRes2 = yield this._rpcRequest("simulateTransaction", args3);
        const res2 = create(unsafeRes2, SimulatedTransactionResponseStruct);
        if ("error" in res2) {
          throw new Error("failed to simulate transaction: " + res2.error.message);
        }
        return res2.result;
      }
      let transaction;
      if (transactionOrMessage instanceof Transaction) {
        let originalTx = transactionOrMessage;
        transaction = new Transaction();
        transaction.feePayer = originalTx.feePayer;
        transaction.instructions = transactionOrMessage.instructions;
        transaction.nonceInfo = originalTx.nonceInfo;
        transaction.signatures = originalTx.signatures;
      } else {
        transaction = Transaction.populate(transactionOrMessage);
        transaction._message = transaction._json = void 0;
      }
      if (configOrSigners !== void 0 && !Array.isArray(configOrSigners)) {
        throw new Error("Invalid arguments");
      }
      const signers = configOrSigners;
      if (transaction.nonceInfo && signers) {
        transaction.sign(...signers);
      } else {
        let disableCache = this._disableBlockhashCaching;
        for (; ; ) {
          const latestBlockhash = yield this._blockhashWithExpiryBlockHeight(disableCache);
          transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
          transaction.recentBlockhash = latestBlockhash.blockhash;
          if (!signers)
            break;
          transaction.sign(...signers);
          if (!transaction.signature) {
            throw new Error("!signature");
          }
          const signature2 = transaction.signature.toString("base64");
          if (!this._blockhashInfo.simulatedSignatures.includes(signature2) && !this._blockhashInfo.transactionSignatures.includes(signature2)) {
            this._blockhashInfo.simulatedSignatures.push(signature2);
            break;
          } else {
            disableCache = true;
          }
        }
      }
      const message2 = transaction._compile();
      const signData = message2.serialize();
      const wireTransaction = transaction._serialize(signData);
      const encodedTransaction = wireTransaction.toString("base64");
      const config = {
        encoding: "base64",
        commitment: this.commitment
      };
      if (includeAccounts) {
        const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message2.nonProgramIds()).map((key) => key.toBase58());
        config["accounts"] = {
          encoding: "base64",
          addresses
        };
      }
      if (signers) {
        config.sigVerify = true;
      }
      const args2 = [encodedTransaction, config];
      const unsafeRes = yield this._rpcRequest("simulateTransaction", args2);
      const res = create(unsafeRes, SimulatedTransactionResponseStruct);
      if ("error" in res) {
        let logs;
        if ("data" in res.error) {
          logs = res.error.data.logs;
          if (logs && Array.isArray(logs)) {
            const traceIndent = "\n    ";
            const logTrace = traceIndent + logs.join(traceIndent);
            console.error(res.error.message, logTrace);
          }
        }
        throw new SendTransactionError("failed to simulate transaction: " + res.error.message, logs);
      }
      return res.result;
    });
  }
  /**
   * Sign and send a transaction
   *
   * @deprecated Instead, call {@link sendTransaction} with a {@link
   * VersionedTransaction}
   */
  /**
   * Sign and send a transaction
   */
  // eslint-disable-next-line no-dupe-class-members
  sendTransaction(transaction, signersOrOptions, options) {
    return __async(this, null, function* () {
      if ("version" in transaction) {
        if (signersOrOptions && Array.isArray(signersOrOptions)) {
          throw new Error("Invalid arguments");
        }
        const wireTransaction2 = transaction.serialize();
        return yield this.sendRawTransaction(wireTransaction2, signersOrOptions);
      }
      if (signersOrOptions === void 0 || !Array.isArray(signersOrOptions)) {
        throw new Error("Invalid arguments");
      }
      const signers = signersOrOptions;
      if (transaction.nonceInfo) {
        transaction.sign(...signers);
      } else {
        let disableCache = this._disableBlockhashCaching;
        for (; ; ) {
          const latestBlockhash = yield this._blockhashWithExpiryBlockHeight(disableCache);
          transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
          transaction.recentBlockhash = latestBlockhash.blockhash;
          transaction.sign(...signers);
          if (!transaction.signature) {
            throw new Error("!signature");
          }
          const signature2 = transaction.signature.toString("base64");
          if (!this._blockhashInfo.transactionSignatures.includes(signature2)) {
            this._blockhashInfo.transactionSignatures.push(signature2);
            break;
          } else {
            disableCache = true;
          }
        }
      }
      const wireTransaction = transaction.serialize();
      return yield this.sendRawTransaction(wireTransaction, options);
    });
  }
  /**
   * Send a transaction that has already been signed and serialized into the
   * wire format
   */
  sendRawTransaction(rawTransaction, options) {
    return __async(this, null, function* () {
      const encodedTransaction = toBuffer(rawTransaction).toString("base64");
      const result = yield this.sendEncodedTransaction(encodedTransaction, options);
      return result;
    });
  }
  /**
   * Send a transaction that has already been signed, serialized into the
   * wire format, and encoded as a base64 string
   */
  sendEncodedTransaction(encodedTransaction, options) {
    return __async(this, null, function* () {
      const config = {
        encoding: "base64"
      };
      const skipPreflight = options && options.skipPreflight;
      const preflightCommitment = options && options.preflightCommitment || this.commitment;
      if (options && options.maxRetries != null) {
        config.maxRetries = options.maxRetries;
      }
      if (options && options.minContextSlot != null) {
        config.minContextSlot = options.minContextSlot;
      }
      if (skipPreflight) {
        config.skipPreflight = skipPreflight;
      }
      if (preflightCommitment) {
        config.preflightCommitment = preflightCommitment;
      }
      const args2 = [encodedTransaction, config];
      const unsafeRes = yield this._rpcRequest("sendTransaction", args2);
      const res = create(unsafeRes, SendTransactionRpcResult);
      if ("error" in res) {
        let logs;
        if ("data" in res.error) {
          logs = res.error.data.logs;
        }
        throw new SendTransactionError("failed to send transaction: " + res.error.message, logs);
      }
      return res.result;
    });
  }
  /**
   * @internal
   */
  _wsOnOpen() {
    this._rpcWebSocketConnected = true;
    this._rpcWebSocketHeartbeat = setInterval(() => {
      (() => __async(this, null, function* () {
        try {
          yield this._rpcWebSocket.notify("ping");
        } catch (e) {
        }
      }))();
    }, 5e3);
    this._updateSubscriptions();
  }
  /**
   * @internal
   */
  _wsOnError(err) {
    this._rpcWebSocketConnected = false;
    console.error("ws error:", err.message);
  }
  /**
   * @internal
   */
  _wsOnClose(code) {
    this._rpcWebSocketConnected = false;
    this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;
    if (this._rpcWebSocketIdleTimeout) {
      clearTimeout(this._rpcWebSocketIdleTimeout);
      this._rpcWebSocketIdleTimeout = null;
    }
    if (this._rpcWebSocketHeartbeat) {
      clearInterval(this._rpcWebSocketHeartbeat);
      this._rpcWebSocketHeartbeat = null;
    }
    if (code === 1e3) {
      this._updateSubscriptions();
      return;
    }
    this._subscriptionCallbacksByServerSubscriptionId = {};
    Object.entries(this._subscriptionsByHash).forEach(([hash2, subscription]) => {
      this._setSubscription(hash2, __spreadProps(__spreadValues({}, subscription), {
        state: "pending"
      }));
    });
  }
  /**
   * @internal
   */
  _setSubscription(hash2, nextSubscription) {
    var _a;
    const prevState = (_a = this._subscriptionsByHash[hash2]) == null ? void 0 : _a.state;
    this._subscriptionsByHash[hash2] = nextSubscription;
    if (prevState !== nextSubscription.state) {
      const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash2];
      if (stateChangeCallbacks) {
        stateChangeCallbacks.forEach((cb) => {
          try {
            cb(nextSubscription.state);
          } catch (e) {
          }
        });
      }
    }
  }
  /**
   * @internal
   */
  _onSubscriptionStateChange(clientSubscriptionId, callback) {
    var _this$_subscriptionSt;
    const hash2 = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
    if (hash2 == null) {
      return () => {
      };
    }
    const stateChangeCallbacks = (_this$_subscriptionSt = this._subscriptionStateChangeCallbacksByHash)[hash2] || (_this$_subscriptionSt[hash2] = /* @__PURE__ */ new Set());
    stateChangeCallbacks.add(callback);
    return () => {
      stateChangeCallbacks.delete(callback);
      if (stateChangeCallbacks.size === 0) {
        delete this._subscriptionStateChangeCallbacksByHash[hash2];
      }
    };
  }
  /**
   * @internal
   */
  _updateSubscriptions() {
    return __async(this, null, function* () {
      if (Object.keys(this._subscriptionsByHash).length === 0) {
        if (this._rpcWebSocketConnected) {
          this._rpcWebSocketConnected = false;
          this._rpcWebSocketIdleTimeout = setTimeout(() => {
            this._rpcWebSocketIdleTimeout = null;
            try {
              this._rpcWebSocket.close();
            } catch (err) {
              if (err instanceof Error) {
                console.log(`Error when closing socket connection: ${err.message}`);
              }
            }
          }, 500);
        }
        return;
      }
      if (this._rpcWebSocketIdleTimeout !== null) {
        clearTimeout(this._rpcWebSocketIdleTimeout);
        this._rpcWebSocketIdleTimeout = null;
        this._rpcWebSocketConnected = true;
      }
      if (!this._rpcWebSocketConnected) {
        this._rpcWebSocket.connect();
        return;
      }
      const activeWebSocketGeneration = this._rpcWebSocketGeneration;
      const isCurrentConnectionStillActive = () => {
        return activeWebSocketGeneration === this._rpcWebSocketGeneration;
      };
      yield Promise.all(
        // Don't be tempted to change this to `Object.entries`. We call
        // `_updateSubscriptions` recursively when processing the state,
        // so it's important that we look up the *current* version of
        // each subscription, every time we process a hash.
        Object.keys(this._subscriptionsByHash).map((hash2) => __async(this, null, function* () {
          const subscription = this._subscriptionsByHash[hash2];
          if (subscription === void 0) {
            return;
          }
          switch (subscription.state) {
            case "pending":
            case "unsubscribed":
              if (subscription.callbacks.size === 0) {
                delete this._subscriptionsByHash[hash2];
                if (subscription.state === "unsubscribed") {
                  delete this._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];
                }
                yield this._updateSubscriptions();
                return;
              }
              yield (() => __async(this, null, function* () {
                const {
                  args: args2,
                  method
                } = subscription;
                try {
                  this._setSubscription(hash2, __spreadProps(__spreadValues({}, subscription), {
                    state: "subscribing"
                  }));
                  const serverSubscriptionId = yield this._rpcWebSocket.call(method, args2);
                  this._setSubscription(hash2, __spreadProps(__spreadValues({}, subscription), {
                    serverSubscriptionId,
                    state: "subscribed"
                  }));
                  this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;
                  yield this._updateSubscriptions();
                } catch (e) {
                  if (e instanceof Error) {
                    console.error(`${method} error for argument`, args2, e.message);
                  }
                  if (!isCurrentConnectionStillActive()) {
                    return;
                  }
                  this._setSubscription(hash2, __spreadProps(__spreadValues({}, subscription), {
                    state: "pending"
                  }));
                  yield this._updateSubscriptions();
                }
              }))();
              break;
            case "subscribed":
              if (subscription.callbacks.size === 0) {
                yield (() => __async(this, null, function* () {
                  const {
                    serverSubscriptionId,
                    unsubscribeMethod
                  } = subscription;
                  if (this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {
                    this._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);
                  } else {
                    this._setSubscription(hash2, __spreadProps(__spreadValues({}, subscription), {
                      state: "unsubscribing"
                    }));
                    this._setSubscription(hash2, __spreadProps(__spreadValues({}, subscription), {
                      state: "unsubscribing"
                    }));
                    try {
                      yield this._rpcWebSocket.call(unsubscribeMethod, [serverSubscriptionId]);
                    } catch (e) {
                      if (e instanceof Error) {
                        console.error(`${unsubscribeMethod} error:`, e.message);
                      }
                      if (!isCurrentConnectionStillActive()) {
                        return;
                      }
                      this._setSubscription(hash2, __spreadProps(__spreadValues({}, subscription), {
                        state: "subscribed"
                      }));
                      yield this._updateSubscriptions();
                      return;
                    }
                  }
                  this._setSubscription(hash2, __spreadProps(__spreadValues({}, subscription), {
                    state: "unsubscribed"
                  }));
                  yield this._updateSubscriptions();
                }))();
              }
              break;
          }
        }))
      );
    });
  }
  /**
   * @internal
   */
  _handleServerNotification(serverSubscriptionId, callbackArgs) {
    const callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];
    if (callbacks === void 0) {
      return;
    }
    callbacks.forEach((cb) => {
      try {
        cb(
          ...callbackArgs
        );
      } catch (e) {
        console.error(e);
      }
    });
  }
  /**
   * @internal
   */
  _wsOnAccountNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, AccountNotificationResult);
    this._handleServerNotification(subscription, [result.value, result.context]);
  }
  /**
   * @internal
   */
  _makeSubscription(subscriptionConfig, args2) {
    const clientSubscriptionId = this._nextClientSubscriptionId++;
    const hash2 = fastStableStringify$1([subscriptionConfig.method, args2]);
    const existingSubscription = this._subscriptionsByHash[hash2];
    if (existingSubscription === void 0) {
      this._subscriptionsByHash[hash2] = __spreadProps(__spreadValues({}, subscriptionConfig), {
        args: args2,
        callbacks: /* @__PURE__ */ new Set([subscriptionConfig.callback]),
        state: "pending"
      });
    } else {
      existingSubscription.callbacks.add(subscriptionConfig.callback);
    }
    this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash2;
    this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = () => __async(this, null, function* () {
      delete this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
      delete this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
      const subscription = this._subscriptionsByHash[hash2];
      assert3(subscription !== void 0, `Could not find a \`Subscription\` when tearing down client subscription #${clientSubscriptionId}`);
      subscription.callbacks.delete(subscriptionConfig.callback);
      yield this._updateSubscriptions();
    });
    this._updateSubscriptions();
    return clientSubscriptionId;
  }
  /**
   * Register a callback to be invoked whenever the specified account changes
   *
   * @param publicKey Public key of the account to monitor
   * @param callback Function to invoke whenever the account is changed
   * @param commitment Specify the commitment level account changes must reach before notification
   * @return subscription id
   */
  onAccountChange(publicKey3, callback, commitment) {
    const args2 = this._buildArgs(
      [publicKey3.toBase58()],
      commitment || this._commitment || "finalized",
      // Apply connection/server default.
      "base64"
    );
    return this._makeSubscription({
      callback,
      method: "accountSubscribe",
      unsubscribeMethod: "accountUnsubscribe"
    }, args2);
  }
  /**
   * Deregister an account notification callback
   *
   * @param id client subscription id to deregister
   */
  removeAccountChangeListener(clientSubscriptionId) {
    return __async(this, null, function* () {
      yield this._unsubscribeClientSubscription(clientSubscriptionId, "account change");
    });
  }
  /**
   * @internal
   */
  _wsOnProgramAccountNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, ProgramAccountNotificationResult);
    this._handleServerNotification(subscription, [{
      accountId: result.value.pubkey,
      accountInfo: result.value.account
    }, result.context]);
  }
  /**
   * Register a callback to be invoked whenever accounts owned by the
   * specified program change
   *
   * @param programId Public key of the program to monitor
   * @param callback Function to invoke whenever the account is changed
   * @param commitment Specify the commitment level account changes must reach before notification
   * @param filters The program account filters to pass into the RPC method
   * @return subscription id
   */
  onProgramAccountChange(programId, callback, commitment, filters) {
    const args2 = this._buildArgs(
      [programId.toBase58()],
      commitment || this._commitment || "finalized",
      // Apply connection/server default.
      "base64",
      filters ? {
        filters
      } : void 0
      /* extra */
    );
    return this._makeSubscription({
      callback,
      method: "programSubscribe",
      unsubscribeMethod: "programUnsubscribe"
    }, args2);
  }
  /**
   * Deregister an account notification callback
   *
   * @param id client subscription id to deregister
   */
  removeProgramAccountChangeListener(clientSubscriptionId) {
    return __async(this, null, function* () {
      yield this._unsubscribeClientSubscription(clientSubscriptionId, "program account change");
    });
  }
  /**
   * Registers a callback to be invoked whenever logs are emitted.
   */
  onLogs(filter, callback, commitment) {
    const args2 = this._buildArgs(
      [typeof filter === "object" ? {
        mentions: [filter.toString()]
      } : filter],
      commitment || this._commitment || "finalized"
      // Apply connection/server default.
    );
    return this._makeSubscription({
      callback,
      method: "logsSubscribe",
      unsubscribeMethod: "logsUnsubscribe"
    }, args2);
  }
  /**
   * Deregister a logs callback.
   *
   * @param id client subscription id to deregister.
   */
  removeOnLogsListener(clientSubscriptionId) {
    return __async(this, null, function* () {
      yield this._unsubscribeClientSubscription(clientSubscriptionId, "logs");
    });
  }
  /**
   * @internal
   */
  _wsOnLogsNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, LogsNotificationResult);
    this._handleServerNotification(subscription, [result.value, result.context]);
  }
  /**
   * @internal
   */
  _wsOnSlotNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, SlotNotificationResult);
    this._handleServerNotification(subscription, [result]);
  }
  /**
   * Register a callback to be invoked upon slot changes
   *
   * @param callback Function to invoke whenever the slot changes
   * @return subscription id
   */
  onSlotChange(callback) {
    return this._makeSubscription(
      {
        callback,
        method: "slotSubscribe",
        unsubscribeMethod: "slotUnsubscribe"
      },
      []
      /* args */
    );
  }
  /**
   * Deregister a slot notification callback
   *
   * @param id client subscription id to deregister
   */
  removeSlotChangeListener(clientSubscriptionId) {
    return __async(this, null, function* () {
      yield this._unsubscribeClientSubscription(clientSubscriptionId, "slot change");
    });
  }
  /**
   * @internal
   */
  _wsOnSlotUpdatesNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, SlotUpdateNotificationResult);
    this._handleServerNotification(subscription, [result]);
  }
  /**
   * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s
   * may be useful to track live progress of a cluster.
   *
   * @param callback Function to invoke whenever the slot updates
   * @return subscription id
   */
  onSlotUpdate(callback) {
    return this._makeSubscription(
      {
        callback,
        method: "slotsUpdatesSubscribe",
        unsubscribeMethod: "slotsUpdatesUnsubscribe"
      },
      []
      /* args */
    );
  }
  /**
   * Deregister a slot update notification callback
   *
   * @param id client subscription id to deregister
   */
  removeSlotUpdateListener(clientSubscriptionId) {
    return __async(this, null, function* () {
      yield this._unsubscribeClientSubscription(clientSubscriptionId, "slot update");
    });
  }
  /**
   * @internal
   */
  _unsubscribeClientSubscription(clientSubscriptionId, subscriptionName) {
    return __async(this, null, function* () {
      const dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
      if (dispose) {
        yield dispose();
      } else {
        console.warn(`Ignored unsubscribe request because an active subscription with id \`${clientSubscriptionId}\` for '${subscriptionName}' events could not be found.`);
      }
    });
  }
  _buildArgs(args2, override, encoding, extra) {
    const commitment = override || this._commitment;
    if (commitment || encoding || extra) {
      let options = {};
      if (encoding) {
        options.encoding = encoding;
      }
      if (commitment) {
        options.commitment = commitment;
      }
      if (extra) {
        options = Object.assign(options, extra);
      }
      args2.push(options);
    }
    return args2;
  }
  /**
   * @internal
   */
  _buildArgsAtLeastConfirmed(args2, override, encoding, extra) {
    const commitment = override || this._commitment;
    if (commitment && !["confirmed", "finalized"].includes(commitment)) {
      throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
    }
    return this._buildArgs(args2, override, encoding, extra);
  }
  /**
   * @internal
   */
  _wsOnSignatureNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, SignatureNotificationResult);
    if (result.value !== "receivedSignature") {
      this._subscriptionsAutoDisposedByRpc.add(subscription);
    }
    this._handleServerNotification(subscription, result.value === "receivedSignature" ? [{
      type: "received"
    }, result.context] : [{
      type: "status",
      result: result.value
    }, result.context]);
  }
  /**
   * Register a callback to be invoked upon signature updates
   *
   * @param signature Transaction signature string in base 58
   * @param callback Function to invoke on signature notifications
   * @param commitment Specify the commitment level signature must reach before notification
   * @return subscription id
   */
  onSignature(signature2, callback, commitment) {
    const args2 = this._buildArgs(
      [signature2],
      commitment || this._commitment || "finalized"
      // Apply connection/server default.
    );
    const clientSubscriptionId = this._makeSubscription({
      callback: (notification, context) => {
        if (notification.type === "status") {
          callback(notification.result, context);
          try {
            this.removeSignatureListener(clientSubscriptionId);
          } catch (_err) {
          }
        }
      },
      method: "signatureSubscribe",
      unsubscribeMethod: "signatureUnsubscribe"
    }, args2);
    return clientSubscriptionId;
  }
  /**
   * Register a callback to be invoked when a transaction is
   * received and/or processed.
   *
   * @param signature Transaction signature string in base 58
   * @param callback Function to invoke on signature notifications
   * @param options Enable received notifications and set the commitment
   *   level that signature must reach before notification
   * @return subscription id
   */
  onSignatureWithOptions(signature2, callback, options) {
    const _a = __spreadProps(__spreadValues({}, options), {
      commitment: options && options.commitment || this._commitment || "finalized"
      // Apply connection/server default.
    }), {
      commitment
    } = _a, extra = __objRest(_a, [
      "commitment"
    ]);
    const args2 = this._buildArgs([signature2], commitment, void 0, extra);
    const clientSubscriptionId = this._makeSubscription({
      callback: (notification, context) => {
        callback(notification, context);
        try {
          this.removeSignatureListener(clientSubscriptionId);
        } catch (_err) {
        }
      },
      method: "signatureSubscribe",
      unsubscribeMethod: "signatureUnsubscribe"
    }, args2);
    return clientSubscriptionId;
  }
  /**
   * Deregister a signature notification callback
   *
   * @param id client subscription id to deregister
   */
  removeSignatureListener(clientSubscriptionId) {
    return __async(this, null, function* () {
      yield this._unsubscribeClientSubscription(clientSubscriptionId, "signature result");
    });
  }
  /**
   * @internal
   */
  _wsOnRootNotification(notification) {
    const {
      result,
      subscription
    } = create(notification, RootNotificationResult);
    this._handleServerNotification(subscription, [result]);
  }
  /**
   * Register a callback to be invoked upon root changes
   *
   * @param callback Function to invoke whenever the root changes
   * @return subscription id
   */
  onRootChange(callback) {
    return this._makeSubscription(
      {
        callback,
        method: "rootSubscribe",
        unsubscribeMethod: "rootUnsubscribe"
      },
      []
      /* args */
    );
  }
  /**
   * Deregister a root notification callback
   *
   * @param id client subscription id to deregister
   */
  removeRootChangeListener(clientSubscriptionId) {
    return __async(this, null, function* () {
      yield this._unsubscribeClientSubscription(clientSubscriptionId, "root change");
    });
  }
};
var Keypair = class {
  /**
   * Create a new keypair instance.
   * Generate random keypair if no {@link Ed25519Keypair} is provided.
   *
   * @param keypair ed25519 keypair
   */
  constructor(keypair) {
    this._keypair = void 0;
    this._keypair = keypair != null ? keypair : generateKeypair();
  }
  /**
   * Generate a new random keypair
   */
  static generate() {
    return new Keypair(generateKeypair());
  }
  /**
   * Create a keypair from a raw secret key byte array.
   *
   * This method should only be used to recreate a keypair from a previously
   * generated secret key. Generating keypairs from a random seed should be done
   * with the {@link Keypair.fromSeed} method.
   *
   * @throws error if the provided secret key is invalid and validation is not skipped.
   *
   * @param secretKey secret key byte array
   * @param options: skip secret key validation
   */
  static fromSecretKey(secretKey, options) {
    if (secretKey.byteLength !== 64) {
      throw new Error("bad secret key size");
    }
    const publicKey3 = secretKey.slice(32, 64);
    if (!options || !options.skipValidation) {
      const privateScalar = secretKey.slice(0, 32);
      const computedPublicKey = getPublicKey2(privateScalar);
      for (let ii = 0; ii < 32; ii++) {
        if (publicKey3[ii] !== computedPublicKey[ii]) {
          throw new Error("provided secretKey is invalid");
        }
      }
    }
    return new Keypair({
      publicKey: publicKey3,
      secretKey
    });
  }
  /**
   * Generate a keypair from a 32 byte seed.
   *
   * @param seed seed byte array
   */
  static fromSeed(seed) {
    const publicKey3 = getPublicKey2(seed);
    const secretKey = new Uint8Array(64);
    secretKey.set(seed);
    secretKey.set(publicKey3, 32);
    return new Keypair({
      publicKey: publicKey3,
      secretKey
    });
  }
  /**
   * The public key for this keypair
   */
  get publicKey() {
    return new PublicKey(this._keypair.publicKey);
  }
  /**
   * The raw secret key for this keypair
   */
  get secretKey() {
    return new Uint8Array(this._keypair.secretKey);
  }
};
var LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), u642("recentSlot"), BufferLayout.u8("bumpSeed")])
  },
  FreezeLookupTable: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  ExtendLookupTable: {
    index: 2,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), u642(), BufferLayout.seq(publicKey(), BufferLayout.offset(BufferLayout.u32(), -8), "addresses")])
  },
  DeactivateLookupTable: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  CloseLookupTable: {
    index: 4,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  }
});
var AddressLookupTableInstruction = class {
  /**
   * @internal
   */
  constructor() {
  }
  static decodeInstructionType(instruction) {
    this.checkProgramId(instruction.programId);
    const instructionTypeLayout = BufferLayout.u32("instruction");
    const index = instructionTypeLayout.decode(instruction.data);
    let type2;
    for (const [layoutType, layout] of Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS)) {
      if (layout.index == index) {
        type2 = layoutType;
        break;
      }
    }
    if (!type2) {
      throw new Error("Invalid Instruction. Should be a LookupTable Instruction");
    }
    return type2;
  }
  static decodeCreateLookupTable(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeysLength(instruction.keys, 4);
    const {
      recentSlot
    } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, instruction.data);
    return {
      authority: instruction.keys[1].pubkey,
      payer: instruction.keys[2].pubkey,
      recentSlot: Number(recentSlot)
    };
  }
  static decodeExtendLookupTable(instruction) {
    this.checkProgramId(instruction.programId);
    if (instruction.keys.length < 2) {
      throw new Error(`invalid instruction; found ${instruction.keys.length} keys, expected at least 2`);
    }
    const {
      addresses
    } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, instruction.data);
    return {
      lookupTable: instruction.keys[0].pubkey,
      authority: instruction.keys[1].pubkey,
      payer: instruction.keys.length > 2 ? instruction.keys[2].pubkey : void 0,
      addresses: addresses.map((buffer) => new PublicKey(buffer))
    };
  }
  static decodeCloseLookupTable(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeysLength(instruction.keys, 3);
    return {
      lookupTable: instruction.keys[0].pubkey,
      authority: instruction.keys[1].pubkey,
      recipient: instruction.keys[2].pubkey
    };
  }
  static decodeFreezeLookupTable(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeysLength(instruction.keys, 2);
    return {
      lookupTable: instruction.keys[0].pubkey,
      authority: instruction.keys[1].pubkey
    };
  }
  static decodeDeactivateLookupTable(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeysLength(instruction.keys, 2);
    return {
      lookupTable: instruction.keys[0].pubkey,
      authority: instruction.keys[1].pubkey
    };
  }
  /**
   * @internal
   */
  static checkProgramId(programId) {
    if (!programId.equals(AddressLookupTableProgram.programId)) {
      throw new Error("invalid instruction; programId is not AddressLookupTable Program");
    }
  }
  /**
   * @internal
   */
  static checkKeysLength(keys, expectedLength) {
    if (keys.length < expectedLength) {
      throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
    }
  }
};
var AddressLookupTableProgram = class {
  /**
   * @internal
   */
  constructor() {
  }
  static createLookupTable(params) {
    const [lookupTableAddress, bumpSeed] = PublicKey.findProgramAddressSync([params.authority.toBuffer(), (0, import_bigint_buffer.toBufferLE)(BigInt(params.recentSlot), 8)], this.programId);
    const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;
    const data = encodeData(type2, {
      recentSlot: BigInt(params.recentSlot),
      bumpSeed
    });
    const keys = [{
      pubkey: lookupTableAddress,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: params.payer,
      isSigner: true,
      isWritable: true
    }, {
      pubkey: SystemProgram.programId,
      isSigner: false,
      isWritable: false
    }];
    return [new TransactionInstruction({
      programId: this.programId,
      keys,
      data
    }), lookupTableAddress];
  }
  static freezeLookupTable(params) {
    const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;
    const data = encodeData(type2);
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    return new TransactionInstruction({
      programId: this.programId,
      keys,
      data
    });
  }
  static extendLookupTable(params) {
    const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;
    const data = encodeData(type2, {
      addresses: params.addresses.map((addr) => addr.toBytes())
    });
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    if (params.payer) {
      keys.push({
        pubkey: params.payer,
        isSigner: true,
        isWritable: true
      }, {
        pubkey: SystemProgram.programId,
        isSigner: false,
        isWritable: false
      });
    }
    return new TransactionInstruction({
      programId: this.programId,
      keys,
      data
    });
  }
  static deactivateLookupTable(params) {
    const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;
    const data = encodeData(type2);
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }];
    return new TransactionInstruction({
      programId: this.programId,
      keys,
      data
    });
  }
  static closeLookupTable(params) {
    const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;
    const data = encodeData(type2);
    const keys = [{
      pubkey: params.lookupTable,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: params.authority,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: params.recipient,
      isSigner: false,
      isWritable: true
    }];
    return new TransactionInstruction({
      programId: this.programId,
      keys,
      data
    });
  }
};
AddressLookupTableProgram.programId = new PublicKey("AddressLookupTab1e1111111111111111111111111");
var ComputeBudgetInstruction = class {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Decode a compute budget instruction and retrieve the instruction type.
   */
  static decodeInstructionType(instruction) {
    this.checkProgramId(instruction.programId);
    const instructionTypeLayout = BufferLayout.u8("instruction");
    const typeIndex = instructionTypeLayout.decode(instruction.data);
    let type2;
    for (const [ixType, layout] of Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS)) {
      if (layout.index == typeIndex) {
        type2 = ixType;
        break;
      }
    }
    if (!type2) {
      throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");
    }
    return type2;
  }
  /**
   * Decode request units compute budget instruction and retrieve the instruction params.
   */
  static decodeRequestUnits(instruction) {
    this.checkProgramId(instruction.programId);
    const {
      units,
      additionalFee
    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, instruction.data);
    return {
      units,
      additionalFee
    };
  }
  /**
   * Decode request heap frame compute budget instruction and retrieve the instruction params.
   */
  static decodeRequestHeapFrame(instruction) {
    this.checkProgramId(instruction.programId);
    const {
      bytes: bytes2
    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, instruction.data);
    return {
      bytes: bytes2
    };
  }
  /**
   * Decode set compute unit limit compute budget instruction and retrieve the instruction params.
   */
  static decodeSetComputeUnitLimit(instruction) {
    this.checkProgramId(instruction.programId);
    const {
      units
    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, instruction.data);
    return {
      units
    };
  }
  /**
   * Decode set compute unit price compute budget instruction and retrieve the instruction params.
   */
  static decodeSetComputeUnitPrice(instruction) {
    this.checkProgramId(instruction.programId);
    const {
      microLamports
    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, instruction.data);
    return {
      microLamports
    };
  }
  /**
   * @internal
   */
  static checkProgramId(programId) {
    if (!programId.equals(ComputeBudgetProgram.programId)) {
      throw new Error("invalid instruction; programId is not ComputeBudgetProgram");
    }
  }
};
var COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({
  RequestUnits: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u8("instruction"), BufferLayout.u32("units"), BufferLayout.u32("additionalFee")])
  },
  RequestHeapFrame: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u8("instruction"), BufferLayout.u32("bytes")])
  },
  SetComputeUnitLimit: {
    index: 2,
    layout: BufferLayout.struct([BufferLayout.u8("instruction"), BufferLayout.u32("units")])
  },
  SetComputeUnitPrice: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u8("instruction"), u642("microLamports")])
  }
});
var ComputeBudgetProgram = class {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the Compute Budget program
   */
  /**
   * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}
   */
  static requestUnits(params) {
    const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;
    const data = encodeData(type2, params);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static requestHeapFrame(params) {
    const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;
    const data = encodeData(type2, params);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static setComputeUnitLimit(params) {
    const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;
    const data = encodeData(type2, params);
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }
  static setComputeUnitPrice(params) {
    const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;
    const data = encodeData(type2, {
      microLamports: BigInt(params.microLamports)
    });
    return new TransactionInstruction({
      keys: [],
      programId: this.programId,
      data
    });
  }
};
ComputeBudgetProgram.programId = new PublicKey("ComputeBudget111111111111111111111111111111");
var PRIVATE_KEY_BYTES$1 = 64;
var PUBLIC_KEY_BYTES$1 = 32;
var SIGNATURE_BYTES = 64;
var ED25519_INSTRUCTION_LAYOUT = BufferLayout.struct([BufferLayout.u8("numSignatures"), BufferLayout.u8("padding"), BufferLayout.u16("signatureOffset"), BufferLayout.u16("signatureInstructionIndex"), BufferLayout.u16("publicKeyOffset"), BufferLayout.u16("publicKeyInstructionIndex"), BufferLayout.u16("messageDataOffset"), BufferLayout.u16("messageDataSize"), BufferLayout.u16("messageInstructionIndex")]);
var Ed25519Program = class {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the ed25519 program
   */
  /**
   * Create an ed25519 instruction with a public key and signature. The
   * public key must be a buffer that is 32 bytes long, and the signature
   * must be a buffer of 64 bytes.
   */
  static createInstructionWithPublicKey(params) {
    const {
      publicKey: publicKey3,
      message: message2,
      signature: signature2,
      instructionIndex
    } = params;
    assert3(publicKey3.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey3.length} bytes`);
    assert3(signature2.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature2.length} bytes`);
    const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;
    const signatureOffset = publicKeyOffset + publicKey3.length;
    const messageDataOffset = signatureOffset + signature2.length;
    const numSignatures = 1;
    const instructionData = Buffer2.alloc(messageDataOffset + message2.length);
    const index = instructionIndex == null ? 65535 : instructionIndex;
    ED25519_INSTRUCTION_LAYOUT.encode({
      numSignatures,
      padding: 0,
      signatureOffset,
      signatureInstructionIndex: index,
      publicKeyOffset,
      publicKeyInstructionIndex: index,
      messageDataOffset,
      messageDataSize: message2.length,
      messageInstructionIndex: index
    }, instructionData);
    instructionData.fill(publicKey3, publicKeyOffset);
    instructionData.fill(signature2, signatureOffset);
    instructionData.fill(message2, messageDataOffset);
    return new TransactionInstruction({
      keys: [],
      programId: Ed25519Program.programId,
      data: instructionData
    });
  }
  /**
   * Create an ed25519 instruction with a private key. The private key
   * must be a buffer that is 64 bytes long.
   */
  static createInstructionWithPrivateKey(params) {
    const {
      privateKey,
      message: message2,
      instructionIndex
    } = params;
    assert3(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);
    try {
      const keypair = Keypair.fromSecretKey(privateKey);
      const publicKey3 = keypair.publicKey.toBytes();
      const signature2 = sign(message2, keypair.secretKey);
      return this.createInstructionWithPublicKey({
        publicKey: publicKey3,
        message: message2,
        signature: signature2,
        instructionIndex
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }
};
Ed25519Program.programId = new PublicKey("Ed25519SigVerify111111111111111111111111111");
utils2.hmacSha256Sync = (key, ...msgs) => {
  const h2 = hmac.create(sha256, key);
  msgs.forEach((msg) => h2.update(msg));
  return h2.digest();
};
var ecdsaSign = (msgHash, privKey) => signSync2(msgHash, privKey, {
  der: false,
  recovered: true
});
utils2.isValidPrivateKey;
var publicKeyCreate = getPublicKey;
var PRIVATE_KEY_BYTES = 32;
var ETHEREUM_ADDRESS_BYTES = 20;
var PUBLIC_KEY_BYTES = 64;
var SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;
var SECP256K1_INSTRUCTION_LAYOUT = BufferLayout.struct([BufferLayout.u8("numSignatures"), BufferLayout.u16("signatureOffset"), BufferLayout.u8("signatureInstructionIndex"), BufferLayout.u16("ethAddressOffset"), BufferLayout.u8("ethAddressInstructionIndex"), BufferLayout.u16("messageDataOffset"), BufferLayout.u16("messageDataSize"), BufferLayout.u8("messageInstructionIndex"), BufferLayout.blob(20, "ethAddress"), BufferLayout.blob(64, "signature"), BufferLayout.u8("recoveryId")]);
var Secp256k1Program = class {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the secp256k1 program
   */
  /**
   * Construct an Ethereum address from a secp256k1 public key buffer.
   * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer
   */
  static publicKeyToEthAddress(publicKey3) {
    assert3(publicKey3.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey3.length} bytes`);
    try {
      return Buffer2.from(keccak_256(toBuffer(publicKey3))).slice(-ETHEREUM_ADDRESS_BYTES);
    } catch (error) {
      throw new Error(`Error constructing Ethereum address: ${error}`);
    }
  }
  /**
   * Create an secp256k1 instruction with a public key. The public key
   * must be a buffer that is 64 bytes long.
   */
  static createInstructionWithPublicKey(params) {
    const {
      publicKey: publicKey3,
      message: message2,
      signature: signature2,
      recoveryId,
      instructionIndex
    } = params;
    return Secp256k1Program.createInstructionWithEthAddress({
      ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey3),
      message: message2,
      signature: signature2,
      recoveryId,
      instructionIndex
    });
  }
  /**
   * Create an secp256k1 instruction with an Ethereum address. The address
   * must be a hex string or a buffer that is 20 bytes long.
   */
  static createInstructionWithEthAddress(params) {
    const {
      ethAddress: rawAddress,
      message: message2,
      signature: signature2,
      recoveryId,
      instructionIndex = 0
    } = params;
    let ethAddress;
    if (typeof rawAddress === "string") {
      if (rawAddress.startsWith("0x")) {
        ethAddress = Buffer2.from(rawAddress.substr(2), "hex");
      } else {
        ethAddress = Buffer2.from(rawAddress, "hex");
      }
    } else {
      ethAddress = rawAddress;
    }
    assert3(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);
    const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;
    const ethAddressOffset = dataStart;
    const signatureOffset = dataStart + ethAddress.length;
    const messageDataOffset = signatureOffset + signature2.length + 1;
    const numSignatures = 1;
    const instructionData = Buffer2.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message2.length);
    SECP256K1_INSTRUCTION_LAYOUT.encode({
      numSignatures,
      signatureOffset,
      signatureInstructionIndex: instructionIndex,
      ethAddressOffset,
      ethAddressInstructionIndex: instructionIndex,
      messageDataOffset,
      messageDataSize: message2.length,
      messageInstructionIndex: instructionIndex,
      signature: toBuffer(signature2),
      ethAddress: toBuffer(ethAddress),
      recoveryId
    }, instructionData);
    instructionData.fill(toBuffer(message2), SECP256K1_INSTRUCTION_LAYOUT.span);
    return new TransactionInstruction({
      keys: [],
      programId: Secp256k1Program.programId,
      data: instructionData
    });
  }
  /**
   * Create an secp256k1 instruction with a private key. The private key
   * must be a buffer that is 32 bytes long.
   */
  static createInstructionWithPrivateKey(params) {
    const {
      privateKey: pkey,
      message: message2,
      instructionIndex
    } = params;
    assert3(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);
    try {
      const privateKey = toBuffer(pkey);
      const publicKey3 = publicKeyCreate(
        privateKey,
        false
        /* isCompressed */
      ).slice(1);
      const messageHash = Buffer2.from(keccak_256(toBuffer(message2)));
      const [signature2, recoveryId] = ecdsaSign(messageHash, privateKey);
      return this.createInstructionWithPublicKey({
        publicKey: publicKey3,
        message: message2,
        signature: signature2,
        recoveryId,
        instructionIndex
      });
    } catch (error) {
      throw new Error(`Error creating instruction; ${error}`);
    }
  }
};
Secp256k1Program.programId = new PublicKey("KeccakSecp256k11111111111111111111111111111");
var STAKE_CONFIG_ID = new PublicKey("StakeConfig11111111111111111111111111111111");
var Authorized = class {
  /** stake authority */
  /** withdraw authority */
  /**
   * Create a new Authorized object
   * @param staker the stake authority
   * @param withdrawer the withdraw authority
   */
  constructor(staker, withdrawer) {
    this.staker = void 0;
    this.withdrawer = void 0;
    this.staker = staker;
    this.withdrawer = withdrawer;
  }
};
var Lockup = class {
  /** Unix timestamp of lockup expiration */
  /** Epoch of lockup expiration */
  /** Lockup custodian authority */
  /**
   * Create a new Lockup object
   */
  constructor(unixTimestamp, epoch, custodian) {
    this.unixTimestamp = void 0;
    this.epoch = void 0;
    this.custodian = void 0;
    this.unixTimestamp = unixTimestamp;
    this.epoch = epoch;
    this.custodian = custodian;
  }
  /**
   * Default, inactive Lockup value
   */
};
Lockup.default = new Lockup(0, 0, PublicKey.default);
var StakeInstruction = class {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Decode a stake instruction and retrieve the instruction type.
   */
  static decodeInstructionType(instruction) {
    this.checkProgramId(instruction.programId);
    const instructionTypeLayout = BufferLayout.u32("instruction");
    const typeIndex = instructionTypeLayout.decode(instruction.data);
    let type2;
    for (const [ixType, layout] of Object.entries(STAKE_INSTRUCTION_LAYOUTS)) {
      if (layout.index == typeIndex) {
        type2 = ixType;
        break;
      }
    }
    if (!type2) {
      throw new Error("Instruction type incorrect; not a StakeInstruction");
    }
    return type2;
  }
  /**
   * Decode a initialize stake instruction and retrieve the instruction params.
   */
  static decodeInitialize(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 2);
    const {
      authorized: authorized2,
      lockup: lockup2
    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data);
    return {
      stakePubkey: instruction.keys[0].pubkey,
      authorized: new Authorized(new PublicKey(authorized2.staker), new PublicKey(authorized2.withdrawer)),
      lockup: new Lockup(lockup2.unixTimestamp, lockup2.epoch, new PublicKey(lockup2.custodian))
    };
  }
  /**
   * Decode a delegate stake instruction and retrieve the instruction params.
   */
  static decodeDelegate(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 6);
    decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);
    return {
      stakePubkey: instruction.keys[0].pubkey,
      votePubkey: instruction.keys[1].pubkey,
      authorizedPubkey: instruction.keys[5].pubkey
    };
  }
  /**
   * Decode an authorize stake instruction and retrieve the instruction params.
   */
  static decodeAuthorize(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    const {
      newAuthorized,
      stakeAuthorizationType
    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);
    const o = {
      stakePubkey: instruction.keys[0].pubkey,
      authorizedPubkey: instruction.keys[2].pubkey,
      newAuthorizedPubkey: new PublicKey(newAuthorized),
      stakeAuthorizationType: {
        index: stakeAuthorizationType
      }
    };
    if (instruction.keys.length > 3) {
      o.custodianPubkey = instruction.keys[3].pubkey;
    }
    return o;
  }
  /**
   * Decode an authorize-with-seed stake instruction and retrieve the instruction params.
   */
  static decodeAuthorizeWithSeed(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 2);
    const {
      newAuthorized,
      stakeAuthorizationType,
      authoritySeed,
      authorityOwner
    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);
    const o = {
      stakePubkey: instruction.keys[0].pubkey,
      authorityBase: instruction.keys[1].pubkey,
      authoritySeed,
      authorityOwner: new PublicKey(authorityOwner),
      newAuthorizedPubkey: new PublicKey(newAuthorized),
      stakeAuthorizationType: {
        index: stakeAuthorizationType
      }
    };
    if (instruction.keys.length > 3) {
      o.custodianPubkey = instruction.keys[3].pubkey;
    }
    return o;
  }
  /**
   * Decode a split stake instruction and retrieve the instruction params.
   */
  static decodeSplit(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    const {
      lamports
    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data);
    return {
      stakePubkey: instruction.keys[0].pubkey,
      splitStakePubkey: instruction.keys[1].pubkey,
      authorizedPubkey: instruction.keys[2].pubkey,
      lamports
    };
  }
  /**
   * Decode a merge stake instruction and retrieve the instruction params.
   */
  static decodeMerge(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, instruction.data);
    return {
      stakePubkey: instruction.keys[0].pubkey,
      sourceStakePubKey: instruction.keys[1].pubkey,
      authorizedPubkey: instruction.keys[4].pubkey
    };
  }
  /**
   * Decode a withdraw stake instruction and retrieve the instruction params.
   */
  static decodeWithdraw(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 5);
    const {
      lamports
    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);
    const o = {
      stakePubkey: instruction.keys[0].pubkey,
      toPubkey: instruction.keys[1].pubkey,
      authorizedPubkey: instruction.keys[4].pubkey,
      lamports
    };
    if (instruction.keys.length > 5) {
      o.custodianPubkey = instruction.keys[5].pubkey;
    }
    return o;
  }
  /**
   * Decode a deactivate stake instruction and retrieve the instruction params.
   */
  static decodeDeactivate(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);
    return {
      stakePubkey: instruction.keys[0].pubkey,
      authorizedPubkey: instruction.keys[2].pubkey
    };
  }
  /**
   * @internal
   */
  static checkProgramId(programId) {
    if (!programId.equals(StakeProgram.programId)) {
      throw new Error("invalid instruction; programId is not StakeProgram");
    }
  }
  /**
   * @internal
   */
  static checkKeyLength(keys, expectedLength) {
    if (keys.length < expectedLength) {
      throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
    }
  }
};
var STAKE_INSTRUCTION_LAYOUTS = Object.freeze({
  Initialize: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), authorized(), lockup()])
  },
  Authorize: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("newAuthorized"), BufferLayout.u32("stakeAuthorizationType")])
  },
  Delegate: {
    index: 2,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  Split: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
  },
  Withdraw: {
    index: 4,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
  },
  Deactivate: {
    index: 5,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  Merge: {
    index: 7,
    layout: BufferLayout.struct([BufferLayout.u32("instruction")])
  },
  AuthorizeWithSeed: {
    index: 8,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("newAuthorized"), BufferLayout.u32("stakeAuthorizationType"), rustString("authoritySeed"), publicKey("authorityOwner")])
  }
});
var StakeAuthorizationLayout = Object.freeze({
  Staker: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});
var StakeProgram = class {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the Stake program
   */
  /**
   * Generate an Initialize instruction to add to a Stake Create transaction
   */
  static initialize(params) {
    const {
      stakePubkey,
      authorized: authorized2,
      lockup: maybeLockup
    } = params;
    const lockup2 = maybeLockup || Lockup.default;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Initialize;
    const data = encodeData(type2, {
      authorized: {
        staker: toBuffer(authorized2.staker.toBuffer()),
        withdrawer: toBuffer(authorized2.withdrawer.toBuffer())
      },
      lockup: {
        unixTimestamp: lockup2.unixTimestamp,
        epoch: lockup2.epoch,
        custodian: toBuffer(lockup2.custodian.toBuffer())
      }
    });
    const instructionData = {
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  /**
   * Generate a Transaction that creates a new Stake account at
   *   an address generated with `from`, a seed, and the Stake programId
   */
  static createAccountWithSeed(params) {
    const transaction = new Transaction();
    transaction.add(SystemProgram.createAccountWithSeed({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      basePubkey: params.basePubkey,
      seed: params.seed,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized: authorized2,
      lockup: lockup2
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized: authorized2,
      lockup: lockup2
    }));
  }
  /**
   * Generate a Transaction that creates a new Stake account
   */
  static createAccount(params) {
    const transaction = new Transaction();
    transaction.add(SystemProgram.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.stakePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    const {
      stakePubkey,
      authorized: authorized2,
      lockup: lockup2
    } = params;
    return transaction.add(this.initialize({
      stakePubkey,
      authorized: authorized2,
      lockup: lockup2
    }));
  }
  /**
   * Generate a Transaction that delegates Stake tokens to a validator
   * Vote PublicKey. This transaction can also be used to redelegate Stake
   * to a new validator Vote PublicKey.
   */
  static delegate(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      votePubkey
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Delegate;
    const data = encodeData(type2);
    return new Transaction().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: votePubkey,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: STAKE_CONFIG_ID,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that authorizes a new PublicKey as Staker
   * or Withdrawer on the Stake account.
   */
  static authorize(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Authorize;
    const data = encodeData(type2, {
      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
      stakeAuthorizationType: stakeAuthorizationType.index
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: false,
        isWritable: false
      });
    }
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that authorizes a new PublicKey as Staker
   * or Withdrawer on the Stake account.
   */
  static authorizeWithSeed(params) {
    const {
      stakePubkey,
      authorityBase,
      authoritySeed,
      authorityOwner,
      newAuthorizedPubkey,
      stakeAuthorizationType,
      custodianPubkey
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
    const data = encodeData(type2, {
      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
      stakeAuthorizationType: stakeAuthorizationType.index,
      authoritySeed,
      authorityOwner: toBuffer(authorityOwner.toBuffer())
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorityBase,
      isSigner: true,
      isWritable: false
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: false,
        isWritable: false
      });
    }
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * @internal
   */
  static splitInstruction(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      lamports
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Split;
    const data = encodeData(type2, {
      lamports
    });
    return new TransactionInstruction({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: splitStakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that splits Stake tokens into another stake account
   */
  static split(params) {
    const transaction = new Transaction();
    transaction.add(SystemProgram.createAccount({
      fromPubkey: params.authorizedPubkey,
      newAccountPubkey: params.splitStakePubkey,
      lamports: 0,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.splitInstruction(params));
  }
  /**
   * Generate a Transaction that splits Stake tokens into another account
   * derived from a base public key and seed
   */
  static splitWithSeed(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      basePubkey,
      seed,
      lamports
    } = params;
    const transaction = new Transaction();
    transaction.add(SystemProgram.allocate({
      accountPubkey: splitStakePubkey,
      basePubkey,
      seed,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.splitInstruction({
      stakePubkey,
      authorizedPubkey,
      splitStakePubkey,
      lamports
    }));
  }
  /**
   * Generate a Transaction that merges Stake accounts.
   */
  static merge(params) {
    const {
      stakePubkey,
      sourceStakePubKey,
      authorizedPubkey
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Merge;
    const data = encodeData(type2);
    return new Transaction().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: sourceStakePubKey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that withdraws deactivated Stake tokens.
   */
  static withdraw(params) {
    const {
      stakePubkey,
      authorizedPubkey,
      toPubkey,
      lamports,
      custodianPubkey
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Withdraw;
    const data = encodeData(type2, {
      lamports
    });
    const keys = [{
      pubkey: stakePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    if (custodianPubkey) {
      keys.push({
        pubkey: custodianPubkey,
        isSigner: false,
        isWritable: false
      });
    }
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a Transaction that deactivates Stake tokens.
   */
  static deactivate(params) {
    const {
      stakePubkey,
      authorizedPubkey
    } = params;
    const type2 = STAKE_INSTRUCTION_LAYOUTS.Deactivate;
    const data = encodeData(type2);
    return new Transaction().add({
      keys: [{
        pubkey: stakePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: authorizedPubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    });
  }
};
StakeProgram.programId = new PublicKey("Stake11111111111111111111111111111111111111");
StakeProgram.space = 200;
var VoteInit = class {
  /** [0, 100] */
  constructor(nodePubkey, authorizedVoter, authorizedWithdrawer, commission) {
    this.nodePubkey = void 0;
    this.authorizedVoter = void 0;
    this.authorizedWithdrawer = void 0;
    this.commission = void 0;
    this.nodePubkey = nodePubkey;
    this.authorizedVoter = authorizedVoter;
    this.authorizedWithdrawer = authorizedWithdrawer;
    this.commission = commission;
  }
};
var VoteInstruction = class {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Decode a vote instruction and retrieve the instruction type.
   */
  static decodeInstructionType(instruction) {
    this.checkProgramId(instruction.programId);
    const instructionTypeLayout = BufferLayout.u32("instruction");
    const typeIndex = instructionTypeLayout.decode(instruction.data);
    let type2;
    for (const [ixType, layout] of Object.entries(VOTE_INSTRUCTION_LAYOUTS)) {
      if (layout.index == typeIndex) {
        type2 = ixType;
        break;
      }
    }
    if (!type2) {
      throw new Error("Instruction type incorrect; not a VoteInstruction");
    }
    return type2;
  }
  /**
   * Decode an initialize vote instruction and retrieve the instruction params.
   */
  static decodeInitializeAccount(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 4);
    const {
      voteInit: voteInit2
    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, instruction.data);
    return {
      votePubkey: instruction.keys[0].pubkey,
      nodePubkey: instruction.keys[3].pubkey,
      voteInit: new VoteInit(new PublicKey(voteInit2.nodePubkey), new PublicKey(voteInit2.authorizedVoter), new PublicKey(voteInit2.authorizedWithdrawer), voteInit2.commission)
    };
  }
  /**
   * Decode an authorize instruction and retrieve the instruction params.
   */
  static decodeAuthorize(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    const {
      newAuthorized,
      voteAuthorizationType
    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);
    return {
      votePubkey: instruction.keys[0].pubkey,
      authorizedPubkey: instruction.keys[2].pubkey,
      newAuthorizedPubkey: new PublicKey(newAuthorized),
      voteAuthorizationType: {
        index: voteAuthorizationType
      }
    };
  }
  /**
   * Decode an authorize instruction and retrieve the instruction params.
   */
  static decodeAuthorizeWithSeed(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    const {
      voteAuthorizeWithSeedArgs: {
        currentAuthorityDerivedKeyOwnerPubkey,
        currentAuthorityDerivedKeySeed,
        newAuthorized,
        voteAuthorizationType
      }
    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);
    return {
      currentAuthorityDerivedKeyBasePubkey: instruction.keys[2].pubkey,
      currentAuthorityDerivedKeyOwnerPubkey: new PublicKey(currentAuthorityDerivedKeyOwnerPubkey),
      currentAuthorityDerivedKeySeed,
      newAuthorizedPubkey: new PublicKey(newAuthorized),
      voteAuthorizationType: {
        index: voteAuthorizationType
      },
      votePubkey: instruction.keys[0].pubkey
    };
  }
  /**
   * Decode a withdraw instruction and retrieve the instruction params.
   */
  static decodeWithdraw(instruction) {
    this.checkProgramId(instruction.programId);
    this.checkKeyLength(instruction.keys, 3);
    const {
      lamports
    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);
    return {
      votePubkey: instruction.keys[0].pubkey,
      authorizedWithdrawerPubkey: instruction.keys[2].pubkey,
      lamports,
      toPubkey: instruction.keys[1].pubkey
    };
  }
  /**
   * @internal
   */
  static checkProgramId(programId) {
    if (!programId.equals(VoteProgram.programId)) {
      throw new Error("invalid instruction; programId is not VoteProgram");
    }
  }
  /**
   * @internal
   */
  static checkKeyLength(keys, expectedLength) {
    if (keys.length < expectedLength) {
      throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);
    }
  }
};
var VOTE_INSTRUCTION_LAYOUTS = Object.freeze({
  InitializeAccount: {
    index: 0,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), voteInit()])
  },
  Authorize: {
    index: 1,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), publicKey("newAuthorized"), BufferLayout.u32("voteAuthorizationType")])
  },
  Withdraw: {
    index: 3,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), BufferLayout.ns64("lamports")])
  },
  AuthorizeWithSeed: {
    index: 10,
    layout: BufferLayout.struct([BufferLayout.u32("instruction"), voteAuthorizeWithSeedArgs()])
  }
});
var VoteAuthorizationLayout = Object.freeze({
  Voter: {
    index: 0
  },
  Withdrawer: {
    index: 1
  }
});
var VoteProgram = class {
  /**
   * @internal
   */
  constructor() {
  }
  /**
   * Public key that identifies the Vote program
   */
  /**
   * Generate an Initialize instruction.
   */
  static initializeAccount(params) {
    const {
      votePubkey,
      nodePubkey,
      voteInit: voteInit2
    } = params;
    const type2 = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;
    const data = encodeData(type2, {
      voteInit: {
        nodePubkey: toBuffer(voteInit2.nodePubkey.toBuffer()),
        authorizedVoter: toBuffer(voteInit2.authorizedVoter.toBuffer()),
        authorizedWithdrawer: toBuffer(voteInit2.authorizedWithdrawer.toBuffer()),
        commission: voteInit2.commission
      }
    });
    const instructionData = {
      keys: [{
        pubkey: votePubkey,
        isSigner: false,
        isWritable: true
      }, {
        pubkey: SYSVAR_RENT_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: SYSVAR_CLOCK_PUBKEY,
        isSigner: false,
        isWritable: false
      }, {
        pubkey: nodePubkey,
        isSigner: true,
        isWritable: false
      }],
      programId: this.programId,
      data
    };
    return new TransactionInstruction(instructionData);
  }
  /**
   * Generate a transaction that creates a new Vote account.
   */
  static createAccount(params) {
    const transaction = new Transaction();
    transaction.add(SystemProgram.createAccount({
      fromPubkey: params.fromPubkey,
      newAccountPubkey: params.votePubkey,
      lamports: params.lamports,
      space: this.space,
      programId: this.programId
    }));
    return transaction.add(this.initializeAccount({
      votePubkey: params.votePubkey,
      nodePubkey: params.voteInit.nodePubkey,
      voteInit: params.voteInit
    }));
  }
  /**
   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.
   */
  static authorize(params) {
    const {
      votePubkey,
      authorizedPubkey,
      newAuthorizedPubkey,
      voteAuthorizationType
    } = params;
    const type2 = VOTE_INSTRUCTION_LAYOUTS.Authorize;
    const data = encodeData(type2, {
      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
      voteAuthorizationType: voteAuthorizationType.index
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: authorizedPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account
   * where the current Voter or Withdrawer authority is a derived key.
   */
  static authorizeWithSeed(params) {
    const {
      currentAuthorityDerivedKeyBasePubkey,
      currentAuthorityDerivedKeyOwnerPubkey,
      currentAuthorityDerivedKeySeed,
      newAuthorizedPubkey,
      voteAuthorizationType,
      votePubkey
    } = params;
    const type2 = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
    const data = encodeData(type2, {
      voteAuthorizeWithSeedArgs: {
        currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),
        currentAuthorityDerivedKeySeed,
        newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
        voteAuthorizationType: voteAuthorizationType.index
      }
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: SYSVAR_CLOCK_PUBKEY,
      isSigner: false,
      isWritable: false
    }, {
      pubkey: currentAuthorityDerivedKeyBasePubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction to withdraw from a Vote account.
   */
  static withdraw(params) {
    const {
      votePubkey,
      authorizedWithdrawerPubkey,
      lamports,
      toPubkey
    } = params;
    const type2 = VOTE_INSTRUCTION_LAYOUTS.Withdraw;
    const data = encodeData(type2, {
      lamports
    });
    const keys = [{
      pubkey: votePubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: toPubkey,
      isSigner: false,
      isWritable: true
    }, {
      pubkey: authorizedWithdrawerPubkey,
      isSigner: true,
      isWritable: false
    }];
    return new Transaction().add({
      keys,
      programId: this.programId,
      data
    });
  }
  /**
   * Generate a transaction to withdraw safely from a Vote account.
   *
   * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`
   * checks that the withdraw amount will not exceed the specified balance while leaving enough left
   * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the
   * `withdraw` method directly.
   */
  static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {
    if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {
      throw new Error("Withdraw will leave vote account with insuffcient funds.");
    }
    return VoteProgram.withdraw(params);
  }
};
VoteProgram.programId = new PublicKey("Vote111111111111111111111111111111111111111");
VoteProgram.space = 3731;
var VALIDATOR_INFO_KEY = new PublicKey("Va1idator1nfo111111111111111111111111111111");
var InfoString = type({
  name: string(),
  website: optional(string()),
  details: optional(string()),
  keybaseUsername: optional(string())
});
var ValidatorInfo = class {
  /**
   * validator public key
   */
  /**
   * validator information
   */
  /**
   * Construct a valid ValidatorInfo
   *
   * @param key validator public key
   * @param info validator information
   */
  constructor(key, info) {
    this.key = void 0;
    this.info = void 0;
    this.key = key;
    this.info = info;
  }
  /**
   * Deserialize ValidatorInfo from the config account data. Exactly two config
   * keys are required in the data.
   *
   * @param buffer config account data
   * @return null if info was not found
   */
  static fromConfigData(buffer) {
    let byteArray = [...buffer];
    const configKeyCount = decodeLength(byteArray);
    if (configKeyCount !== 2)
      return null;
    const configKeys = [];
    for (let i = 0; i < 2; i++) {
      const publicKey3 = new PublicKey(byteArray.slice(0, PUBLIC_KEY_LENGTH));
      byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
      const isSigner = byteArray.slice(0, 1)[0] === 1;
      byteArray = byteArray.slice(1);
      configKeys.push({
        publicKey: publicKey3,
        isSigner
      });
    }
    if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {
      if (configKeys[1].isSigner) {
        const rawInfo = rustString().decode(Buffer2.from(byteArray));
        const info = JSON.parse(rawInfo);
        assert2(info, InfoString);
        return new ValidatorInfo(configKeys[1].publicKey, info);
      }
    }
    return null;
  }
};
var VOTE_PROGRAM_ID = new PublicKey("Vote111111111111111111111111111111111111111");
var VoteAccountLayout = BufferLayout.struct([
  publicKey("nodePubkey"),
  publicKey("authorizedWithdrawer"),
  BufferLayout.u8("commission"),
  BufferLayout.nu64(),
  // votes.length
  BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64("slot"), BufferLayout.u32("confirmationCount")]), BufferLayout.offset(BufferLayout.u32(), -8), "votes"),
  BufferLayout.u8("rootSlotValid"),
  BufferLayout.nu64("rootSlot"),
  BufferLayout.nu64(),
  // authorizedVoters.length
  BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64("epoch"), publicKey("authorizedVoter")]), BufferLayout.offset(BufferLayout.u32(), -8), "authorizedVoters"),
  BufferLayout.struct([BufferLayout.seq(BufferLayout.struct([publicKey("authorizedPubkey"), BufferLayout.nu64("epochOfLastAuthorizedSwitch"), BufferLayout.nu64("targetEpoch")]), 32, "buf"), BufferLayout.nu64("idx"), BufferLayout.u8("isEmpty")], "priorVoters"),
  BufferLayout.nu64(),
  // epochCredits.length
  BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64("epoch"), BufferLayout.nu64("credits"), BufferLayout.nu64("prevCredits")]), BufferLayout.offset(BufferLayout.u32(), -8), "epochCredits"),
  BufferLayout.struct([BufferLayout.nu64("slot"), BufferLayout.nu64("timestamp")], "lastTimestamp")
]);
var VoteAccount = class {
  /**
   * @internal
   */
  constructor(args2) {
    this.nodePubkey = void 0;
    this.authorizedWithdrawer = void 0;
    this.commission = void 0;
    this.rootSlot = void 0;
    this.votes = void 0;
    this.authorizedVoters = void 0;
    this.priorVoters = void 0;
    this.epochCredits = void 0;
    this.lastTimestamp = void 0;
    this.nodePubkey = args2.nodePubkey;
    this.authorizedWithdrawer = args2.authorizedWithdrawer;
    this.commission = args2.commission;
    this.rootSlot = args2.rootSlot;
    this.votes = args2.votes;
    this.authorizedVoters = args2.authorizedVoters;
    this.priorVoters = args2.priorVoters;
    this.epochCredits = args2.epochCredits;
    this.lastTimestamp = args2.lastTimestamp;
  }
  /**
   * Deserialize VoteAccount from the account data.
   *
   * @param buffer account data
   * @return VoteAccount
   */
  static fromAccountData(buffer) {
    const versionOffset = 4;
    const va = VoteAccountLayout.decode(toBuffer(buffer), versionOffset);
    let rootSlot = va.rootSlot;
    if (!va.rootSlotValid) {
      rootSlot = null;
    }
    return new VoteAccount({
      nodePubkey: new PublicKey(va.nodePubkey),
      authorizedWithdrawer: new PublicKey(va.authorizedWithdrawer),
      commission: va.commission,
      votes: va.votes,
      rootSlot,
      authorizedVoters: va.authorizedVoters.map(parseAuthorizedVoter),
      priorVoters: getPriorVoters(va.priorVoters),
      epochCredits: va.epochCredits,
      lastTimestamp: va.lastTimestamp
    });
  }
};
function parseAuthorizedVoter({
  authorizedVoter,
  epoch
}) {
  return {
    epoch,
    authorizedVoter: new PublicKey(authorizedVoter)
  };
}
function parsePriorVoters({
  authorizedPubkey,
  epochOfLastAuthorizedSwitch,
  targetEpoch
}) {
  return {
    authorizedPubkey: new PublicKey(authorizedPubkey),
    epochOfLastAuthorizedSwitch,
    targetEpoch
  };
}
function getPriorVoters({
  buf,
  idx,
  isEmpty
}) {
  if (isEmpty) {
    return [];
  }
  return [...buf.slice(idx + 1).map(parsePriorVoters), ...buf.slice(0, idx).map(parsePriorVoters)];
}
var endpoint = {
  http: {
    devnet: "http://api.devnet.solana.com",
    testnet: "http://api.testnet.solana.com",
    "mainnet-beta": "http://api.mainnet-beta.solana.com/"
  },
  https: {
    devnet: "https://api.devnet.solana.com",
    testnet: "https://api.testnet.solana.com",
    "mainnet-beta": "https://api.mainnet-beta.solana.com/"
  }
};
function clusterApiUrl(cluster, tls) {
  const key = tls === false ? "http" : "https";
  if (!cluster) {
    return endpoint[key]["devnet"];
  }
  const url = endpoint[key][cluster];
  if (!url) {
    throw new Error(`Unknown ${key} cluster: ${cluster}`);
  }
  return url;
}
function sendAndConfirmRawTransaction(connection, rawTransaction, confirmationStrategyOrConfirmOptions, maybeConfirmOptions) {
  return __async(this, null, function* () {
    let confirmationStrategy;
    let options;
    if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, "lastValidBlockHeight")) {
      confirmationStrategy = confirmationStrategyOrConfirmOptions;
      options = maybeConfirmOptions;
    } else if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, "nonceValue")) {
      confirmationStrategy = confirmationStrategyOrConfirmOptions;
      options = maybeConfirmOptions;
    } else {
      options = confirmationStrategyOrConfirmOptions;
    }
    const sendOptions = options && {
      skipPreflight: options.skipPreflight,
      preflightCommitment: options.preflightCommitment || options.commitment,
      minContextSlot: options.minContextSlot
    };
    const signature2 = yield connection.sendRawTransaction(rawTransaction, sendOptions);
    const commitment = options && options.commitment;
    const confirmationPromise = confirmationStrategy ? connection.confirmTransaction(confirmationStrategy, commitment) : connection.confirmTransaction(signature2, commitment);
    const status = (yield confirmationPromise).value;
    if (status.err) {
      throw new Error(`Raw transaction ${signature2} failed (${JSON.stringify(status)})`);
    }
    return signature2;
  });
}
var LAMPORTS_PER_SOL = 1e9;

// ../../node_modules/@solana/spl-token/lib/esm/constants.js
var TOKEN_PROGRAM_ID = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
var TOKEN_2022_PROGRAM_ID = new PublicKey("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");
var ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
var NATIVE_MINT = new PublicKey("So11111111111111111111111111111111111111112");
var NATIVE_MINT_2022 = new PublicKey("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");

// ../../node_modules/@solana/buffer-layout-utils/lib/esm/base.mjs
var encodeDecode2 = (layout) => {
  const decode = layout.decode.bind(layout);
  const encode = layout.encode.bind(layout);
  return { decode, encode };
};

// ../../node_modules/@solana/buffer-layout-utils/lib/esm/bigint.mjs
var import_buffer_layout2 = __toESM(require_Layout(), 1);
var import_bigint_buffer2 = __toESM(require_node(), 1);
var bigInt2 = (length) => (property) => {
  const layout = (0, import_buffer_layout2.blob)(length, property);
  const { encode, decode } = encodeDecode2(layout);
  const bigIntLayout = layout;
  bigIntLayout.decode = (buffer, offset2) => {
    const src2 = decode(buffer, offset2);
    return (0, import_bigint_buffer2.toBigIntLE)(Buffer.from(src2));
  };
  bigIntLayout.encode = (bigInt3, buffer, offset2) => {
    const src2 = (0, import_bigint_buffer2.toBufferLE)(bigInt3, length);
    return encode(src2, buffer, offset2);
  };
  return bigIntLayout;
};
var bigIntBE = (length) => (property) => {
  const layout = (0, import_buffer_layout2.blob)(length, property);
  const { encode, decode } = encodeDecode2(layout);
  const bigIntLayout = layout;
  bigIntLayout.decode = (buffer, offset2) => {
    const src2 = decode(buffer, offset2);
    return (0, import_bigint_buffer2.toBigIntBE)(Buffer.from(src2));
  };
  bigIntLayout.encode = (bigInt3, buffer, offset2) => {
    const src2 = (0, import_bigint_buffer2.toBufferBE)(bigInt3, length);
    return encode(src2, buffer, offset2);
  };
  return bigIntLayout;
};
var u643 = bigInt2(8);
var u64be = bigIntBE(8);
var u128 = bigInt2(16);
var u128be = bigIntBE(16);
var u192 = bigInt2(24);
var u192be = bigIntBE(24);
var u256 = bigInt2(32);
var u256be = bigIntBE(32);

// ../../node_modules/bignumber.js/bignumber.mjs
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i;
var mathceil = Math.ceil;
var mathfloor = Math.floor;
var bignumberError = "[BigNumber Error] ";
var tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ";
var BASE = 1e14;
var LOG_BASE = 14;
var MAX_SAFE_INTEGER = 9007199254740991;
var POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13];
var SQRT_BASE = 1e7;
var MAX = 1e9;
function clone2(configObject) {
  var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "\xA0",
    // non-breaking space
    suffix: ""
  }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
  function BigNumber2(v, b) {
    var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
    if (!(x instanceof BigNumber2))
      return new BigNumber2(v, b);
    if (b == null) {
      if (v && v._isBigNumber === true) {
        x.s = v.s;
        if (!v.c || v.e > MAX_EXP) {
          x.c = x.e = null;
        } else if (v.e < MIN_EXP) {
          x.c = [x.e = 0];
        } else {
          x.e = v.e;
          x.c = v.c.slice();
        }
        return;
      }
      if ((isNum = typeof v == "number") && v * 0 == 0) {
        x.s = 1 / v < 0 ? (v = -v, -1) : 1;
        if (v === ~~v) {
          for (e = 0, i = v; i >= 10; i /= 10, e++)
            ;
          if (e > MAX_EXP) {
            x.c = x.e = null;
          } else {
            x.e = e;
            x.c = [v];
          }
          return;
        }
        str = String(v);
      } else {
        if (!isNumeric.test(str = String(v)))
          return parseNumeric(x, str, isNum);
        x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      }
      if ((e = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      if ((i = str.search(/e/i)) > 0) {
        if (e < 0)
          e = i;
        e += +str.slice(i + 1);
        str = str.substring(0, i);
      } else if (e < 0) {
        e = str.length;
      }
    } else {
      intCheck(b, 2, ALPHABET.length, "Base");
      if (b == 10 && alphabetHasNormalDecimalDigits) {
        x = new BigNumber2(v);
        return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
      }
      str = String(v);
      if (isNum = typeof v == "number") {
        if (v * 0 != 0)
          return parseNumeric(x, str, isNum, b);
        x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
        if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
          throw Error(tooManyDigits + v);
        }
      } else {
        x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }
      alphabet = ALPHABET.slice(0, b);
      e = i = 0;
      for (len = str.length; i < len; i++) {
        if (alphabet.indexOf(c = str.charAt(i)) < 0) {
          if (c == ".") {
            if (i > e) {
              e = len;
              continue;
            }
          } else if (!caseChanged) {
            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i = -1;
              e = 0;
              continue;
            }
          }
          return parseNumeric(x, String(v), isNum, b);
        }
      }
      isNum = false;
      str = convertBase(str, b, 10, x.s);
      if ((e = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      else
        e = str.length;
    }
    for (i = 0; str.charCodeAt(i) === 48; i++)
      ;
    for (len = str.length; str.charCodeAt(--len) === 48; )
      ;
    if (str = str.slice(i, ++len)) {
      len -= i;
      if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
        throw Error(tooManyDigits + x.s * v);
      }
      if ((e = e - i - 1) > MAX_EXP) {
        x.c = x.e = null;
      } else if (e < MIN_EXP) {
        x.c = [x.e = 0];
      } else {
        x.e = e;
        x.c = [];
        i = (e + 1) % LOG_BASE;
        if (e < 0)
          i += LOG_BASE;
        if (i < len) {
          if (i)
            x.c.push(+str.slice(0, i));
          for (len -= LOG_BASE; i < len; ) {
            x.c.push(+str.slice(i, i += LOG_BASE));
          }
          i = LOG_BASE - (str = str.slice(i)).length;
        } else {
          i -= len;
        }
        for (; i--; str += "0")
          ;
        x.c.push(+str);
      }
    } else {
      x.c = [x.e = 0];
    }
  }
  BigNumber2.clone = clone2;
  BigNumber2.ROUND_UP = 0;
  BigNumber2.ROUND_DOWN = 1;
  BigNumber2.ROUND_CEIL = 2;
  BigNumber2.ROUND_FLOOR = 3;
  BigNumber2.ROUND_HALF_UP = 4;
  BigNumber2.ROUND_HALF_DOWN = 5;
  BigNumber2.ROUND_HALF_EVEN = 6;
  BigNumber2.ROUND_HALF_CEIL = 7;
  BigNumber2.ROUND_HALF_FLOOR = 8;
  BigNumber2.EUCLID = 9;
  BigNumber2.config = BigNumber2.set = function(obj) {
    var p, v;
    if (obj != null) {
      if (typeof obj == "object") {
        if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          DECIMAL_PLACES = v;
        }
        if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
          v = obj[p];
          intCheck(v, 0, 8, p);
          ROUNDING_MODE = v;
        }
        if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, 0, p);
            intCheck(v[1], 0, MAX, p);
            TO_EXP_NEG = v[0];
            TO_EXP_POS = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
          }
        }
        if (obj.hasOwnProperty(p = "RANGE")) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, -1, p);
            intCheck(v[1], 1, MAX, p);
            MIN_EXP = v[0];
            MAX_EXP = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            if (v) {
              MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
            } else {
              throw Error(bignumberError + p + " cannot be zero: " + v);
            }
          }
        }
        if (obj.hasOwnProperty(p = "CRYPTO")) {
          v = obj[p];
          if (v === !!v) {
            if (v) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v;
              } else {
                CRYPTO = !v;
                throw Error(bignumberError + "crypto unavailable");
              }
            } else {
              CRYPTO = v;
            }
          } else {
            throw Error(bignumberError + p + " not true or false: " + v);
          }
        }
        if (obj.hasOwnProperty(p = "MODULO_MODE")) {
          v = obj[p];
          intCheck(v, 0, 9, p);
          MODULO_MODE = v;
        }
        if (obj.hasOwnProperty(p = "POW_PRECISION")) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          POW_PRECISION = v;
        }
        if (obj.hasOwnProperty(p = "FORMAT")) {
          v = obj[p];
          if (typeof v == "object")
            FORMAT = v;
          else
            throw Error(bignumberError + p + " not an object: " + v);
        }
        if (obj.hasOwnProperty(p = "ALPHABET")) {
          v = obj[p];
          if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
            alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
            ALPHABET = v;
          } else {
            throw Error(bignumberError + p + " invalid: " + v);
          }
        }
      } else {
        throw Error(bignumberError + "Object expected: " + obj);
      }
    }
    return {
      DECIMAL_PLACES,
      ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO,
      MODULO_MODE,
      POW_PRECISION,
      FORMAT,
      ALPHABET
    };
  };
  BigNumber2.isBigNumber = function(v) {
    if (!v || v._isBigNumber !== true)
      return false;
    if (!BigNumber2.DEBUG)
      return true;
    var i, n, c = v.c, e = v.e, s2 = v.s;
    out:
      if ({}.toString.call(c) == "[object Array]") {
        if ((s2 === 1 || s2 === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
          if (c[0] === 0) {
            if (e === 0 && c.length === 1)
              return true;
            break out;
          }
          i = (e + 1) % LOG_BASE;
          if (i < 1)
            i += LOG_BASE;
          if (String(c[0]).length == i) {
            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n))
                break out;
            }
            if (n !== 0)
              return true;
          }
        }
      } else if (c === null && e === null && (s2 === null || s2 === 1 || s2 === -1)) {
        return true;
      }
    throw Error(bignumberError + "Invalid BigNumber: " + v);
  };
  BigNumber2.maximum = BigNumber2.max = function() {
    return maxOrMin(arguments, P.lt);
  };
  BigNumber2.minimum = BigNumber2.min = function() {
    return maxOrMin(arguments, P.gt);
  };
  BigNumber2.random = function() {
    var pow2_53 = 9007199254740992;
    var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
      return mathfloor(Math.random() * pow2_53);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(dp) {
      var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
      if (dp == null)
        dp = DECIMAL_PLACES;
      else
        intCheck(dp, 0, MAX);
      k = mathceil(dp / LOG_BASE);
      if (CRYPTO) {
        if (crypto.getRandomValues) {
          a = crypto.getRandomValues(new Uint32Array(k *= 2));
          for (; i < k; ) {
            v = a[i] * 131072 + (a[i + 1] >>> 11);
            if (v >= 9e15) {
              b = crypto.getRandomValues(new Uint32Array(2));
              a[i] = b[0];
              a[i + 1] = b[1];
            } else {
              c.push(v % 1e14);
              i += 2;
            }
          }
          i = k / 2;
        } else if (crypto.randomBytes) {
          a = crypto.randomBytes(k *= 7);
          for (; i < k; ) {
            v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
            if (v >= 9e15) {
              crypto.randomBytes(7).copy(a, i);
            } else {
              c.push(v % 1e14);
              i += 7;
            }
          }
          i = k / 7;
        } else {
          CRYPTO = false;
          throw Error(bignumberError + "crypto unavailable");
        }
      }
      if (!CRYPTO) {
        for (; i < k; ) {
          v = random53bitInt();
          if (v < 9e15)
            c[i++] = v % 1e14;
        }
      }
      k = c[--i];
      dp %= LOG_BASE;
      if (k && dp) {
        v = POWS_TEN[LOG_BASE - dp];
        c[i] = mathfloor(k / v) * v;
      }
      for (; c[i] === 0; c.pop(), i--)
        ;
      if (i < 0) {
        c = [e = 0];
      } else {
        for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
          ;
        for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
          ;
        if (i < LOG_BASE)
          e -= LOG_BASE - i;
      }
      rand.e = e;
      rand.c = c;
      return rand;
    };
  }();
  BigNumber2.sum = function() {
    var i = 1, args2 = arguments, sum = new BigNumber2(args2[0]);
    for (; i < args2.length; )
      sum = sum.plus(args2[i++]);
    return sum;
  };
  convertBase = function() {
    var decimal = "0123456789";
    function toBaseOut(str, baseIn, baseOut, alphabet) {
      var j, arr = [0], arrL, i = 0, len = str.length;
      for (; i < len; ) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
          ;
        arr[0] += alphabet.indexOf(str.charAt(i++));
        for (j = 0; j < arr.length; j++) {
          if (arr[j] > baseOut - 1) {
            if (arr[j + 1] == null)
              arr[j + 1] = 0;
            arr[j + 1] += arr[j] / baseOut | 0;
            arr[j] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    return function(str, baseIn, baseOut, sign2, callerIsToString) {
      var alphabet, d2, e, k, r, x, xc, y2, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
      if (i >= 0) {
        k = POW_PRECISION;
        POW_PRECISION = 0;
        str = str.replace(".", "");
        y2 = new BigNumber2(baseIn);
        x = y2.pow(str.length - i);
        POW_PRECISION = k;
        y2.c = toBaseOut(
          toFixedPoint(coeffToString(x.c), x.e, "0"),
          10,
          baseOut,
          decimal
        );
        y2.e = y2.c.length;
      }
      xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
      e = k = xc.length;
      for (; xc[--k] == 0; xc.pop())
        ;
      if (!xc[0])
        return alphabet.charAt(0);
      if (i < 0) {
        --e;
      } else {
        x.c = xc;
        x.e = e;
        x.s = sign2;
        x = div(x, y2, dp, rm, baseOut);
        xc = x.c;
        r = x.r;
        e = x.e;
      }
      d2 = e + dp + 1;
      i = xc[d2];
      k = baseOut / 2;
      r = r || d2 < 0 || xc[d2 + 1] != null;
      r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d2 - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
      if (d2 < 1 || !xc[0]) {
        str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
      } else {
        xc.length = d2;
        if (r) {
          for (--baseOut; ++xc[--d2] > baseOut; ) {
            xc[d2] = 0;
            if (!d2) {
              ++e;
              xc = [1].concat(xc);
            }
          }
        }
        for (k = xc.length; !xc[--k]; )
          ;
        for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++]))
          ;
        str = toFixedPoint(str, e, alphabet.charAt(0));
      }
      return str;
    };
  }();
  div = function() {
    function multiply(x, k, base) {
      var m2, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
      for (x = x.slice(); i--; ) {
        xlo = x[i] % SQRT_BASE;
        xhi = x[i] / SQRT_BASE | 0;
        m2 = khi * xlo + xhi * klo;
        temp = klo * xlo + m2 % SQRT_BASE * SQRT_BASE + carry;
        carry = (temp / base | 0) + (m2 / SQRT_BASE | 0) + khi * xhi;
        x[i] = temp % base;
      }
      if (carry)
        x = [carry].concat(x);
      return x;
    }
    function compare2(a, b, aL, bL) {
      var i, cmp;
      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {
        for (i = cmp = 0; i < aL; i++) {
          if (a[i] != b[i]) {
            cmp = a[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }
      return cmp;
    }
    function subtract(a, b, aL, base) {
      var i = 0;
      for (; aL--; ) {
        a[aL] -= i;
        i = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i * base + a[aL] - b[aL];
      }
      for (; !a[0] && a.length > 1; a.splice(0, 1))
        ;
    }
    return function(x, y2, dp, rm, base) {
      var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s2 = x.s == y2.s ? 1 : -1, xc = x.c, yc = y2.c;
      if (!xc || !xc[0] || !yc || !yc[0]) {
        return new BigNumber2(
          // Return NaN if either NaN, or both Infinity or 0.
          !x.s || !y2.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            xc && xc[0] == 0 || !yc ? s2 * 0 : s2 / 0
          )
        );
      }
      q = new BigNumber2(s2);
      qc = q.c = [];
      e = x.e - y2.e;
      s2 = dp + e + 1;
      if (!base) {
        base = BASE;
        e = bitFloor(x.e / LOG_BASE) - bitFloor(y2.e / LOG_BASE);
        s2 = s2 / LOG_BASE | 0;
      }
      for (i = 0; yc[i] == (xc[i] || 0); i++)
        ;
      if (yc[i] > (xc[i] || 0))
        e--;
      if (s2 < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i = 0;
        s2 += 2;
        n = mathfloor(base / (yc[0] + 1));
        if (n > 1) {
          yc = multiply(yc, n, base);
          xc = multiply(xc, n, base);
          yL = yc.length;
          xL = xc.length;
        }
        xi = yL;
        rem = xc.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; rem[remL++] = 0)
          ;
        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base / 2)
          yc0++;
        do {
          n = 0;
          cmp = compare2(yc, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base + (rem[1] || 0);
            n = mathfloor(rem0 / yc0);
            if (n > 1) {
              if (n >= base)
                n = base - 1;
              prod = multiply(yc, n, base);
              prodL = prod.length;
              remL = rem.length;
              while (compare2(prod, rem, prodL, remL) == 1) {
                n--;
                subtract(prod, yL < prodL ? yz : yc, prodL, base);
                prodL = prod.length;
                cmp = 1;
              }
            } else {
              if (n == 0) {
                cmp = n = 1;
              }
              prod = yc.slice();
              prodL = prod.length;
            }
            if (prodL < remL)
              prod = [0].concat(prod);
            subtract(rem, prod, remL, base);
            remL = rem.length;
            if (cmp == -1) {
              while (compare2(yc, rem, yL, remL) < 1) {
                n++;
                subtract(rem, yL < remL ? yz : yc, remL, base);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n++;
            rem = [0];
          }
          qc[i++] = n;
          if (rem[0]) {
            rem[remL++] = xc[xi] || 0;
          } else {
            rem = [xc[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] != null) && s2--);
        more = rem[0] != null;
        if (!qc[0])
          qc.splice(0, 1);
      }
      if (base == BASE) {
        for (i = 1, s2 = qc[0]; s2 >= 10; s2 /= 10, i++)
          ;
        round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
      } else {
        q.e = e;
        q.r = +more;
      }
      return q;
    };
  }();
  function format(n, i, rm, id) {
    var c0, e, ne, len, str;
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    if (!n.c)
      return n.toString();
    c0 = n.c[0];
    ne = n.e;
    if (i == null) {
      str = coeffToString(n.c);
      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
    } else {
      n = round(new BigNumber2(n), i, rm);
      e = n.e;
      str = coeffToString(n.c);
      len = str.length;
      if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
        for (; len < i; str += "0", len++)
          ;
        str = toExponential(str, e);
      } else {
        i -= ne;
        str = toFixedPoint(str, e, "0");
        if (e + 1 > len) {
          if (--i > 0)
            for (str += "."; i--; str += "0")
              ;
        } else {
          i += e - len;
          if (i > 0) {
            if (e + 1 == len)
              str += ".";
            for (; i--; str += "0")
              ;
          }
        }
      }
    }
    return n.s < 0 && c0 ? "-" + str : str;
  }
  function maxOrMin(args2, method) {
    var n, i = 1, m2 = new BigNumber2(args2[0]);
    for (; i < args2.length; i++) {
      n = new BigNumber2(args2[i]);
      if (!n.s) {
        m2 = n;
        break;
      } else if (method.call(m2, n)) {
        m2 = n;
      }
    }
    return m2;
  }
  function normalise(n, c, e) {
    var i = 1, j = c.length;
    for (; !c[--j]; c.pop())
      ;
    for (j = c[0]; j >= 10; j /= 10, i++)
      ;
    if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
      n.c = n.e = null;
    } else if (e < MIN_EXP) {
      n.c = [n.e = 0];
    } else {
      n.e = e;
      n.c = c;
    }
    return n;
  }
  parseNumeric = function() {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(x, str, isNum, b) {
      var base, s2 = isNum ? str : str.replace(whitespaceOrPlus, "");
      if (isInfinityOrNaN.test(s2)) {
        x.s = isNaN(s2) ? null : s2 < 0 ? -1 : 1;
      } else {
        if (!isNum) {
          s2 = s2.replace(basePrefix, function(m2, p1, p2) {
            base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
            return !b || b == base ? p1 : m2;
          });
          if (b) {
            base = b;
            s2 = s2.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
          }
          if (str != s2)
            return new BigNumber2(s2, base);
        }
        if (BigNumber2.DEBUG) {
          throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
        }
        x.s = null;
      }
      x.c = x.e = null;
    };
  }();
  function round(x, sd, rm, r) {
    var d2, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
    if (xc) {
      out: {
        for (d2 = 1, k = xc[0]; k >= 10; k /= 10, d2++)
          ;
        i = sd - d2;
        if (i < 0) {
          i += LOG_BASE;
          j = sd;
          n = xc[ni = 0];
          rd = n / pows10[d2 - j - 1] % 10 | 0;
        } else {
          ni = mathceil((i + 1) / LOG_BASE);
          if (ni >= xc.length) {
            if (r) {
              for (; xc.length <= ni; xc.push(0))
                ;
              n = rd = 0;
              d2 = 1;
              i %= LOG_BASE;
              j = i - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n = k = xc[ni];
            for (d2 = 1; k >= 10; k /= 10, d2++)
              ;
            i %= LOG_BASE;
            j = i - LOG_BASE + d2;
            rd = j < 0 ? 0 : n / pows10[d2 - j - 1] % 10 | 0;
          }
        }
        r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        xc[ni + 1] != null || (j < 0 ? n : n % pows10[d2 - j - 1]);
        r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (i > 0 ? j > 0 ? n / pows10[d2 - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
        if (sd < 1 || !xc[0]) {
          xc.length = 0;
          if (r) {
            sd -= x.e + 1;
            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x.e = -sd || 0;
          } else {
            xc[0] = x.e = 0;
          }
          return x;
        }
        if (i == 0) {
          xc.length = ni;
          k = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k = pows10[LOG_BASE - i];
          xc[ni] = j > 0 ? mathfloor(n / pows10[d2 - j] % pows10[j]) * k : 0;
        }
        if (r) {
          for (; ; ) {
            if (ni == 0) {
              for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                ;
              j = xc[0] += k;
              for (k = 1; j >= 10; j /= 10, k++)
                ;
              if (i != k) {
                x.e++;
                if (xc[0] == BASE)
                  xc[0] = 1;
              }
              break;
            } else {
              xc[ni] += k;
              if (xc[ni] != BASE)
                break;
              xc[ni--] = 0;
              k = 1;
            }
          }
        }
        for (i = xc.length; xc[--i] === 0; xc.pop())
          ;
      }
      if (x.e > MAX_EXP) {
        x.c = x.e = null;
      } else if (x.e < MIN_EXP) {
        x.c = [x.e = 0];
      }
    }
    return x;
  }
  function valueOf(n) {
    var str, e = n.e;
    if (e === null)
      return n.toString();
    str = coeffToString(n.c);
    str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
    return n.s < 0 ? "-" + str : str;
  }
  P.absoluteValue = P.abs = function() {
    var x = new BigNumber2(this);
    if (x.s < 0)
      x.s = 1;
    return x;
  };
  P.comparedTo = function(y2, b) {
    return compare(this, new BigNumber2(y2, b));
  };
  P.decimalPlaces = P.dp = function(dp, rm) {
    var c, n, v, x = this;
    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(new BigNumber2(x), dp + x.e + 1, rm);
    }
    if (!(c = x.c))
      return null;
    n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
    if (v = c[v])
      for (; v % 10 == 0; v /= 10, n--)
        ;
    if (n < 0)
      n = 0;
    return n;
  };
  P.dividedBy = P.div = function(y2, b) {
    return div(this, new BigNumber2(y2, b), DECIMAL_PLACES, ROUNDING_MODE);
  };
  P.dividedToIntegerBy = P.idiv = function(y2, b) {
    return div(this, new BigNumber2(y2, b), 0, 1);
  };
  P.exponentiatedBy = P.pow = function(n, m2) {
    var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y2, x = this;
    n = new BigNumber2(n);
    if (n.c && !n.isInteger()) {
      throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
    }
    if (m2 != null)
      m2 = new BigNumber2(m2);
    nIsBig = n.e > 14;
    if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
      y2 = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
      return m2 ? y2.mod(m2) : y2;
    }
    nIsNeg = n.s < 0;
    if (m2) {
      if (m2.c ? !m2.c[0] : !m2.s)
        return new BigNumber2(NaN);
      isModExp = !nIsNeg && x.isInteger() && m2.isInteger();
      if (isModExp)
        x = x.mod(m2);
    } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
      k = x.s < 0 && isOdd(n) ? -0 : 0;
      if (x.e > -1)
        k = 1 / k;
      return new BigNumber2(nIsNeg ? 1 / k : k);
    } else if (POW_PRECISION) {
      k = mathceil(POW_PRECISION / LOG_BASE + 2);
    }
    if (nIsBig) {
      half = new BigNumber2(0.5);
      if (nIsNeg)
        n.s = 1;
      nIsOdd = isOdd(n);
    } else {
      i = Math.abs(+valueOf(n));
      nIsOdd = i % 2;
    }
    y2 = new BigNumber2(ONE);
    for (; ; ) {
      if (nIsOdd) {
        y2 = y2.times(x);
        if (!y2.c)
          break;
        if (k) {
          if (y2.c.length > k)
            y2.c.length = k;
        } else if (isModExp) {
          y2 = y2.mod(m2);
        }
      }
      if (i) {
        i = mathfloor(i / 2);
        if (i === 0)
          break;
        nIsOdd = i % 2;
      } else {
        n = n.times(half);
        round(n, n.e + 1, 1);
        if (n.e > 14) {
          nIsOdd = isOdd(n);
        } else {
          i = +valueOf(n);
          if (i === 0)
            break;
          nIsOdd = i % 2;
        }
      }
      x = x.times(x);
      if (k) {
        if (x.c && x.c.length > k)
          x.c.length = k;
      } else if (isModExp) {
        x = x.mod(m2);
      }
    }
    if (isModExp)
      return y2;
    if (nIsNeg)
      y2 = ONE.div(y2);
    return m2 ? y2.mod(m2) : k ? round(y2, POW_PRECISION, ROUNDING_MODE, more) : y2;
  };
  P.integerValue = function(rm) {
    var n = new BigNumber2(this);
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    return round(n, n.e + 1, rm);
  };
  P.isEqualTo = P.eq = function(y2, b) {
    return compare(this, new BigNumber2(y2, b)) === 0;
  };
  P.isFinite = function() {
    return !!this.c;
  };
  P.isGreaterThan = P.gt = function(y2, b) {
    return compare(this, new BigNumber2(y2, b)) > 0;
  };
  P.isGreaterThanOrEqualTo = P.gte = function(y2, b) {
    return (b = compare(this, new BigNumber2(y2, b))) === 1 || b === 0;
  };
  P.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };
  P.isLessThan = P.lt = function(y2, b) {
    return compare(this, new BigNumber2(y2, b)) < 0;
  };
  P.isLessThanOrEqualTo = P.lte = function(y2, b) {
    return (b = compare(this, new BigNumber2(y2, b))) === -1 || b === 0;
  };
  P.isNaN = function() {
    return !this.s;
  };
  P.isNegative = function() {
    return this.s < 0;
  };
  P.isPositive = function() {
    return this.s > 0;
  };
  P.isZero = function() {
    return !!this.c && this.c[0] == 0;
  };
  P.minus = function(y2, b) {
    var i, j, t, xLTy, x = this, a = x.s;
    y2 = new BigNumber2(y2, b);
    b = y2.s;
    if (!a || !b)
      return new BigNumber2(NaN);
    if (a != b) {
      y2.s = -b;
      return x.plus(y2);
    }
    var xe = x.e / LOG_BASE, ye = y2.e / LOG_BASE, xc = x.c, yc = y2.c;
    if (!xe || !ye) {
      if (!xc || !yc)
        return xc ? (y2.s = -b, y2) : new BigNumber2(yc ? x : NaN);
      if (!xc[0] || !yc[0]) {
        return yc[0] ? (y2.s = -b, y2) : new BigNumber2(xc[0] ? x : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ROUNDING_MODE == 3 ? -0 : 0
        ));
      }
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a = xe - ye) {
      if (xLTy = a < 0) {
        a = -a;
        t = xc;
      } else {
        ye = xe;
        t = yc;
      }
      t.reverse();
      for (b = a; b--; t.push(0))
        ;
      t.reverse();
    } else {
      j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
      for (a = b = 0; b < j; b++) {
        if (xc[b] != yc[b]) {
          xLTy = xc[b] < yc[b];
          break;
        }
      }
    }
    if (xLTy)
      t = xc, xc = yc, yc = t, y2.s = -y2.s;
    b = (j = yc.length) - (i = xc.length);
    if (b > 0)
      for (; b--; xc[i++] = 0)
        ;
    b = BASE - 1;
    for (; j > a; ) {
      if (xc[--j] < yc[j]) {
        for (i = j; i && !xc[--i]; xc[i] = b)
          ;
        --xc[i];
        xc[j] += BASE;
      }
      xc[j] -= yc[j];
    }
    for (; xc[0] == 0; xc.splice(0, 1), --ye)
      ;
    if (!xc[0]) {
      y2.s = ROUNDING_MODE == 3 ? -1 : 1;
      y2.c = [y2.e = 0];
      return y2;
    }
    return normalise(y2, xc, ye);
  };
  P.modulo = P.mod = function(y2, b) {
    var q, s2, x = this;
    y2 = new BigNumber2(y2, b);
    if (!x.c || !y2.s || y2.c && !y2.c[0]) {
      return new BigNumber2(NaN);
    } else if (!y2.c || x.c && !x.c[0]) {
      return new BigNumber2(x);
    }
    if (MODULO_MODE == 9) {
      s2 = y2.s;
      y2.s = 1;
      q = div(x, y2, 0, 3);
      y2.s = s2;
      q.s *= s2;
    } else {
      q = div(x, y2, 0, MODULO_MODE);
    }
    y2 = x.minus(q.times(y2));
    if (!y2.c[0] && MODULO_MODE == 1)
      y2.s = x.s;
    return y2;
  };
  P.multipliedBy = P.times = function(y2, b) {
    var c, e, i, j, k, m2, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y2 = new BigNumber2(y2, b)).c;
    if (!xc || !yc || !xc[0] || !yc[0]) {
      if (!x.s || !y2.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y2.c = y2.e = y2.s = null;
      } else {
        y2.s *= x.s;
        if (!xc || !yc) {
          y2.c = y2.e = null;
        } else {
          y2.c = [0];
          y2.e = 0;
        }
      }
      return y2;
    }
    e = bitFloor(x.e / LOG_BASE) + bitFloor(y2.e / LOG_BASE);
    y2.s *= x.s;
    xcL = xc.length;
    ycL = yc.length;
    if (xcL < ycL)
      zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;
    for (i = xcL + ycL, zc = []; i--; zc.push(0))
      ;
    base = BASE;
    sqrtBase = SQRT_BASE;
    for (i = ycL; --i >= 0; ) {
      c = 0;
      ylo = yc[i] % sqrtBase;
      yhi = yc[i] / sqrtBase | 0;
      for (k = xcL, j = i + k; j > i; ) {
        xlo = xc[--k] % sqrtBase;
        xhi = xc[k] / sqrtBase | 0;
        m2 = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + m2 % sqrtBase * sqrtBase + zc[j] + c;
        c = (xlo / base | 0) + (m2 / sqrtBase | 0) + yhi * xhi;
        zc[j--] = xlo % base;
      }
      zc[j] = c;
    }
    if (c) {
      ++e;
    } else {
      zc.splice(0, 1);
    }
    return normalise(y2, zc, e);
  };
  P.negated = function() {
    var x = new BigNumber2(this);
    x.s = -x.s || null;
    return x;
  };
  P.plus = function(y2, b) {
    var t, x = this, a = x.s;
    y2 = new BigNumber2(y2, b);
    b = y2.s;
    if (!a || !b)
      return new BigNumber2(NaN);
    if (a != b) {
      y2.s = -b;
      return x.minus(y2);
    }
    var xe = x.e / LOG_BASE, ye = y2.e / LOG_BASE, xc = x.c, yc = y2.c;
    if (!xe || !ye) {
      if (!xc || !yc)
        return new BigNumber2(a / 0);
      if (!xc[0] || !yc[0])
        return yc[0] ? y2 : new BigNumber2(xc[0] ? x : a * 0);
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a = xe - ye) {
      if (a > 0) {
        ye = xe;
        t = yc;
      } else {
        a = -a;
        t = xc;
      }
      t.reverse();
      for (; a--; t.push(0))
        ;
      t.reverse();
    }
    a = xc.length;
    b = yc.length;
    if (a - b < 0)
      t = yc, yc = xc, xc = t, b = a;
    for (a = 0; b; ) {
      a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
      xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
    }
    if (a) {
      xc = [a].concat(xc);
      ++ye;
    }
    return normalise(y2, xc, ye);
  };
  P.precision = P.sd = function(sd, rm) {
    var c, n, v, x = this;
    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(new BigNumber2(x), sd, rm);
    }
    if (!(c = x.c))
      return null;
    v = c.length - 1;
    n = v * LOG_BASE + 1;
    if (v = c[v]) {
      for (; v % 10 == 0; v /= 10, n--)
        ;
      for (v = c[0]; v >= 10; v /= 10, n++)
        ;
    }
    if (sd && x.e + 1 > n)
      n = x.e + 1;
    return n;
  };
  P.shiftedBy = function(k) {
    intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times("1e" + k);
  };
  P.squareRoot = P.sqrt = function() {
    var m2, n, r, rep, t, x = this, c = x.c, s2 = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
    if (s2 !== 1 || !c || !c[0]) {
      return new BigNumber2(!s2 || s2 < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
    }
    s2 = Math.sqrt(+valueOf(x));
    if (s2 == 0 || s2 == 1 / 0) {
      n = coeffToString(c);
      if ((n.length + e) % 2 == 0)
        n += "0";
      s2 = Math.sqrt(+n);
      e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
      if (s2 == 1 / 0) {
        n = "5e" + e;
      } else {
        n = s2.toExponential();
        n = n.slice(0, n.indexOf("e") + 1) + e;
      }
      r = new BigNumber2(n);
    } else {
      r = new BigNumber2(s2 + "");
    }
    if (r.c[0]) {
      e = r.e;
      s2 = e + dp;
      if (s2 < 3)
        s2 = 0;
      for (; ; ) {
        t = r;
        r = half.times(t.plus(div(x, t, dp, 1)));
        if (coeffToString(t.c).slice(0, s2) === (n = coeffToString(r.c)).slice(0, s2)) {
          if (r.e < e)
            --s2;
          n = n.slice(s2 - 3, s2 + 1);
          if (n == "9999" || !rep && n == "4999") {
            if (!rep) {
              round(t, t.e + DECIMAL_PLACES + 2, 0);
              if (t.times(t).eq(x)) {
                r = t;
                break;
              }
            }
            dp += 4;
            s2 += 4;
            rep = 1;
          } else {
            if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
              round(r, r.e + DECIMAL_PLACES + 2, 1);
              m2 = !r.times(r).eq(x);
            }
            break;
          }
        }
      }
    }
    return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m2);
  };
  P.toExponential = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format(this, dp, rm, 1);
  };
  P.toFixed = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format(this, dp, rm);
  };
  P.toFormat = function(dp, rm, format2) {
    var str, x = this;
    if (format2 == null) {
      if (dp != null && rm && typeof rm == "object") {
        format2 = rm;
        rm = null;
      } else if (dp && typeof dp == "object") {
        format2 = dp;
        dp = rm = null;
      } else {
        format2 = FORMAT;
      }
    } else if (typeof format2 != "object") {
      throw Error(bignumberError + "Argument not an object: " + format2);
    }
    str = x.toFixed(dp, rm);
    if (x.c) {
      var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
      if (g2)
        i = g1, g1 = g2, g2 = i, len -= i;
      if (g1 > 0 && len > 0) {
        i = len % g1 || g1;
        intPart = intDigits.substr(0, i);
        for (; i < len; i += g1)
          intPart += groupSeparator + intDigits.substr(i, g1);
        if (g2 > 0)
          intPart += groupSeparator + intDigits.slice(i);
        if (isNeg)
          intPart = "-" + intPart;
      }
      str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
        new RegExp("\\d{" + g2 + "}\\B", "g"),
        "$&" + (format2.fractionGroupSeparator || "")
      ) : fractionPart) : intPart;
    }
    return (format2.prefix || "") + str + (format2.suffix || "");
  };
  P.toFraction = function(md) {
    var d2, d0, d1, d22, e, exp, n, n0, n1, q, r, s2, x = this, xc = x.c;
    if (md != null) {
      n = new BigNumber2(md);
      if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
        throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
      }
    }
    if (!xc)
      return new BigNumber2(x);
    d2 = new BigNumber2(ONE);
    n1 = d0 = new BigNumber2(ONE);
    d1 = n0 = new BigNumber2(ONE);
    s2 = coeffToString(xc);
    e = d2.e = s2.length - x.e - 1;
    d2.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
    md = !md || n.comparedTo(d2) > 0 ? e > 0 ? d2 : n1 : n;
    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n = new BigNumber2(s2);
    n0.c[0] = 0;
    for (; ; ) {
      q = div(n, d2, 0, 1);
      d22 = d0.plus(q.times(d1));
      if (d22.comparedTo(md) == 1)
        break;
      d0 = d1;
      d1 = d22;
      n1 = n0.plus(q.times(d22 = n1));
      n0 = d22;
      d2 = n.minus(q.times(d22 = d2));
      n = d22;
    }
    d22 = div(md.minus(d0), d1, 0, 1);
    n0 = n0.plus(d22.times(n1));
    d0 = d0.plus(d22.times(d1));
    n0.s = n1.s = x.s;
    e = e * 2;
    r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
      div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
    ) < 1 ? [n1, d1] : [n0, d0];
    MAX_EXP = exp;
    return r;
  };
  P.toNumber = function() {
    return +valueOf(this);
  };
  P.toPrecision = function(sd, rm) {
    if (sd != null)
      intCheck(sd, 1, MAX);
    return format(this, sd, rm, 2);
  };
  P.toString = function(b) {
    var str, n = this, s2 = n.s, e = n.e;
    if (e === null) {
      if (s2) {
        str = "Infinity";
        if (s2 < 0)
          str = "-" + str;
      } else {
        str = "NaN";
      }
    } else {
      if (b == null) {
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
      } else if (b === 10 && alphabetHasNormalDecimalDigits) {
        n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n.c), n.e, "0");
      } else {
        intCheck(b, 2, ALPHABET.length, "Base");
        str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s2, true);
      }
      if (s2 < 0 && n.c[0])
        str = "-" + str;
    }
    return str;
  };
  P.valueOf = P.toJSON = function() {
    return valueOf(this);
  };
  P._isBigNumber = true;
  P[Symbol.toStringTag] = "BigNumber";
  P[Symbol.for("nodejs.util.inspect.custom")] = P.valueOf;
  if (configObject != null)
    BigNumber2.set(configObject);
  return BigNumber2;
}
function bitFloor(n) {
  var i = n | 0;
  return n > 0 || n === i ? i : i - 1;
}
function coeffToString(a) {
  var s2, z2, i = 1, j = a.length, r = a[0] + "";
  for (; i < j; ) {
    s2 = a[i++] + "";
    z2 = LOG_BASE - s2.length;
    for (; z2--; s2 = "0" + s2)
      ;
    r += s2;
  }
  for (j = r.length; r.charCodeAt(--j) === 48; )
    ;
  return r.slice(0, j + 1 || 1);
}
function compare(x, y2) {
  var a, b, xc = x.c, yc = y2.c, i = x.s, j = y2.s, k = x.e, l = y2.e;
  if (!i || !j)
    return null;
  a = xc && !xc[0];
  b = yc && !yc[0];
  if (a || b)
    return a ? b ? 0 : -j : i;
  if (i != j)
    return i;
  a = i < 0;
  b = k == l;
  if (!xc || !yc)
    return b ? 0 : !xc ^ a ? 1 : -1;
  if (!b)
    return k > l ^ a ? 1 : -1;
  j = (k = xc.length) < (l = yc.length) ? k : l;
  for (i = 0; i < j; i++)
    if (xc[i] != yc[i])
      return xc[i] > yc[i] ^ a ? 1 : -1;
  return k == l ? 0 : k > l ^ a ? 1 : -1;
}
function intCheck(n, min, max, name) {
  if (n < min || n > max || n !== mathfloor(n)) {
    throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
  }
}
function isOdd(n) {
  var k = n.c.length - 1;
  return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
}
function toExponential(str, e) {
  return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
}
function toFixedPoint(str, e, z2) {
  var len, zs;
  if (e < 0) {
    for (zs = z2 + "."; ++e; zs += z2)
      ;
    str = zs + str;
  } else {
    len = str.length;
    if (++e > len) {
      for (zs = z2, e -= len; --e; zs += z2)
        ;
      str += zs;
    } else if (e < len) {
      str = str.slice(0, e) + "." + str.slice(e);
    }
  }
  return str;
}
var BigNumber = clone2();
var bignumber_default = BigNumber;

// ../../node_modules/@solana/buffer-layout-utils/lib/esm/decimal.mjs
var WAD = new bignumber_default("1e+18");

// ../../node_modules/@solana/buffer-layout-utils/lib/esm/native.mjs
var import_buffer_layout3 = __toESM(require_Layout(), 1);
var bool2 = (property) => {
  const layout = (0, import_buffer_layout3.u8)(property);
  const { encode, decode } = encodeDecode2(layout);
  const boolLayout = layout;
  boolLayout.decode = (buffer, offset2) => {
    const src2 = decode(buffer, offset2);
    return !!src2;
  };
  boolLayout.encode = (bool3, buffer, offset2) => {
    const src2 = Number(bool3);
    return encode(src2, buffer, offset2);
  };
  return boolLayout;
};

// ../../node_modules/@solana/buffer-layout-utils/lib/esm/web3.mjs
var import_buffer_layout4 = __toESM(require_Layout(), 1);
var publicKey2 = (property) => {
  const layout = (0, import_buffer_layout4.blob)(32, property);
  const { encode, decode } = encodeDecode2(layout);
  const publicKeyLayout = layout;
  publicKeyLayout.decode = (buffer, offset2) => {
    const src2 = decode(buffer, offset2);
    return new PublicKey(src2);
  };
  publicKeyLayout.encode = (publicKey3, buffer, offset2) => {
    const src2 = publicKey3.toBuffer();
    return encode(src2, buffer, offset2);
  };
  return publicKeyLayout;
};

// ../../node_modules/@solana/spl-token/lib/esm/errors.js
var TokenError = class extends Error {
  constructor(message2) {
    super(message2);
  }
};
var TokenAccountNotFoundError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenAccountNotFoundError";
  }
};
var TokenInvalidAccountOwnerError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidAccountOwnerError";
  }
};
var TokenInvalidAccountSizeError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidAccountSizeError";
  }
};
var TokenInvalidMintError = class extends TokenError {
  constructor() {
    super(...arguments);
    this.name = "TokenInvalidMintError";
  }
};

// ../../node_modules/@solana/spl-token/lib/esm/instructions/types.js
var TokenInstruction;
(function(TokenInstruction2) {
  TokenInstruction2[TokenInstruction2["InitializeMint"] = 0] = "InitializeMint";
  TokenInstruction2[TokenInstruction2["InitializeAccount"] = 1] = "InitializeAccount";
  TokenInstruction2[TokenInstruction2["InitializeMultisig"] = 2] = "InitializeMultisig";
  TokenInstruction2[TokenInstruction2["Transfer"] = 3] = "Transfer";
  TokenInstruction2[TokenInstruction2["Approve"] = 4] = "Approve";
  TokenInstruction2[TokenInstruction2["Revoke"] = 5] = "Revoke";
  TokenInstruction2[TokenInstruction2["SetAuthority"] = 6] = "SetAuthority";
  TokenInstruction2[TokenInstruction2["MintTo"] = 7] = "MintTo";
  TokenInstruction2[TokenInstruction2["Burn"] = 8] = "Burn";
  TokenInstruction2[TokenInstruction2["CloseAccount"] = 9] = "CloseAccount";
  TokenInstruction2[TokenInstruction2["FreezeAccount"] = 10] = "FreezeAccount";
  TokenInstruction2[TokenInstruction2["ThawAccount"] = 11] = "ThawAccount";
  TokenInstruction2[TokenInstruction2["TransferChecked"] = 12] = "TransferChecked";
  TokenInstruction2[TokenInstruction2["ApproveChecked"] = 13] = "ApproveChecked";
  TokenInstruction2[TokenInstruction2["MintToChecked"] = 14] = "MintToChecked";
  TokenInstruction2[TokenInstruction2["BurnChecked"] = 15] = "BurnChecked";
  TokenInstruction2[TokenInstruction2["InitializeAccount2"] = 16] = "InitializeAccount2";
  TokenInstruction2[TokenInstruction2["SyncNative"] = 17] = "SyncNative";
  TokenInstruction2[TokenInstruction2["InitializeAccount3"] = 18] = "InitializeAccount3";
  TokenInstruction2[TokenInstruction2["InitializeMultisig2"] = 19] = "InitializeMultisig2";
  TokenInstruction2[TokenInstruction2["InitializeMint2"] = 20] = "InitializeMint2";
  TokenInstruction2[TokenInstruction2["GetAccountDataSize"] = 21] = "GetAccountDataSize";
  TokenInstruction2[TokenInstruction2["InitializeImmutableOwner"] = 22] = "InitializeImmutableOwner";
  TokenInstruction2[TokenInstruction2["AmountToUiAmount"] = 23] = "AmountToUiAmount";
  TokenInstruction2[TokenInstruction2["UiAmountToAmount"] = 24] = "UiAmountToAmount";
  TokenInstruction2[TokenInstruction2["InitializeMintCloseAuthority"] = 25] = "InitializeMintCloseAuthority";
  TokenInstruction2[TokenInstruction2["TransferFeeExtension"] = 26] = "TransferFeeExtension";
  TokenInstruction2[TokenInstruction2["ConfidentialTransferExtension"] = 27] = "ConfidentialTransferExtension";
  TokenInstruction2[TokenInstruction2["DefaultAccountStateExtension"] = 28] = "DefaultAccountStateExtension";
  TokenInstruction2[TokenInstruction2["Reallocate"] = 29] = "Reallocate";
  TokenInstruction2[TokenInstruction2["MemoTransferExtension"] = 30] = "MemoTransferExtension";
  TokenInstruction2[TokenInstruction2["CreateNativeMint"] = 31] = "CreateNativeMint";
  TokenInstruction2[TokenInstruction2["InitializeNonTransferableMint"] = 32] = "InitializeNonTransferableMint";
  TokenInstruction2[TokenInstruction2["InterestBearingMintExtension"] = 33] = "InterestBearingMintExtension";
  TokenInstruction2[TokenInstruction2["CpiGuardExtension"] = 34] = "CpiGuardExtension";
  TokenInstruction2[TokenInstruction2["InitializePermanentDelegate"] = 35] = "InitializePermanentDelegate";
})(TokenInstruction || (TokenInstruction = {}));

// ../../node_modules/@solana/spl-token/lib/esm/instructions/internal.js
function addSigners(keys, ownerOrAuthority, multiSigners) {
  if (multiSigners.length) {
    keys.push({ pubkey: ownerOrAuthority, isSigner: false, isWritable: false });
    for (const signer of multiSigners) {
      keys.push({
        pubkey: signer instanceof PublicKey ? signer : signer.publicKey,
        isSigner: true,
        isWritable: false
      });
    }
  } else {
    keys.push({ pubkey: ownerOrAuthority, isSigner: true, isWritable: false });
  }
  return keys;
}

// ../../node_modules/@solana/spl-token/lib/esm/state/account.js
var import_buffer_layout6 = __toESM(require_Layout(), 1);

// ../../node_modules/@solana/spl-token/lib/esm/extensions/accountType.js
var AccountType;
(function(AccountType2) {
  AccountType2[AccountType2["Uninitialized"] = 0] = "Uninitialized";
  AccountType2[AccountType2["Mint"] = 1] = "Mint";
  AccountType2[AccountType2["Account"] = 2] = "Account";
})(AccountType || (AccountType = {}));
var ACCOUNT_TYPE_SIZE = 1;

// ../../node_modules/@solana/spl-token/lib/esm/state/multisig.js
var import_buffer_layout5 = __toESM(require_Layout(), 1);
var MultisigLayout = (0, import_buffer_layout5.struct)([
  (0, import_buffer_layout5.u8)("m"),
  (0, import_buffer_layout5.u8)("n"),
  bool2("isInitialized"),
  publicKey2("signer1"),
  publicKey2("signer2"),
  publicKey2("signer3"),
  publicKey2("signer4"),
  publicKey2("signer5"),
  publicKey2("signer6"),
  publicKey2("signer7"),
  publicKey2("signer8"),
  publicKey2("signer9"),
  publicKey2("signer10"),
  publicKey2("signer11")
]);
var MULTISIG_SIZE = MultisigLayout.span;

// ../../node_modules/@solana/spl-token/lib/esm/state/account.js
var AccountState;
(function(AccountState2) {
  AccountState2[AccountState2["Uninitialized"] = 0] = "Uninitialized";
  AccountState2[AccountState2["Initialized"] = 1] = "Initialized";
  AccountState2[AccountState2["Frozen"] = 2] = "Frozen";
})(AccountState || (AccountState = {}));
var AccountLayout = (0, import_buffer_layout6.struct)([
  publicKey2("mint"),
  publicKey2("owner"),
  u643("amount"),
  (0, import_buffer_layout6.u32)("delegateOption"),
  publicKey2("delegate"),
  (0, import_buffer_layout6.u8)("state"),
  (0, import_buffer_layout6.u32)("isNativeOption"),
  u643("isNative"),
  u643("delegatedAmount"),
  (0, import_buffer_layout6.u32)("closeAuthorityOption"),
  publicKey2("closeAuthority")
]);
var ACCOUNT_SIZE = AccountLayout.span;

// ../../node_modules/@solana/spl-token/lib/esm/state/mint.js
var import_buffer_layout7 = __toESM(require_Layout(), 1);
var MintLayout = (0, import_buffer_layout7.struct)([
  (0, import_buffer_layout7.u32)("mintAuthorityOption"),
  publicKey2("mintAuthority"),
  u643("supply"),
  (0, import_buffer_layout7.u8)("decimals"),
  bool2("isInitialized"),
  (0, import_buffer_layout7.u32)("freezeAuthorityOption"),
  publicKey2("freezeAuthority")
]);
var MINT_SIZE = MintLayout.span;
function getMint(_0, _1, _2) {
  return __async(this, arguments, function* (connection, address, commitment, programId = TOKEN_PROGRAM_ID) {
    const info = yield connection.getAccountInfo(address, commitment);
    return unpackMint(address, info, programId);
  });
}
function unpackMint(address, info, programId = TOKEN_PROGRAM_ID) {
  if (!info)
    throw new TokenAccountNotFoundError();
  if (!info.owner.equals(programId))
    throw new TokenInvalidAccountOwnerError();
  if (info.data.length < MINT_SIZE)
    throw new TokenInvalidAccountSizeError();
  const rawMint = MintLayout.decode(info.data.slice(0, MINT_SIZE));
  let tlvData = Buffer.alloc(0);
  if (info.data.length > MINT_SIZE) {
    if (info.data.length <= ACCOUNT_SIZE)
      throw new TokenInvalidAccountSizeError();
    if (info.data.length === MULTISIG_SIZE)
      throw new TokenInvalidAccountSizeError();
    if (info.data[ACCOUNT_SIZE] != AccountType.Mint)
      throw new TokenInvalidMintError();
    tlvData = info.data.slice(ACCOUNT_SIZE + ACCOUNT_TYPE_SIZE);
  }
  return {
    address,
    mintAuthority: rawMint.mintAuthorityOption ? rawMint.mintAuthority : null,
    supply: rawMint.supply,
    decimals: rawMint.decimals,
    isInitialized: rawMint.isInitialized,
    freezeAuthority: rawMint.freezeAuthorityOption ? rawMint.freezeAuthority : null,
    tlvData
  };
}

// ../../node_modules/@solana/spl-token/lib/esm/instructions/transferChecked.js
var import_buffer_layout8 = __toESM(require_Layout(), 1);
var transferCheckedInstructionData = (0, import_buffer_layout8.struct)([
  (0, import_buffer_layout8.u8)("instruction"),
  u643("amount"),
  (0, import_buffer_layout8.u8)("decimals")
]);
function createTransferCheckedInstruction(source, mint, destination, owner, amount, decimals, multiSigners = [], programId = TOKEN_PROGRAM_ID) {
  const keys = addSigners([
    { pubkey: source, isSigner: false, isWritable: true },
    { pubkey: mint, isSigner: false, isWritable: false },
    { pubkey: destination, isSigner: false, isWritable: true }
  ], owner, multiSigners);
  const data = Buffer.alloc(transferCheckedInstructionData.span);
  transferCheckedInstructionData.encode({
    instruction: TokenInstruction.TransferChecked,
    amount: BigInt(amount),
    decimals
  }, data);
  return new TransactionInstruction({ keys, programId, data });
}

// src/configs/token-list.config.ts
var TokenInformation = class {
  constructor(alias, pubkey, decimals) {
    this.alias = alias;
    this.pubkey = pubkey;
    this.decimals = decimals;
  }
  convertSizeToQuantity(size) {
    const decimalMultiplier = 10 ** this.decimals;
    const tokenQuantity = size * decimalMultiplier;
    return Math.floor(tokenQuantity);
  }
  convertQuantityToSize(quantity) {
    const decimalMultiplier = 10 ** this.decimals;
    const tokenSize = quantity / decimalMultiplier;
    return tokenSize;
  }
  static queryTokenInformationFromPubkey(pubkey, connection) {
    return __async(this, null, function* () {
      try {
        const mint = yield getMint(connection, pubkey, "confirmed");
        return new TokenInformation(
          mint.address.toBase58(),
          mint.address,
          mint.decimals
        );
      } catch (e) {
        throw new Error("Token does not exist.");
      }
    });
  }
};
var _TokenRegistry = class {
};
var TokenRegistry = _TokenRegistry;
TokenRegistry.isTokenAlias = (name) => {
  const token = _TokenRegistry.allTokens.find((token2) => {
    return token2.alias == name;
  });
  return token != void 0;
};
TokenRegistry.getTokenFromAlias = (input) => {
  return _TokenRegistry.allTokens.find((token) => {
    return token.alias == input;
  });
};
TokenRegistry.getTokenFromPubkey = (input) => {
  return _TokenRegistry.allTokens.find((token) => {
    return token.pubkey == input;
  });
};
TokenRegistry.getTokenFromPubkeyString = (input) => {
  return _TokenRegistry.allTokens.find((token) => {
    return token.pubkey.toBase58() == input;
  });
};
TokenRegistry.queryTokenInformation = (input, connection) => __async(_TokenRegistry, null, function* () {
  if (connection != void 0) {
    return yield TokenInformation.queryTokenInformationFromPubkey(
      new anchor2.web3.PublicKey(input),
      connection
    );
  }
});
TokenRegistry.allTokens = [
  new TokenInformation("usdc", USDC_PUBKEY, 6),
  new TokenInformation("sol", WSOL_PUBKEY, 9)
];

// src/schemas/pay-request.schema.ts
import { z } from "zod";

// src/utils/pubkey.util.ts
import { web3 as web33 } from "@project-serum/anchor";
var pubkeyOrThrow = (input) => {
  try {
    return new web33.PublicKey(input);
  } catch (e) {
    throw new Error(
      "Could not create a public key with the provided input."
    );
  }
};

// src/schemas/pay-request.schema.ts
var AmountType = {
  Size: "size",
  Quantity: "quantity"
};
var AmountTypeEnum = z.nativeEnum(AmountType);
var TransactionType = {
  Blockhash: "blockhash",
  Nonce: "nonce"
};
var TransactionTypeEnum = z.nativeEnum(TransactionType);
var PayRequest = z.object({
  receiver: z.string().transform(pubkeyOrThrow),
  sender: z.string().transform(pubkeyOrThrow),
  sendingToken: z.string().transform(pubkeyOrThrow),
  receivingToken: z.string().transform(pubkeyOrThrow),
  feePayer: z.string().transform(pubkeyOrThrow),
  receivingAmount: z.string().transform(parseFloat),
  amountType: AmountTypeEnum,
  transactionType: TransactionTypeEnum.default(TransactionType.Blockhash),
  createAta: z.boolean().default(false)
});

// src/utils/ata.util.ts
import { web3 as web34 } from "@project-serum/anchor";
function findAssociatedTokenAddress(walletAddress, tokenMintAddress) {
  return __async(this, null, function* () {
    return (yield web34.PublicKey.findProgramAddress(
      [
        walletAddress.toBuffer(),
        TOKEN_PROGRAM_ID.toBuffer(),
        tokenMintAddress.toBuffer()
      ],
      SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID
    ))[0];
  });
}
var createAssociatedTokenAccountInstruction = (associatedTokenAddress, payer, walletAddress, splTokenMintAddress) => {
  const keys = [
    { pubkey: payer, isSigner: true, isWritable: true },
    { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },
    { pubkey: walletAddress, isSigner: false, isWritable: false },
    { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },
    {
      pubkey: web34.SystemProgram.programId,
      isSigner: false,
      isWritable: false
    },
    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
    {
      pubkey: web34.SYSVAR_RENT_PUBKEY,
      isSigner: false,
      isWritable: false
    }
  ];
  return new web34.TransactionInstruction({
    keys,
    programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,
    data: Buffer.from([])
  });
};

// src/services/builders/transfer-ix.builder.ts
var createTransferIx = (sender, receiver, token, quantity, createAta, connection) => __async(void 0, null, function* () {
  const transferIxs = [];
  var senderAssociatedTokenAddress = yield findAssociatedTokenAddress(
    sender,
    token.pubkey
  );
  var receiverAssociatedTokenAddress = yield findAssociatedTokenAddress(
    receiver,
    token.pubkey
  );
  console.log(senderAssociatedTokenAddress.toBase58());
  console.log(receiverAssociatedTokenAddress.toBase58());
  const info = yield connection.getAccountInfo(receiverAssociatedTokenAddress);
  if (createAta && info == null) {
    const createAssociatedInstruction = createAssociatedTokenAccountInstruction(
      receiverAssociatedTokenAddress,
      sender,
      receiver,
      token.pubkey
    );
    transferIxs.push(createAssociatedInstruction);
  }
  const transfer = createTransferCheckedInstruction(
    senderAssociatedTokenAddress,
    token.pubkey,
    receiverAssociatedTokenAddress,
    sender,
    quantity,
    token.decimals
  );
  transferIxs.push(transfer);
  return transferIxs;
});

// src/utils/jupiter.util.ts
var createJupiterQuoteRequestUrl = (quantity, fromMint, toMint) => {
  const jupiterQuoteUrl = `https://quote-api.jup.ag/v4/quote?inputMint=${fromMint}&outputMint=${toMint}&amount=${quantity}&slippageBps=1&swapMode=ExactOut`;
  return jupiterQuoteUrl;
};

// src/services/swaps/jupiter.service.ts
var import_axios = __toESM(require_axios2());
import * as anchor3 from "@project-serum/anchor";
var NO_QUOTE_FROM_JUPITER_ERROR_MESSAGE = "There was no quote availible for your swap.";
var NO_SWAP_FROM_JUPITER_ERROR_MESSAGE = "There was no quote availible for your swap.";
var JUPITER_SWAP_REQUEST_URL = "https://quote-api.jup.ag/v1/swap";
var createJupiterSwapIx = (config) => __async(void 0, null, function* () {
  var { data } = yield import_axios.default.get(
    createJupiterQuoteRequestUrl(
      config.quantity,
      config.fromMint,
      config.toMint
    )
  );
  if (data == null || data == void 0 || data.data == null || data.data == void 0) {
    throw new Error(NO_QUOTE_FROM_JUPITER_ERROR_MESSAGE);
  }
  const route = data.data[0];
  const responseTransactions = yield import_axios.default.post(
    JUPITER_SWAP_REQUEST_URL,
    JSON.stringify({
      route,
      userPublicKey: config.swapingWallet.toBase58(),
      wrapUnwrapSOL: true
    }),
    {
      headers: {
        "Content-Type": "application/json"
      }
    }
  );
  const { swapTransaction } = responseTransactions.data;
  if (swapTransaction == null || swapTransaction == void 0) {
    throw new Error(NO_SWAP_FROM_JUPITER_ERROR_MESSAGE);
  }
  const swapTransactionBuf = Buffer.from(swapTransaction, "base64");
  const swapTransactionIxs = anchor3.web3.Transaction.from(swapTransactionBuf).instructions;
  return swapTransactionIxs;
});

// src/services/swaps/create-swap-ix.service.ts
var createSwapIx = (config) => __async(void 0, null, function* () {
  switch (config.provider) {
    case "jupiter":
      return createJupiterSwapIx(config);
  }
});

// src/utils/connection.util.ts
import { web3 as web36 } from "@project-serum/anchor";
var createConnection = () => {
  return new web36.Connection(
    "https://rpc.helius.xyz/?api-key=5f70b753-57cb-422b-a018-d7df67b4470e"
  );
};

// src/index.ts
var createPayTransaction = (payRequest) => __async(void 0, null, function* () {
  let connection;
  let transaction;
  let receivingQuantity;
  var swapIxs = [];
  var transferIxs = [];
  try {
    connection = createConnection();
  } catch (error) {
    throw error;
  }
  const blockhash = yield connection.getLatestBlockhash();
  switch (payRequest.transactionType) {
    case "blockhash":
      transaction = new web37.Transaction({
        feePayer: payRequest.feePayer,
        blockhash: blockhash.blockhash,
        lastValidBlockHeight: blockhash.lastValidBlockHeight
      });
    case "nonce":
      transaction = new web37.Transaction({
        feePayer: payRequest.feePayer,
        blockhash: blockhash.blockhash,
        lastValidBlockHeight: blockhash.lastValidBlockHeight
      });
  }
  const receivingTokenInformation = yield TokenInformation.queryTokenInformationFromPubkey(
    payRequest.receivingToken,
    connection
  );
  switch (payRequest.amountType) {
    case "quantity":
      receivingQuantity = payRequest.receivingAmount;
    case "size":
      receivingQuantity = receivingTokenInformation.convertSizeToQuantity(
        payRequest.receivingAmount
      );
  }
  if (payRequest.sendingToken.toBase58() != payRequest.receivingToken.toBase58()) {
    swapIxs = yield createSwapIx({
      provider: "jupiter",
      quantity: receivingQuantity,
      fromMint: payRequest.sendingToken,
      toMint: payRequest.receivingToken,
      swapingWallet: payRequest.feePayer
    });
  }
  transferIxs = yield createTransferIx(
    payRequest.sender,
    payRequest.receiver,
    receivingTokenInformation,
    receivingQuantity,
    payRequest.createAta,
    connection
  );
  transaction = transaction.add(...swapIxs, ...transferIxs);
  return transaction;
});
var createSamplePayRequest = () => {
  const payRequest = PayRequest.parse({
    receiver: "5rPoLqhSC2VnMULYfzYX4712GEFNFv8nof6K6nP7GX8E",
    sender: "ExvbioyTPuFivNJjPcYiCbHijTWPAHzfRXHnAmA4cyRx",
    sendingToken: USDC_PUBKEY.toBase58(),
    receivingToken: USDC_PUBKEY.toBase58(),
    feePayer: "ExvbioyTPuFivNJjPcYiCbHijTWPAHzfRXHnAmA4cyRx",
    receivingAmount: 10,
    amountType: "size",
    transactionType: "blockhash",
    createAta: true
  });
  return payRequest;
};
export {
  PayRequest,
  createPayTransaction,
  createSamplePayRequest
};
/*! Bundled license information:

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@solana/buffer-layout/lib/Layout.js:
  (**
   * Support for translating between Uint8Array instances and JavaScript
   * native types.
   *
   * {@link module:Layout~Layout|Layout} is the basis of a class
   * hierarchy that associates property names with sequences of encoded
   * bytes.
   *
   * Layouts are supported for these scalar (numeric) types:
   * * {@link module:Layout~UInt|Unsigned integers in little-endian
   *   format} with {@link module:Layout.u8|8-bit}, {@link
   *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},
   *   {@link module:Layout.u32|32-bit}, {@link
   *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~UIntBE|Unsigned integers in big-endian
   *   format} with {@link module:Layout.u16be|16-bit}, {@link
   *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},
   *   {@link module:Layout.u40be|40-bit}, and {@link
   *   module:Layout.u48be|48-bit} representation ranges;
   * * {@link module:Layout~Int|Signed integers in little-endian
   *   format} with {@link module:Layout.s8|8-bit}, {@link
   *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},
   *   {@link module:Layout.s32|32-bit}, {@link
   *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}
   *   representation ranges;
   * * {@link module:Layout~IntBE|Signed integers in big-endian format}
   *   with {@link module:Layout.s16be|16-bit}, {@link
   *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},
   *   {@link module:Layout.s40be|40-bit}, and {@link
   *   module:Layout.s48be|48-bit} representation ranges;
   * * 64-bit integral values that decode to an exact (if magnitude is
   *   less than 2^53) or nearby integral Number in {@link
   *   module:Layout.nu64|unsigned little-endian}, {@link
   *   module:Layout.nu64be|unsigned big-endian}, {@link
   *   module:Layout.ns64|signed little-endian}, and {@link
   *   module:Layout.ns64be|unsigned big-endian} encodings;
   * * 32-bit floating point values with {@link
   *   module:Layout.f32|little-endian} and {@link
   *   module:Layout.f32be|big-endian} representations;
   * * 64-bit floating point values with {@link
   *   module:Layout.f64|little-endian} and {@link
   *   module:Layout.f64be|big-endian} representations;
   * * {@link module:Layout.const|Constants} that take no space in the
   *   encoded expression.
   *
   * and for these aggregate types:
   * * {@link module:Layout.seq|Sequence}s of instances of a {@link
   *   module:Layout~Layout|Layout}, with JavaScript representation as
   *   an Array and constant or data-dependent {@link
   *   module:Layout~Sequence#count|length};
   * * {@link module:Layout.struct|Structure}s that aggregate a
   *   heterogeneous sequence of {@link module:Layout~Layout|Layout}
   *   instances, with JavaScript representation as an Object;
   * * {@link module:Layout.union|Union}s that support multiple {@link
   *   module:Layout~VariantLayout|variant layouts} over a fixed
   *   (padded) or variable (not padded) span of bytes, using an
   *   unsigned integer at the start of the data or a separate {@link
   *   module:Layout.unionLayoutDiscriminator|layout element} to
   *   determine which layout to use when interpreting the buffer
   *   contents;
   * * {@link module:Layout.bits|BitStructure}s that contain a sequence
   *   of individual {@link
   *   module:Layout~BitStructure#addField|BitField}s packed into an 8,
   *   16, 24, or 32-bit unsigned integer starting at the least- or
   *   most-significant bit;
   * * {@link module:Layout.cstr|C strings} of varying length;
   * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link
   *   module:Layout~Blob#length|length} raw data.
   *
   * All {@link module:Layout~Layout|Layout} instances are immutable
   * after construction, to prevent internal state from becoming
   * inconsistent.
   *
   * @local Layout
   * @local ExternalLayout
   * @local GreedyCount
   * @local OffsetLayout
   * @local UInt
   * @local UIntBE
   * @local Int
   * @local IntBE
   * @local NearUInt64
   * @local NearUInt64BE
   * @local NearInt64
   * @local NearInt64BE
   * @local Float
   * @local FloatBE
   * @local Double
   * @local DoubleBE
   * @local Sequence
   * @local Structure
   * @local UnionDiscriminator
   * @local UnionLayoutDiscriminator
   * @local Union
   * @local VariantLayout
   * @local BitStructure
   * @local BitField
   * @local Boolean
   * @local Blob
   * @local CString
   * @local Constant
   * @local bindConstructorLayout
   * @module Layout
   * @license MIT
   * @author Peter A. Bigot
   * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}
   *)

@babel/runtime/helpers/regeneratorRuntime.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/ed25519/lib/esm/index.js:
  (*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)

@noble/secp256k1/lib/esm/index.js:
  (*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) *)

@solana/web3.js/lib/index.esm.js:
  (*!
   * humanize-ms - index.js
   * Copyright(c) 2014 dead_horse <dead_horse@qq.com>
   * MIT Licensed
   *)
  (*!
   * depd
   * Copyright(c) 2014 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*!
   * depd
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*!
   * depd
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*!
   * depd
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
